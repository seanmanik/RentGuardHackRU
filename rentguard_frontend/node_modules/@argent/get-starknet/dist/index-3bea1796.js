var A2 = Object.defineProperty;
var I2 = (e, t, r) => t in e ? A2(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Ee = (e, t, r) => (I2(e, typeof t != "symbol" ? t + "" : t, r), r);
var Et = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function os(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Dl(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      if (this instanceof n) {
        var a = [null];
        a.push.apply(a, arguments);
        var i = Function.bind.apply(t, a);
        return new i();
      }
      return t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var a = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, a.get ? a : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var wo = { exports: {} }, jn = typeof Reflect == "object" ? Reflect : null, Zf = jn && typeof jn.apply == "function" ? jn.apply : function(t, r, n) {
  return Function.prototype.apply.call(t, r, n);
}, Bi;
jn && typeof jn.ownKeys == "function" ? Bi = jn.ownKeys : Object.getOwnPropertySymbols ? Bi = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : Bi = function(t) {
  return Object.getOwnPropertyNames(t);
};
function C2(e) {
  console && console.warn && console.warn(e);
}
var Al = Number.isNaN || function(t) {
  return t !== t;
};
function Oe() {
  Oe.init.call(this);
}
wo.exports = Oe;
wo.exports.once = R2;
Oe.EventEmitter = Oe;
Oe.prototype._events = void 0;
Oe.prototype._eventsCount = 0;
Oe.prototype._maxListeners = void 0;
var Yf = 10;
function fs(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(Oe, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Yf;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || Al(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    Yf = e;
  }
});
Oe.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Oe.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || Al(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function Il(e) {
  return e._maxListeners === void 0 ? Oe.defaultMaxListeners : e._maxListeners;
}
Oe.prototype.getMaxListeners = function() {
  return Il(this);
};
Oe.prototype.emit = function(t) {
  for (var r = [], n = 1; n < arguments.length; n++)
    r.push(arguments[n]);
  var a = t === "error", i = this._events;
  if (i !== void 0)
    a = a && i.error === void 0;
  else if (!a)
    return !1;
  if (a) {
    var c;
    if (r.length > 0 && (c = r[0]), c instanceof Error)
      throw c;
    var s = new Error("Unhandled error." + (c ? " (" + c.message + ")" : ""));
    throw s.context = c, s;
  }
  var d = i[t];
  if (d === void 0)
    return !1;
  if (typeof d == "function")
    Zf(d, this, r);
  else
    for (var f = d.length, l = Rl(d, f), n = 0; n < f; ++n)
      Zf(l[n], this, r);
  return !0;
};
function Cl(e, t, r, n) {
  var a, i, c;
  if (fs(r), i = e._events, i === void 0 ? (i = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (i.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    r.listener ? r.listener : r
  ), i = e._events), c = i[t]), c === void 0)
    c = i[t] = r, ++e._eventsCount;
  else if (typeof c == "function" ? c = i[t] = n ? [r, c] : [c, r] : n ? c.unshift(r) : c.push(r), a = Il(e), a > 0 && c.length > a && !c.warned) {
    c.warned = !0;
    var s = new Error("Possible EventEmitter memory leak detected. " + c.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    s.name = "MaxListenersExceededWarning", s.emitter = e, s.type = t, s.count = c.length, C2(s);
  }
  return e;
}
Oe.prototype.addListener = function(t, r) {
  return Cl(this, t, r, !1);
};
Oe.prototype.on = Oe.prototype.addListener;
Oe.prototype.prependListener = function(t, r) {
  return Cl(this, t, r, !0);
};
function T2() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Tl(e, t, r) {
  var n = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, a = T2.bind(n);
  return a.listener = r, n.wrapFn = a, a;
}
Oe.prototype.once = function(t, r) {
  return fs(r), this.on(t, Tl(this, t, r)), this;
};
Oe.prototype.prependOnceListener = function(t, r) {
  return fs(r), this.prependListener(t, Tl(this, t, r)), this;
};
Oe.prototype.removeListener = function(t, r) {
  var n, a, i, c, s;
  if (fs(r), a = this._events, a === void 0)
    return this;
  if (n = a[t], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete a[t], a.removeListener && this.emit("removeListener", t, n.listener || r));
  else if (typeof n != "function") {
    for (i = -1, c = n.length - 1; c >= 0; c--)
      if (n[c] === r || n[c].listener === r) {
        s = n[c].listener, i = c;
        break;
      }
    if (i < 0)
      return this;
    i === 0 ? n.shift() : O2(n, i), n.length === 1 && (a[t] = n[0]), a.removeListener !== void 0 && this.emit("removeListener", t, s || r);
  }
  return this;
};
Oe.prototype.off = Oe.prototype.removeListener;
Oe.prototype.removeAllListeners = function(t) {
  var r, n, a;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[t]), this;
  if (arguments.length === 0) {
    var i = Object.keys(n), c;
    for (a = 0; a < i.length; ++a)
      c = i[a], c !== "removeListener" && this.removeAllListeners(c);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[t], typeof r == "function")
    this.removeListener(t, r);
  else if (r !== void 0)
    for (a = r.length - 1; a >= 0; a--)
      this.removeListener(t, r[a]);
  return this;
};
function Ol(e, t, r) {
  var n = e._events;
  if (n === void 0)
    return [];
  var a = n[t];
  return a === void 0 ? [] : typeof a == "function" ? r ? [a.listener || a] : [a] : r ? N2(a) : Rl(a, a.length);
}
Oe.prototype.listeners = function(t) {
  return Ol(this, t, !0);
};
Oe.prototype.rawListeners = function(t) {
  return Ol(this, t, !1);
};
Oe.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : Nl.call(e, t);
};
Oe.prototype.listenerCount = Nl;
function Nl(e) {
  var t = this._events;
  if (t !== void 0) {
    var r = t[e];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
Oe.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Bi(this._events) : [];
};
function Rl(e, t) {
  for (var r = new Array(t), n = 0; n < t; ++n)
    r[n] = e[n];
  return r;
}
function O2(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function N2(e) {
  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
    t[r] = e[r].listener || e[r];
  return t;
}
function R2(e, t) {
  return new Promise(function(r, n) {
    function a(c) {
      e.removeListener(t, i), n(c);
    }
    function i() {
      typeof e.removeListener == "function" && e.removeListener("error", a), r([].slice.call(arguments));
    }
    Ll(e, t, i, { once: !0 }), t !== "error" && L2(e, a, { once: !0 });
  });
}
function L2(e, t, r) {
  typeof e.on == "function" && Ll(e, "error", t, r);
}
function Ll(e, t, r, n) {
  if (typeof e.on == "function")
    n.once ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function a(i) {
      n.once && e.removeEventListener(t, a), r(i);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var zt = wo.exports;
const Pl = /* @__PURE__ */ os(zt);
var ds = {}, kl = { exports: {} };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
(function(e) {
  var t, r, n, a, i, c, s, d, f, l, p, w, g, m, S, I, N, x, C, _, D, b, o;
  (function(h) {
    var U = typeof Et == "object" ? Et : typeof self == "object" ? self : typeof this == "object" ? this : {};
    h(E(U, E(e.exports)));
    function E(T, P) {
      return T !== U && (typeof Object.create == "function" ? Object.defineProperty(T, "__esModule", { value: !0 }) : T.__esModule = !0), function(z, v) {
        return T[z] = P ? P(z, v) : v;
      };
    }
  })(function(h) {
    var U = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(E, T) {
      E.__proto__ = T;
    } || function(E, T) {
      for (var P in T)
        T.hasOwnProperty(P) && (E[P] = T[P]);
    };
    t = function(E, T) {
      U(E, T);
      function P() {
        this.constructor = E;
      }
      E.prototype = T === null ? Object.create(T) : (P.prototype = T.prototype, new P());
    }, r = Object.assign || function(E) {
      for (var T, P = 1, z = arguments.length; P < z; P++) {
        T = arguments[P];
        for (var v in T)
          Object.prototype.hasOwnProperty.call(T, v) && (E[v] = T[v]);
      }
      return E;
    }, n = function(E, T) {
      var P = {};
      for (var z in E)
        Object.prototype.hasOwnProperty.call(E, z) && T.indexOf(z) < 0 && (P[z] = E[z]);
      if (E != null && typeof Object.getOwnPropertySymbols == "function")
        for (var v = 0, z = Object.getOwnPropertySymbols(E); v < z.length; v++)
          T.indexOf(z[v]) < 0 && Object.prototype.propertyIsEnumerable.call(E, z[v]) && (P[z[v]] = E[z[v]]);
      return P;
    }, a = function(E, T, P, z) {
      var v = arguments.length, y = v < 3 ? T : z === null ? z = Object.getOwnPropertyDescriptor(T, P) : z, L;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        y = Reflect.decorate(E, T, P, z);
      else
        for (var M = E.length - 1; M >= 0; M--)
          (L = E[M]) && (y = (v < 3 ? L(y) : v > 3 ? L(T, P, y) : L(T, P)) || y);
      return v > 3 && y && Object.defineProperty(T, P, y), y;
    }, i = function(E, T) {
      return function(P, z) {
        T(P, z, E);
      };
    }, c = function(E, T) {
      if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(E, T);
    }, s = function(E, T, P, z) {
      function v(y) {
        return y instanceof P ? y : new P(function(L) {
          L(y);
        });
      }
      return new (P || (P = Promise))(function(y, L) {
        function M(j) {
          try {
            F(z.next(j));
          } catch (V) {
            L(V);
          }
        }
        function H(j) {
          try {
            F(z.throw(j));
          } catch (V) {
            L(V);
          }
        }
        function F(j) {
          j.done ? y(j.value) : v(j.value).then(M, H);
        }
        F((z = z.apply(E, T || [])).next());
      });
    }, d = function(E, T) {
      var P = { label: 0, sent: function() {
        if (y[0] & 1)
          throw y[1];
        return y[1];
      }, trys: [], ops: [] }, z, v, y, L;
      return L = { next: M(0), throw: M(1), return: M(2) }, typeof Symbol == "function" && (L[Symbol.iterator] = function() {
        return this;
      }), L;
      function M(F) {
        return function(j) {
          return H([F, j]);
        };
      }
      function H(F) {
        if (z)
          throw new TypeError("Generator is already executing.");
        for (; P; )
          try {
            if (z = 1, v && (y = F[0] & 2 ? v.return : F[0] ? v.throw || ((y = v.return) && y.call(v), 0) : v.next) && !(y = y.call(v, F[1])).done)
              return y;
            switch (v = 0, y && (F = [F[0] & 2, y.value]), F[0]) {
              case 0:
              case 1:
                y = F;
                break;
              case 4:
                return P.label++, { value: F[1], done: !1 };
              case 5:
                P.label++, v = F[1], F = [0];
                continue;
              case 7:
                F = P.ops.pop(), P.trys.pop();
                continue;
              default:
                if (y = P.trys, !(y = y.length > 0 && y[y.length - 1]) && (F[0] === 6 || F[0] === 2)) {
                  P = 0;
                  continue;
                }
                if (F[0] === 3 && (!y || F[1] > y[0] && F[1] < y[3])) {
                  P.label = F[1];
                  break;
                }
                if (F[0] === 6 && P.label < y[1]) {
                  P.label = y[1], y = F;
                  break;
                }
                if (y && P.label < y[2]) {
                  P.label = y[2], P.ops.push(F);
                  break;
                }
                y[2] && P.ops.pop(), P.trys.pop();
                continue;
            }
            F = T.call(E, P);
          } catch (j) {
            F = [6, j], v = 0;
          } finally {
            z = y = 0;
          }
        if (F[0] & 5)
          throw F[1];
        return { value: F[0] ? F[1] : void 0, done: !0 };
      }
    }, o = function(E, T, P, z) {
      z === void 0 && (z = P), E[z] = T[P];
    }, f = function(E, T) {
      for (var P in E)
        P !== "default" && !T.hasOwnProperty(P) && (T[P] = E[P]);
    }, l = function(E) {
      var T = typeof Symbol == "function" && Symbol.iterator, P = T && E[T], z = 0;
      if (P)
        return P.call(E);
      if (E && typeof E.length == "number")
        return {
          next: function() {
            return E && z >= E.length && (E = void 0), { value: E && E[z++], done: !E };
          }
        };
      throw new TypeError(T ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, p = function(E, T) {
      var P = typeof Symbol == "function" && E[Symbol.iterator];
      if (!P)
        return E;
      var z = P.call(E), v, y = [], L;
      try {
        for (; (T === void 0 || T-- > 0) && !(v = z.next()).done; )
          y.push(v.value);
      } catch (M) {
        L = { error: M };
      } finally {
        try {
          v && !v.done && (P = z.return) && P.call(z);
        } finally {
          if (L)
            throw L.error;
        }
      }
      return y;
    }, w = function() {
      for (var E = [], T = 0; T < arguments.length; T++)
        E = E.concat(p(arguments[T]));
      return E;
    }, g = function() {
      for (var E = 0, T = 0, P = arguments.length; T < P; T++)
        E += arguments[T].length;
      for (var z = Array(E), v = 0, T = 0; T < P; T++)
        for (var y = arguments[T], L = 0, M = y.length; L < M; L++, v++)
          z[v] = y[L];
      return z;
    }, m = function(E) {
      return this instanceof m ? (this.v = E, this) : new m(E);
    }, S = function(E, T, P) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var z = P.apply(E, T || []), v, y = [];
      return v = {}, L("next"), L("throw"), L("return"), v[Symbol.asyncIterator] = function() {
        return this;
      }, v;
      function L(W) {
        z[W] && (v[W] = function(K) {
          return new Promise(function(Q, Z) {
            y.push([W, K, Q, Z]) > 1 || M(W, K);
          });
        });
      }
      function M(W, K) {
        try {
          H(z[W](K));
        } catch (Q) {
          V(y[0][3], Q);
        }
      }
      function H(W) {
        W.value instanceof m ? Promise.resolve(W.value.v).then(F, j) : V(y[0][2], W);
      }
      function F(W) {
        M("next", W);
      }
      function j(W) {
        M("throw", W);
      }
      function V(W, K) {
        W(K), y.shift(), y.length && M(y[0][0], y[0][1]);
      }
    }, I = function(E) {
      var T, P;
      return T = {}, z("next"), z("throw", function(v) {
        throw v;
      }), z("return"), T[Symbol.iterator] = function() {
        return this;
      }, T;
      function z(v, y) {
        T[v] = E[v] ? function(L) {
          return (P = !P) ? { value: m(E[v](L)), done: v === "return" } : y ? y(L) : L;
        } : y;
      }
    }, N = function(E) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var T = E[Symbol.asyncIterator], P;
      return T ? T.call(E) : (E = typeof l == "function" ? l(E) : E[Symbol.iterator](), P = {}, z("next"), z("throw"), z("return"), P[Symbol.asyncIterator] = function() {
        return this;
      }, P);
      function z(y) {
        P[y] = E[y] && function(L) {
          return new Promise(function(M, H) {
            L = E[y](L), v(M, H, L.done, L.value);
          });
        };
      }
      function v(y, L, M, H) {
        Promise.resolve(H).then(function(F) {
          y({ value: F, done: M });
        }, L);
      }
    }, x = function(E, T) {
      return Object.defineProperty ? Object.defineProperty(E, "raw", { value: T }) : E.raw = T, E;
    }, C = function(E) {
      if (E && E.__esModule)
        return E;
      var T = {};
      if (E != null)
        for (var P in E)
          Object.hasOwnProperty.call(E, P) && (T[P] = E[P]);
      return T.default = E, T;
    }, _ = function(E) {
      return E && E.__esModule ? E : { default: E };
    }, D = function(E, T) {
      if (!T.has(E))
        throw new TypeError("attempted to get private field on non-instance");
      return T.get(E);
    }, b = function(E, T, P) {
      if (!T.has(E))
        throw new TypeError("attempted to set private field on non-instance");
      return T.set(E, P), P;
    }, h("__extends", t), h("__assign", r), h("__rest", n), h("__decorate", a), h("__param", i), h("__metadata", c), h("__awaiter", s), h("__generator", d), h("__exportStar", f), h("__createBinding", o), h("__values", l), h("__read", p), h("__spread", w), h("__spreadArrays", g), h("__await", m), h("__asyncGenerator", S), h("__asyncDelegator", I), h("__asyncValues", N), h("__makeTemplateObject", x), h("__importStar", C), h("__importDefault", _), h("__classPrivateFieldGet", D), h("__classPrivateFieldSet", b);
  });
})(kl);
var Xt = kl.exports, ei = {};
Object.defineProperty(ei, "__esModule", { value: !0 });
function P2(e) {
  if (typeof e != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof e}`);
  try {
    return JSON.parse(e);
  } catch {
    return e;
  }
}
ei.safeJsonParse = P2;
function k2(e) {
  return typeof e == "string" ? e : JSON.stringify(e, (t, r) => typeof r > "u" ? null : r);
}
ei.safeJsonStringify = k2;
var pa = { exports: {} }, Xf;
function U2() {
  return Xf || (Xf = 1, function() {
    let e;
    function t() {
    }
    e = t, e.prototype.getItem = function(r) {
      return this.hasOwnProperty(r) ? String(this[r]) : null;
    }, e.prototype.setItem = function(r, n) {
      this[r] = String(n);
    }, e.prototype.removeItem = function(r) {
      delete this[r];
    }, e.prototype.clear = function() {
      const r = this;
      Object.keys(r).forEach(function(n) {
        r[n] = void 0, delete r[n];
      });
    }, e.prototype.key = function(r) {
      return r = r || 0, Object.keys(this)[r];
    }, e.prototype.__defineGetter__("length", function() {
      return Object.keys(this).length;
    }), typeof Et < "u" && Et.localStorage ? pa.exports = Et.localStorage : typeof window < "u" && window.localStorage ? pa.exports = window.localStorage : pa.exports = new t();
  }()), pa.exports;
}
var Hs = {}, ga = {}, Jf;
function F2() {
  if (Jf)
    return ga;
  Jf = 1, Object.defineProperty(ga, "__esModule", { value: !0 }), ga.IKeyValueStorage = void 0;
  class e {
  }
  return ga.IKeyValueStorage = e, ga;
}
var _a = {}, Qf;
function $2() {
  if (Qf)
    return _a;
  Qf = 1, Object.defineProperty(_a, "__esModule", { value: !0 }), _a.parseEntry = void 0;
  const e = ei;
  function t(r) {
    var n;
    return [r[0], e.safeJsonParse((n = r[1]) !== null && n !== void 0 ? n : "")];
  }
  return _a.parseEntry = t, _a;
}
var ed;
function B2() {
  return ed || (ed = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 });
    const t = Xt;
    t.__exportStar(F2(), e), t.__exportStar($2(), e);
  }(Hs)), Hs;
}
Object.defineProperty(ds, "__esModule", { value: !0 });
ds.KeyValueStorage = void 0;
const Un = Xt, td = ei, M2 = Un.__importDefault(U2()), H2 = B2();
class Ul {
  constructor() {
    this.localStorage = M2.default;
  }
  getKeys() {
    return Un.__awaiter(this, void 0, void 0, function* () {
      return Object.keys(this.localStorage);
    });
  }
  getEntries() {
    return Un.__awaiter(this, void 0, void 0, function* () {
      return Object.entries(this.localStorage).map(H2.parseEntry);
    });
  }
  getItem(t) {
    return Un.__awaiter(this, void 0, void 0, function* () {
      const r = this.localStorage.getItem(t);
      if (r !== null)
        return td.safeJsonParse(r);
    });
  }
  setItem(t, r) {
    return Un.__awaiter(this, void 0, void 0, function* () {
      this.localStorage.setItem(t, td.safeJsonStringify(r));
    });
  }
  removeItem(t) {
    return Un.__awaiter(this, void 0, void 0, function* () {
      this.localStorage.removeItem(t);
    });
  }
}
ds.KeyValueStorage = Ul;
var z2 = ds.default = Ul, ti = {}, ya = {}, re = {}, zs = {}, wa = {}, rd;
function j2() {
  if (rd)
    return wa;
  rd = 1, Object.defineProperty(wa, "__esModule", { value: !0 }), wa.delay = void 0;
  function e(t) {
    return new Promise((r) => {
      setTimeout(() => {
        r(!0);
      }, t);
    });
  }
  return wa.delay = e, wa;
}
var sn = {}, js = {}, cn = {}, nd;
function V2() {
  return nd || (nd = 1, Object.defineProperty(cn, "__esModule", { value: !0 }), cn.ONE_THOUSAND = cn.ONE_HUNDRED = void 0, cn.ONE_HUNDRED = 100, cn.ONE_THOUSAND = 1e3), cn;
}
var Vs = {}, ad;
function q2() {
  return ad || (ad = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ONE_YEAR = e.FOUR_WEEKS = e.THREE_WEEKS = e.TWO_WEEKS = e.ONE_WEEK = e.THIRTY_DAYS = e.SEVEN_DAYS = e.FIVE_DAYS = e.THREE_DAYS = e.ONE_DAY = e.TWENTY_FOUR_HOURS = e.TWELVE_HOURS = e.SIX_HOURS = e.THREE_HOURS = e.ONE_HOUR = e.SIXTY_MINUTES = e.THIRTY_MINUTES = e.TEN_MINUTES = e.FIVE_MINUTES = e.ONE_MINUTE = e.SIXTY_SECONDS = e.THIRTY_SECONDS = e.TEN_SECONDS = e.FIVE_SECONDS = e.ONE_SECOND = void 0, e.ONE_SECOND = 1, e.FIVE_SECONDS = 5, e.TEN_SECONDS = 10, e.THIRTY_SECONDS = 30, e.SIXTY_SECONDS = 60, e.ONE_MINUTE = e.SIXTY_SECONDS, e.FIVE_MINUTES = e.ONE_MINUTE * 5, e.TEN_MINUTES = e.ONE_MINUTE * 10, e.THIRTY_MINUTES = e.ONE_MINUTE * 30, e.SIXTY_MINUTES = e.ONE_MINUTE * 60, e.ONE_HOUR = e.SIXTY_MINUTES, e.THREE_HOURS = e.ONE_HOUR * 3, e.SIX_HOURS = e.ONE_HOUR * 6, e.TWELVE_HOURS = e.ONE_HOUR * 12, e.TWENTY_FOUR_HOURS = e.ONE_HOUR * 24, e.ONE_DAY = e.TWENTY_FOUR_HOURS, e.THREE_DAYS = e.ONE_DAY * 3, e.FIVE_DAYS = e.ONE_DAY * 5, e.SEVEN_DAYS = e.ONE_DAY * 7, e.THIRTY_DAYS = e.ONE_DAY * 30, e.ONE_WEEK = e.SEVEN_DAYS, e.TWO_WEEKS = e.ONE_WEEK * 2, e.THREE_WEEKS = e.ONE_WEEK * 3, e.FOUR_WEEKS = e.ONE_WEEK * 4, e.ONE_YEAR = e.ONE_DAY * 365;
  }(Vs)), Vs;
}
var id;
function Fl() {
  return id || (id = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 });
    const t = Xt;
    t.__exportStar(V2(), e), t.__exportStar(q2(), e);
  }(js)), js;
}
var sd;
function K2() {
  if (sd)
    return sn;
  sd = 1, Object.defineProperty(sn, "__esModule", { value: !0 }), sn.fromMiliseconds = sn.toMiliseconds = void 0;
  const e = Fl();
  function t(n) {
    return n * e.ONE_THOUSAND;
  }
  sn.toMiliseconds = t;
  function r(n) {
    return Math.floor(n / e.ONE_THOUSAND);
  }
  return sn.fromMiliseconds = r, sn;
}
var cd;
function G2() {
  return cd || (cd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 });
    const t = Xt;
    t.__exportStar(j2(), e), t.__exportStar(K2(), e);
  }(zs)), zs;
}
var Rn = {}, od;
function W2() {
  if (od)
    return Rn;
  od = 1, Object.defineProperty(Rn, "__esModule", { value: !0 }), Rn.Watch = void 0;
  class e {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(r) {
      if (this.timestamps.has(r))
        throw new Error(`Watch already started for label: ${r}`);
      this.timestamps.set(r, { started: Date.now() });
    }
    stop(r) {
      const n = this.get(r);
      if (typeof n.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${r}`);
      const a = Date.now() - n.started;
      this.timestamps.set(r, { started: n.started, elapsed: a });
    }
    get(r) {
      const n = this.timestamps.get(r);
      if (typeof n > "u")
        throw new Error(`No timestamp found for label: ${r}`);
      return n;
    }
    elapsed(r) {
      const n = this.get(r);
      return n.elapsed || Date.now() - n.started;
    }
  }
  return Rn.Watch = e, Rn.default = e, Rn;
}
var qs = {}, ma = {}, fd;
function Z2() {
  if (fd)
    return ma;
  fd = 1, Object.defineProperty(ma, "__esModule", { value: !0 }), ma.IWatch = void 0;
  class e {
  }
  return ma.IWatch = e, ma;
}
var dd;
function Y2() {
  return dd || (dd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), Xt.__exportStar(Z2(), e);
  }(qs)), qs;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  const t = Xt;
  t.__exportStar(G2(), e), t.__exportStar(W2(), e), t.__exportStar(Y2(), e), t.__exportStar(Fl(), e);
})(re);
var Ks = {}, Ea = {};
let An = class {
};
const X2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IEvents: An
}, Symbol.toStringTag, { value: "Module" })), J2 = /* @__PURE__ */ Dl(X2);
var ld;
function Q2() {
  if (ld)
    return Ea;
  ld = 1, Object.defineProperty(Ea, "__esModule", { value: !0 }), Ea.IHeartBeat = void 0;
  const e = J2;
  class t extends e.IEvents {
    constructor(n) {
      super();
    }
  }
  return Ea.IHeartBeat = t, Ea;
}
var ud;
function $l() {
  return ud || (ud = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), Xt.__exportStar(Q2(), e);
  }(Ks)), Ks;
}
var Gs = {}, on = {}, hd;
function e6() {
  if (hd)
    return on;
  hd = 1, Object.defineProperty(on, "__esModule", { value: !0 }), on.HEARTBEAT_EVENTS = on.HEARTBEAT_INTERVAL = void 0;
  const e = re;
  return on.HEARTBEAT_INTERVAL = e.FIVE_SECONDS, on.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  }, on;
}
var bd;
function Bl() {
  return bd || (bd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), Xt.__exportStar(e6(), e);
  }(Gs)), Gs;
}
var pd;
function t6() {
  if (pd)
    return ya;
  pd = 1, Object.defineProperty(ya, "__esModule", { value: !0 }), ya.HeartBeat = void 0;
  const e = Xt, t = zt, r = re, n = $l(), a = Bl();
  class i extends n.IHeartBeat {
    constructor(s) {
      super(s), this.events = new t.EventEmitter(), this.interval = a.HEARTBEAT_INTERVAL, this.interval = s?.interval || a.HEARTBEAT_INTERVAL;
    }
    static init(s) {
      return e.__awaiter(this, void 0, void 0, function* () {
        const d = new i(s);
        return yield d.init(), d;
      });
    }
    init() {
      return e.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize();
      });
    }
    stop() {
      clearInterval(this.intervalRef);
    }
    on(s, d) {
      this.events.on(s, d);
    }
    once(s, d) {
      this.events.once(s, d);
    }
    off(s, d) {
      this.events.off(s, d);
    }
    removeListener(s, d) {
      this.events.removeListener(s, d);
    }
    initialize() {
      return e.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(() => this.pulse(), r.toMiliseconds(this.interval));
      });
    }
    pulse() {
      this.events.emit(a.HEARTBEAT_EVENTS.pulse);
    }
  }
  return ya.HeartBeat = i, ya;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  const t = Xt;
  t.__exportStar(t6(), e), t.__exportStar($l(), e), t.__exportStar(Bl(), e);
})(ti);
var xe = {}, Ws, gd;
function r6() {
  if (gd)
    return Ws;
  gd = 1;
  function e(r) {
    try {
      return JSON.stringify(r);
    } catch {
      return '"[Circular]"';
    }
  }
  Ws = t;
  function t(r, n, a) {
    var i = a && a.stringify || e, c = 1;
    if (typeof r == "object" && r !== null) {
      var s = n.length + c;
      if (s === 1)
        return r;
      var d = new Array(s);
      d[0] = i(r);
      for (var f = 1; f < s; f++)
        d[f] = i(n[f]);
      return d.join(" ");
    }
    if (typeof r != "string")
      return r;
    var l = n.length;
    if (l === 0)
      return r;
    for (var p = "", w = 1 - c, g = -1, m = r && r.length || 0, S = 0; S < m; ) {
      if (r.charCodeAt(S) === 37 && S + 1 < m) {
        switch (g = g > -1 ? g : 0, r.charCodeAt(S + 1)) {
          case 100:
          case 102:
            if (w >= l || n[w] == null)
              break;
            g < S && (p += r.slice(g, S)), p += Number(n[w]), g = S + 2, S++;
            break;
          case 105:
            if (w >= l || n[w] == null)
              break;
            g < S && (p += r.slice(g, S)), p += Math.floor(Number(n[w])), g = S + 2, S++;
            break;
          case 79:
          case 111:
          case 106:
            if (w >= l || n[w] === void 0)
              break;
            g < S && (p += r.slice(g, S));
            var I = typeof n[w];
            if (I === "string") {
              p += "'" + n[w] + "'", g = S + 2, S++;
              break;
            }
            if (I === "function") {
              p += n[w].name || "<anonymous>", g = S + 2, S++;
              break;
            }
            p += i(n[w]), g = S + 2, S++;
            break;
          case 115:
            if (w >= l)
              break;
            g < S && (p += r.slice(g, S)), p += String(n[w]), g = S + 2, S++;
            break;
          case 37:
            g < S && (p += r.slice(g, S)), p += "%", g = S + 2, S++, w--;
            break;
        }
        ++w;
      }
      ++S;
    }
    return g === -1 ? r : (g < m && (p += r.slice(g)), p);
  }
  return Ws;
}
var Zs, _d;
function n6() {
  if (_d)
    return Zs;
  _d = 1;
  const e = r6();
  Zs = a;
  const t = D().console || {}, r = {
    mapHttpRequest: m,
    mapHttpResponse: m,
    wrapRequestSerializer: S,
    wrapResponseSerializer: S,
    wrapErrorSerializer: S,
    req: m,
    res: m,
    err: w
  };
  function n(b, o) {
    return Array.isArray(b) ? b.filter(function(U) {
      return U !== "!stdSerializers.err";
    }) : b === !0 ? Object.keys(o) : !1;
  }
  function a(b) {
    b = b || {}, b.browser = b.browser || {};
    const o = b.browser.transmit;
    if (o && typeof o.send != "function")
      throw Error("pino: transmit option must have a send function");
    const h = b.browser.write || t;
    b.browser.write && (b.browser.asObject = !0);
    const U = b.serializers || {}, E = n(b.browser.serialize, U);
    let T = b.browser.serialize;
    Array.isArray(b.browser.serialize) && b.browser.serialize.indexOf("!stdSerializers.err") > -1 && (T = !1);
    const P = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof h == "function" && (h.error = h.fatal = h.warn = h.info = h.debug = h.trace = h), b.enabled === !1 && (b.level = "silent");
    const z = b.level || "info", v = Object.create(h);
    v.log || (v.log = I), Object.defineProperty(v, "levelVal", {
      get: L
    }), Object.defineProperty(v, "level", {
      get: M,
      set: H
    });
    const y = {
      transmit: o,
      serialize: E,
      asObject: b.browser.asObject,
      levels: P,
      timestamp: g(b)
    };
    v.levels = a.levels, v.level = z, v.setMaxListeners = v.getMaxListeners = v.emit = v.addListener = v.on = v.prependListener = v.once = v.prependOnceListener = v.removeListener = v.removeAllListeners = v.listeners = v.listenerCount = v.eventNames = v.write = v.flush = I, v.serializers = U, v._serialize = E, v._stdErrSerialize = T, v.child = F, o && (v._logEvent = p());
    function L() {
      return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
    }
    function M() {
      return this._level;
    }
    function H(j) {
      if (j !== "silent" && !this.levels.values[j])
        throw Error("unknown level " + j);
      this._level = j, i(y, v, "error", "log"), i(y, v, "fatal", "error"), i(y, v, "warn", "error"), i(y, v, "info", "log"), i(y, v, "debug", "log"), i(y, v, "trace", "log");
    }
    function F(j, V) {
      if (!j)
        throw new Error("missing bindings for child Pino");
      V = V || {}, E && j.serializers && (V.serializers = j.serializers);
      const W = V.serializers;
      if (E && W) {
        var K = Object.assign({}, U, W), Q = b.browser.serialize === !0 ? Object.keys(K) : E;
        delete j.serializers, d([j], Q, K, this._stdErrSerialize);
      }
      function Z(te) {
        this._childLevel = (te._childLevel | 0) + 1, this.error = f(te, j, "error"), this.fatal = f(te, j, "fatal"), this.warn = f(te, j, "warn"), this.info = f(te, j, "info"), this.debug = f(te, j, "debug"), this.trace = f(te, j, "trace"), K && (this.serializers = K, this._serialize = Q), o && (this._logEvent = p(
          [].concat(te._logEvent.bindings, j)
        ));
      }
      return Z.prototype = this, new Z(this);
    }
    return v;
  }
  a.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  }, a.stdSerializers = r, a.stdTimeFunctions = Object.assign({}, { nullTime: N, epochTime: x, unixTime: C, isoTime: _ });
  function i(b, o, h, U) {
    const E = Object.getPrototypeOf(o);
    o[h] = o.levelVal > o.levels.values[h] ? I : E[h] ? E[h] : t[h] || t[U] || I, c(b, o, h);
  }
  function c(b, o, h) {
    !b.transmit && o[h] === I || (o[h] = function(U) {
      return function() {
        const T = b.timestamp(), P = new Array(arguments.length), z = Object.getPrototypeOf && Object.getPrototypeOf(this) === t ? t : this;
        for (var v = 0; v < P.length; v++)
          P[v] = arguments[v];
        if (b.serialize && !b.asObject && d(P, this._serialize, this.serializers, this._stdErrSerialize), b.asObject ? U.call(z, s(this, h, P, T)) : U.apply(z, P), b.transmit) {
          const y = b.transmit.level || o.level, L = a.levels.values[y], M = a.levels.values[h];
          if (M < L)
            return;
          l(this, {
            ts: T,
            methodLevel: h,
            methodValue: M,
            transmitLevel: y,
            transmitValue: a.levels.values[b.transmit.level || o.level],
            send: b.transmit.send,
            val: o.levelVal
          }, P);
        }
      };
    }(o[h]));
  }
  function s(b, o, h, U) {
    b._serialize && d(h, b._serialize, b.serializers, b._stdErrSerialize);
    const E = h.slice();
    let T = E[0];
    const P = {};
    U && (P.time = U), P.level = a.levels.values[o];
    let z = (b._childLevel | 0) + 1;
    if (z < 1 && (z = 1), T !== null && typeof T == "object") {
      for (; z-- && typeof E[0] == "object"; )
        Object.assign(P, E.shift());
      T = E.length ? e(E.shift(), E) : void 0;
    } else
      typeof T == "string" && (T = e(E.shift(), E));
    return T !== void 0 && (P.msg = T), P;
  }
  function d(b, o, h, U) {
    for (const E in b)
      if (U && b[E] instanceof Error)
        b[E] = a.stdSerializers.err(b[E]);
      else if (typeof b[E] == "object" && !Array.isArray(b[E]))
        for (const T in b[E])
          o && o.indexOf(T) > -1 && T in h && (b[E][T] = h[T](b[E][T]));
  }
  function f(b, o, h) {
    return function() {
      const U = new Array(1 + arguments.length);
      U[0] = o;
      for (var E = 1; E < U.length; E++)
        U[E] = arguments[E - 1];
      return b[h].apply(this, U);
    };
  }
  function l(b, o, h) {
    const U = o.send, E = o.ts, T = o.methodLevel, P = o.methodValue, z = o.val, v = b._logEvent.bindings;
    d(
      h,
      b._serialize || Object.keys(b.serializers),
      b.serializers,
      b._stdErrSerialize === void 0 ? !0 : b._stdErrSerialize
    ), b._logEvent.ts = E, b._logEvent.messages = h.filter(function(y) {
      return v.indexOf(y) === -1;
    }), b._logEvent.level.label = T, b._logEvent.level.value = P, U(T, b._logEvent, z), b._logEvent = p(v);
  }
  function p(b) {
    return {
      ts: 0,
      messages: [],
      bindings: b || [],
      level: { label: "", value: 0 }
    };
  }
  function w(b) {
    const o = {
      type: b.constructor.name,
      msg: b.message,
      stack: b.stack
    };
    for (const h in b)
      o[h] === void 0 && (o[h] = b[h]);
    return o;
  }
  function g(b) {
    return typeof b.timestamp == "function" ? b.timestamp : b.timestamp === !1 ? N : x;
  }
  function m() {
    return {};
  }
  function S(b) {
    return b;
  }
  function I() {
  }
  function N() {
    return !1;
  }
  function x() {
    return Date.now();
  }
  function C() {
    return Math.round(Date.now() / 1e3);
  }
  function _() {
    return new Date(Date.now()).toISOString();
  }
  function D() {
    function b(o) {
      return typeof o < "u" && o;
    }
    try {
      return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
        get: function() {
          return delete Object.prototype.globalThis, this.globalThis = this;
        },
        configurable: !0
      }), globalThis;
    } catch {
      return b(self) || b(window) || b(this) || {};
    }
  }
  return Zs;
}
var fn = {}, yd;
function Ml() {
  return yd || (yd = 1, Object.defineProperty(fn, "__esModule", { value: !0 }), fn.PINO_CUSTOM_CONTEXT_KEY = fn.PINO_LOGGER_DEFAULTS = void 0, fn.PINO_LOGGER_DEFAULTS = {
    level: "info"
  }, fn.PINO_CUSTOM_CONTEXT_KEY = "custom_context"), fn;
}
var xt = {}, wd;
function a6() {
  if (wd)
    return xt;
  wd = 1, Object.defineProperty(xt, "__esModule", { value: !0 }), xt.generateChildLogger = xt.formatChildLoggerContext = xt.getLoggerContext = xt.setBrowserLoggerContext = xt.getBrowserLoggerContext = xt.getDefaultLoggerOptions = void 0;
  const e = Ml();
  function t(s) {
    return Object.assign(Object.assign({}, s), { level: s?.level || e.PINO_LOGGER_DEFAULTS.level });
  }
  xt.getDefaultLoggerOptions = t;
  function r(s, d = e.PINO_CUSTOM_CONTEXT_KEY) {
    return s[d] || "";
  }
  xt.getBrowserLoggerContext = r;
  function n(s, d, f = e.PINO_CUSTOM_CONTEXT_KEY) {
    return s[f] = d, s;
  }
  xt.setBrowserLoggerContext = n;
  function a(s, d = e.PINO_CUSTOM_CONTEXT_KEY) {
    let f = "";
    return typeof s.bindings > "u" ? f = r(s, d) : f = s.bindings().context || "", f;
  }
  xt.getLoggerContext = a;
  function i(s, d, f = e.PINO_CUSTOM_CONTEXT_KEY) {
    const l = a(s, f);
    return l.trim() ? `${l}/${d}` : d;
  }
  xt.formatChildLoggerContext = i;
  function c(s, d, f = e.PINO_CUSTOM_CONTEXT_KEY) {
    const l = i(s, d, f), p = s.child({ context: l });
    return n(p, l, f);
  }
  return xt.generateChildLogger = c, xt;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.pino = void 0;
  const t = Xt, r = t.__importDefault(n6());
  Object.defineProperty(e, "pino", { enumerable: !0, get: function() {
    return r.default;
  } }), t.__exportStar(Ml(), e), t.__exportStar(a6(), e);
})(xe);
class i6 extends An {
  constructor(t) {
    super(), this.opts = t, this.protocol = "wc", this.version = 2;
  }
}
class s6 extends An {
  constructor(t, r) {
    super(), this.core = t, this.logger = r, this.records = /* @__PURE__ */ new Map();
  }
}
class c6 {
  constructor(t, r) {
    this.logger = t, this.core = r;
  }
}
class o6 extends An {
  constructor(t, r) {
    super(), this.relayer = t, this.logger = r;
  }
}
let f6 = class extends An {
  constructor(t) {
    super();
  }
}, d6 = class {
  constructor(t, r, n, a) {
    this.core = t, this.logger = r, this.name = n;
  }
};
class l6 extends An {
  constructor(t, r) {
    super(), this.relayer = t, this.logger = r;
  }
}
class u6 extends An {
  constructor(t, r) {
    super(), this.core = t, this.logger = r;
  }
}
class h6 {
  constructor(t, r) {
    this.projectId = t, this.logger = r;
  }
}
let b6 = class {
  constructor(t) {
    this.opts = t, this.protocol = "wc", this.version = 2;
  }
};
class p6 {
  constructor(t) {
    this.client = t;
  }
}
const g6 = (e) => JSON.stringify(e, (t, r) => typeof r == "bigint" ? r.toString() + "n" : r), _6 = (e) => {
  const t = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = e.replace(t, '$1"$2n"$3');
  return JSON.parse(r, (n, a) => typeof a == "string" && a.match(/^\d+n$/) ? BigInt(a.substring(0, a.length - 1)) : a);
};
function Hl(e) {
  if (typeof e != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof e}`);
  try {
    return _6(e);
  } catch {
    return e;
  }
}
function mo(e) {
  return typeof e == "string" ? e : g6(e) || "";
}
var Eo = {}, ra = {}, ls = {}, us = {};
Object.defineProperty(us, "__esModule", { value: !0 });
us.BrowserRandomSource = void 0;
const md = 65536;
class y6 {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const t = typeof self < "u" ? self.crypto || self.msCrypto : null;
    t && t.getRandomValues !== void 0 && (this._crypto = t, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const r = new Uint8Array(t);
    for (let n = 0; n < r.length; n += md)
      this._crypto.getRandomValues(r.subarray(n, n + Math.min(r.length - n, md)));
    return r;
  }
}
us.BrowserRandomSource = y6;
function w6(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var hs = {}, jt = {};
Object.defineProperty(jt, "__esModule", { value: !0 });
function m6(e) {
  for (var t = 0; t < e.length; t++)
    e[t] = 0;
  return e;
}
jt.wipe = m6;
const E6 = {}, v6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: E6
}, Symbol.toStringTag, { value: "Module" })), x6 = /* @__PURE__ */ Dl(v6);
Object.defineProperty(hs, "__esModule", { value: !0 });
hs.NodeRandomSource = void 0;
const S6 = jt;
class D6 {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof w6 < "u") {
      const t = x6;
      t && t.randomBytes && (this._crypto = t, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let r = this._crypto.randomBytes(t);
    if (r.length !== t)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const n = new Uint8Array(t);
    for (let a = 0; a < n.length; a++)
      n[a] = r[a];
    return (0, S6.wipe)(r), n;
  }
}
hs.NodeRandomSource = D6;
Object.defineProperty(ls, "__esModule", { value: !0 });
ls.SystemRandomSource = void 0;
const A6 = us, I6 = hs;
class C6 {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new A6.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new I6.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(t) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(t);
  }
}
ls.SystemRandomSource = C6;
var se = {}, zl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  function t(s, d) {
    var f = s >>> 16 & 65535, l = s & 65535, p = d >>> 16 & 65535, w = d & 65535;
    return l * w + (f * w + l * p << 16 >>> 0) | 0;
  }
  e.mul = Math.imul || t;
  function r(s, d) {
    return s + d | 0;
  }
  e.add = r;
  function n(s, d) {
    return s - d | 0;
  }
  e.sub = n;
  function a(s, d) {
    return s << d | s >>> 32 - d;
  }
  e.rotl = a;
  function i(s, d) {
    return s << 32 - d | s >>> d;
  }
  e.rotr = i;
  function c(s) {
    return typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  }
  e.isInteger = Number.isInteger || c, e.MAX_SAFE_INTEGER = 9007199254740991, e.isSafeInteger = function(s) {
    return e.isInteger(s) && s >= -e.MAX_SAFE_INTEGER && s <= e.MAX_SAFE_INTEGER;
  };
})(zl);
Object.defineProperty(se, "__esModule", { value: !0 });
var jl = zl;
function T6(e, t) {
  return t === void 0 && (t = 0), (e[t + 0] << 8 | e[t + 1]) << 16 >> 16;
}
se.readInt16BE = T6;
function O6(e, t) {
  return t === void 0 && (t = 0), (e[t + 0] << 8 | e[t + 1]) >>> 0;
}
se.readUint16BE = O6;
function N6(e, t) {
  return t === void 0 && (t = 0), (e[t + 1] << 8 | e[t]) << 16 >> 16;
}
se.readInt16LE = N6;
function R6(e, t) {
  return t === void 0 && (t = 0), (e[t + 1] << 8 | e[t]) >>> 0;
}
se.readUint16LE = R6;
function Vl(e, t, r) {
  return t === void 0 && (t = new Uint8Array(2)), r === void 0 && (r = 0), t[r + 0] = e >>> 8, t[r + 1] = e >>> 0, t;
}
se.writeUint16BE = Vl;
se.writeInt16BE = Vl;
function ql(e, t, r) {
  return t === void 0 && (t = new Uint8Array(2)), r === void 0 && (r = 0), t[r + 0] = e >>> 0, t[r + 1] = e >>> 8, t;
}
se.writeUint16LE = ql;
se.writeInt16LE = ql;
function Oc(e, t) {
  return t === void 0 && (t = 0), e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];
}
se.readInt32BE = Oc;
function Nc(e, t) {
  return t === void 0 && (t = 0), (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;
}
se.readUint32BE = Nc;
function Rc(e, t) {
  return t === void 0 && (t = 0), e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t];
}
se.readInt32LE = Rc;
function Lc(e, t) {
  return t === void 0 && (t = 0), (e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]) >>> 0;
}
se.readUint32LE = Lc;
function Ki(e, t, r) {
  return t === void 0 && (t = new Uint8Array(4)), r === void 0 && (r = 0), t[r + 0] = e >>> 24, t[r + 1] = e >>> 16, t[r + 2] = e >>> 8, t[r + 3] = e >>> 0, t;
}
se.writeUint32BE = Ki;
se.writeInt32BE = Ki;
function Gi(e, t, r) {
  return t === void 0 && (t = new Uint8Array(4)), r === void 0 && (r = 0), t[r + 0] = e >>> 0, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24, t;
}
se.writeUint32LE = Gi;
se.writeInt32LE = Gi;
function L6(e, t) {
  t === void 0 && (t = 0);
  var r = Oc(e, t), n = Oc(e, t + 4);
  return r * 4294967296 + n - (n >> 31) * 4294967296;
}
se.readInt64BE = L6;
function P6(e, t) {
  t === void 0 && (t = 0);
  var r = Nc(e, t), n = Nc(e, t + 4);
  return r * 4294967296 + n;
}
se.readUint64BE = P6;
function k6(e, t) {
  t === void 0 && (t = 0);
  var r = Rc(e, t), n = Rc(e, t + 4);
  return n * 4294967296 + r - (r >> 31) * 4294967296;
}
se.readInt64LE = k6;
function U6(e, t) {
  t === void 0 && (t = 0);
  var r = Lc(e, t), n = Lc(e, t + 4);
  return n * 4294967296 + r;
}
se.readUint64LE = U6;
function Kl(e, t, r) {
  return t === void 0 && (t = new Uint8Array(8)), r === void 0 && (r = 0), Ki(e / 4294967296 >>> 0, t, r), Ki(e >>> 0, t, r + 4), t;
}
se.writeUint64BE = Kl;
se.writeInt64BE = Kl;
function Gl(e, t, r) {
  return t === void 0 && (t = new Uint8Array(8)), r === void 0 && (r = 0), Gi(e >>> 0, t, r), Gi(e / 4294967296 >>> 0, t, r + 4), t;
}
se.writeUint64LE = Gl;
se.writeInt64LE = Gl;
function F6(e, t, r) {
  if (r === void 0 && (r = 0), e % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (e / 8 > t.length - r)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var n = 0, a = 1, i = e / 8 + r - 1; i >= r; i--)
    n += t[i] * a, a *= 256;
  return n;
}
se.readUintBE = F6;
function $6(e, t, r) {
  if (r === void 0 && (r = 0), e % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (e / 8 > t.length - r)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var n = 0, a = 1, i = r; i < r + e / 8; i++)
    n += t[i] * a, a *= 256;
  return n;
}
se.readUintLE = $6;
function B6(e, t, r, n) {
  if (r === void 0 && (r = new Uint8Array(e / 8)), n === void 0 && (n = 0), e % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!jl.isSafeInteger(t))
    throw new Error("writeUintBE value must be an integer");
  for (var a = 1, i = e / 8 + n - 1; i >= n; i--)
    r[i] = t / a & 255, a *= 256;
  return r;
}
se.writeUintBE = B6;
function M6(e, t, r, n) {
  if (r === void 0 && (r = new Uint8Array(e / 8)), n === void 0 && (n = 0), e % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!jl.isSafeInteger(t))
    throw new Error("writeUintLE value must be an integer");
  for (var a = 1, i = n; i < n + e / 8; i++)
    r[i] = t / a & 255, a *= 256;
  return r;
}
se.writeUintLE = M6;
function H6(e, t) {
  t === void 0 && (t = 0);
  var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return r.getFloat32(t);
}
se.readFloat32BE = H6;
function z6(e, t) {
  t === void 0 && (t = 0);
  var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return r.getFloat32(t, !0);
}
se.readFloat32LE = z6;
function j6(e, t) {
  t === void 0 && (t = 0);
  var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return r.getFloat64(t);
}
se.readFloat64BE = j6;
function V6(e, t) {
  t === void 0 && (t = 0);
  var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return r.getFloat64(t, !0);
}
se.readFloat64LE = V6;
function q6(e, t, r) {
  t === void 0 && (t = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return n.setFloat32(r, e), t;
}
se.writeFloat32BE = q6;
function K6(e, t, r) {
  t === void 0 && (t = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return n.setFloat32(r, e, !0), t;
}
se.writeFloat32LE = K6;
function G6(e, t, r) {
  t === void 0 && (t = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return n.setFloat64(r, e), t;
}
se.writeFloat64BE = G6;
function W6(e, t, r) {
  t === void 0 && (t = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return n.setFloat64(r, e, !0), t;
}
se.writeFloat64LE = W6;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.randomStringForEntropy = e.randomString = e.randomUint32 = e.randomBytes = e.defaultRandomSource = void 0;
  const t = ls, r = se, n = jt;
  e.defaultRandomSource = new t.SystemRandomSource();
  function a(f, l = e.defaultRandomSource) {
    return l.randomBytes(f);
  }
  e.randomBytes = a;
  function i(f = e.defaultRandomSource) {
    const l = a(4, f), p = (0, r.readUint32LE)(l);
    return (0, n.wipe)(l), p;
  }
  e.randomUint32 = i;
  const c = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function s(f, l = c, p = e.defaultRandomSource) {
    if (l.length < 2)
      throw new Error("randomString charset is too short");
    if (l.length > 256)
      throw new Error("randomString charset is too long");
    let w = "";
    const g = l.length, m = 256 - 256 % g;
    for (; f > 0; ) {
      const S = a(Math.ceil(f * 256 / m), p);
      for (let I = 0; I < S.length && f > 0; I++) {
        const N = S[I];
        N < m && (w += l.charAt(N % g), f--);
      }
      (0, n.wipe)(S);
    }
    return w;
  }
  e.randomString = s;
  function d(f, l = c, p = e.defaultRandomSource) {
    const w = Math.ceil(f / (Math.log(l.length) / Math.LN2));
    return s(w, l, p);
  }
  e.randomStringForEntropy = d;
})(ra);
var Wl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  var t = se, r = jt;
  e.DIGEST_LENGTH = 64, e.BLOCK_SIZE = 128;
  var n = (
    /** @class */
    function() {
      function s() {
        this.digestLength = e.DIGEST_LENGTH, this.blockSize = e.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return s.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, s.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, s.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._tempHi), r.wipe(this._tempLo), this.reset();
      }, s.prototype.update = function(d, f) {
        if (f === void 0 && (f = d.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var l = 0;
        if (this._bytesHashed += f, this._bufferLength > 0) {
          for (; this._bufferLength < e.BLOCK_SIZE && f > 0; )
            this._buffer[this._bufferLength++] = d[l++], f--;
          this._bufferLength === this.blockSize && (i(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (f >= this.blockSize && (l = i(this._tempHi, this._tempLo, this._stateHi, this._stateLo, d, l, f), f %= this.blockSize); f > 0; )
          this._buffer[this._bufferLength++] = d[l++], f--;
        return this;
      }, s.prototype.finish = function(d) {
        if (!this._finished) {
          var f = this._bytesHashed, l = this._bufferLength, p = f / 536870912 | 0, w = f << 3, g = f % 128 < 112 ? 128 : 256;
          this._buffer[l] = 128;
          for (var m = l + 1; m < g - 8; m++)
            this._buffer[m] = 0;
          t.writeUint32BE(p, this._buffer, g - 8), t.writeUint32BE(w, this._buffer, g - 4), i(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, g), this._finished = !0;
        }
        for (var m = 0; m < this.digestLength / 8; m++)
          t.writeUint32BE(this._stateHi[m], d, m * 8), t.writeUint32BE(this._stateLo[m], d, m * 8 + 4);
        return this;
      }, s.prototype.digest = function() {
        var d = new Uint8Array(this.digestLength);
        return this.finish(d), d;
      }, s.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, s.prototype.restoreState = function(d) {
        return this._stateHi.set(d.stateHi), this._stateLo.set(d.stateLo), this._bufferLength = d.bufferLength, d.buffer && this._buffer.set(d.buffer), this._bytesHashed = d.bytesHashed, this._finished = !1, this;
      }, s.prototype.cleanSavedState = function(d) {
        r.wipe(d.stateHi), r.wipe(d.stateLo), d.buffer && r.wipe(d.buffer), d.bufferLength = 0, d.bytesHashed = 0;
      }, s;
    }()
  );
  e.SHA512 = n;
  var a = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function i(s, d, f, l, p, w, g) {
    for (var m = f[0], S = f[1], I = f[2], N = f[3], x = f[4], C = f[5], _ = f[6], D = f[7], b = l[0], o = l[1], h = l[2], U = l[3], E = l[4], T = l[5], P = l[6], z = l[7], v, y, L, M, H, F, j, V; g >= 128; ) {
      for (var W = 0; W < 16; W++) {
        var K = 8 * W + w;
        s[W] = t.readUint32BE(p, K), d[W] = t.readUint32BE(p, K + 4);
      }
      for (var W = 0; W < 80; W++) {
        var Q = m, Z = S, te = I, $ = N, B = x, R = C, u = _, O = D, G = b, Y = o, ce = h, pe = U, le = E, De = T, ze = P, Fe = z;
        if (v = D, y = z, H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = (x >>> 14 | E << 32 - 14) ^ (x >>> 18 | E << 32 - 18) ^ (E >>> 41 - 32 | x << 32 - (41 - 32)), y = (E >>> 14 | x << 32 - 14) ^ (E >>> 18 | x << 32 - 18) ^ (x >>> 41 - 32 | E << 32 - (41 - 32)), H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, v = x & C ^ ~x & _, y = E & T ^ ~E & P, H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, v = a[W * 2], y = a[W * 2 + 1], H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, v = s[W % 16], y = d[W % 16], H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, L = j & 65535 | V << 16, M = H & 65535 | F << 16, v = L, y = M, H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = (m >>> 28 | b << 32 - 28) ^ (b >>> 34 - 32 | m << 32 - (34 - 32)) ^ (b >>> 39 - 32 | m << 32 - (39 - 32)), y = (b >>> 28 | m << 32 - 28) ^ (m >>> 34 - 32 | b << 32 - (34 - 32)) ^ (m >>> 39 - 32 | b << 32 - (39 - 32)), H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, v = m & S ^ m & I ^ S & I, y = b & o ^ b & h ^ o & h, H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, O = j & 65535 | V << 16, Fe = H & 65535 | F << 16, v = $, y = pe, H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = L, y = M, H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, $ = j & 65535 | V << 16, pe = H & 65535 | F << 16, S = Q, I = Z, N = te, x = $, C = B, _ = R, D = u, m = O, o = G, h = Y, U = ce, E = pe, T = le, P = De, z = ze, b = Fe, W % 16 === 15)
          for (var K = 0; K < 16; K++)
            v = s[K], y = d[K], H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = s[(K + 9) % 16], y = d[(K + 9) % 16], H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, L = s[(K + 1) % 16], M = d[(K + 1) % 16], v = (L >>> 1 | M << 32 - 1) ^ (L >>> 8 | M << 32 - 8) ^ L >>> 7, y = (M >>> 1 | L << 32 - 1) ^ (M >>> 8 | L << 32 - 8) ^ (M >>> 7 | L << 32 - 7), H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, L = s[(K + 14) % 16], M = d[(K + 14) % 16], v = (L >>> 19 | M << 32 - 19) ^ (M >>> 61 - 32 | L << 32 - (61 - 32)) ^ L >>> 6, y = (M >>> 19 | L << 32 - 19) ^ (L >>> 61 - 32 | M << 32 - (61 - 32)) ^ (M >>> 6 | L << 32 - 6), H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, s[K] = j & 65535 | V << 16, d[K] = H & 65535 | F << 16;
      }
      v = m, y = b, H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = f[0], y = l[0], H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, f[0] = m = j & 65535 | V << 16, l[0] = b = H & 65535 | F << 16, v = S, y = o, H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = f[1], y = l[1], H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, f[1] = S = j & 65535 | V << 16, l[1] = o = H & 65535 | F << 16, v = I, y = h, H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = f[2], y = l[2], H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, f[2] = I = j & 65535 | V << 16, l[2] = h = H & 65535 | F << 16, v = N, y = U, H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = f[3], y = l[3], H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, f[3] = N = j & 65535 | V << 16, l[3] = U = H & 65535 | F << 16, v = x, y = E, H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = f[4], y = l[4], H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, f[4] = x = j & 65535 | V << 16, l[4] = E = H & 65535 | F << 16, v = C, y = T, H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = f[5], y = l[5], H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, f[5] = C = j & 65535 | V << 16, l[5] = T = H & 65535 | F << 16, v = _, y = P, H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = f[6], y = l[6], H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, f[6] = _ = j & 65535 | V << 16, l[6] = P = H & 65535 | F << 16, v = D, y = z, H = y & 65535, F = y >>> 16, j = v & 65535, V = v >>> 16, v = f[7], y = l[7], H += y & 65535, F += y >>> 16, j += v & 65535, V += v >>> 16, F += H >>> 16, j += F >>> 16, V += j >>> 16, f[7] = D = j & 65535 | V << 16, l[7] = z = H & 65535 | F << 16, w += 128, g -= 128;
    }
    return w;
  }
  function c(s) {
    var d = new n();
    d.update(s);
    var f = d.digest();
    return d.clean(), f;
  }
  e.hash = c;
})(Wl);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.convertSecretKeyToX25519 = e.convertPublicKeyToX25519 = e.verify = e.sign = e.extractPublicKeyFromSecretKey = e.generateKeyPair = e.generateKeyPairFromSeed = e.SEED_LENGTH = e.SECRET_KEY_LENGTH = e.PUBLIC_KEY_LENGTH = e.SIGNATURE_LENGTH = void 0;
  const t = ra, r = Wl, n = jt;
  e.SIGNATURE_LENGTH = 64, e.PUBLIC_KEY_LENGTH = 32, e.SECRET_KEY_LENGTH = 64, e.SEED_LENGTH = 32;
  function a($) {
    const B = new Float64Array(16);
    if ($)
      for (let R = 0; R < $.length; R++)
        B[R] = $[R];
    return B;
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const c = a(), s = a([1]), d = a([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), f = a([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), l = a([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), p = a([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), w = a([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function g($, B) {
    for (let R = 0; R < 16; R++)
      $[R] = B[R] | 0;
  }
  function m($) {
    let B = 1;
    for (let R = 0; R < 16; R++) {
      let u = $[R] + B + 65535;
      B = Math.floor(u / 65536), $[R] = u - B * 65536;
    }
    $[0] += B - 1 + 37 * (B - 1);
  }
  function S($, B, R) {
    const u = ~(R - 1);
    for (let O = 0; O < 16; O++) {
      const G = u & ($[O] ^ B[O]);
      $[O] ^= G, B[O] ^= G;
    }
  }
  function I($, B) {
    const R = a(), u = a();
    for (let O = 0; O < 16; O++)
      u[O] = B[O];
    m(u), m(u), m(u);
    for (let O = 0; O < 2; O++) {
      R[0] = u[0] - 65517;
      for (let Y = 1; Y < 15; Y++)
        R[Y] = u[Y] - 65535 - (R[Y - 1] >> 16 & 1), R[Y - 1] &= 65535;
      R[15] = u[15] - 32767 - (R[14] >> 16 & 1);
      const G = R[15] >> 16 & 1;
      R[14] &= 65535, S(u, R, 1 - G);
    }
    for (let O = 0; O < 16; O++)
      $[2 * O] = u[O] & 255, $[2 * O + 1] = u[O] >> 8;
  }
  function N($, B) {
    let R = 0;
    for (let u = 0; u < 32; u++)
      R |= $[u] ^ B[u];
    return (1 & R - 1 >>> 8) - 1;
  }
  function x($, B) {
    const R = new Uint8Array(32), u = new Uint8Array(32);
    return I(R, $), I(u, B), N(R, u);
  }
  function C($) {
    const B = new Uint8Array(32);
    return I(B, $), B[0] & 1;
  }
  function _($, B) {
    for (let R = 0; R < 16; R++)
      $[R] = B[2 * R] + (B[2 * R + 1] << 8);
    $[15] &= 32767;
  }
  function D($, B, R) {
    for (let u = 0; u < 16; u++)
      $[u] = B[u] + R[u];
  }
  function b($, B, R) {
    for (let u = 0; u < 16; u++)
      $[u] = B[u] - R[u];
  }
  function o($, B, R) {
    let u, O, G = 0, Y = 0, ce = 0, pe = 0, le = 0, De = 0, ze = 0, Fe = 0, me = 0, _e = 0, ge = 0, he = 0, ue = 0, de = 0, fe = 0, ae = 0, be = 0, ye = 0, ie = 0, ve = 0, Se = 0, Ce = 0, Te = 0, Ae = 0, Jt = 0, nr = 0, Rr = 0, Ut = 0, tn = 0, ua = 0, mi = 0, Ve = R[0], $e = R[1], qe = R[2], Ke = R[3], Ge = R[4], Be = R[5], tt = R[6], rt = R[7], nt = R[8], at = R[9], it = R[10], Xe = R[11], We = R[12], Pe = R[13], st = R[14], ct = R[15];
    u = B[0], G += u * Ve, Y += u * $e, ce += u * qe, pe += u * Ke, le += u * Ge, De += u * Be, ze += u * tt, Fe += u * rt, me += u * nt, _e += u * at, ge += u * it, he += u * Xe, ue += u * We, de += u * Pe, fe += u * st, ae += u * ct, u = B[1], Y += u * Ve, ce += u * $e, pe += u * qe, le += u * Ke, De += u * Ge, ze += u * Be, Fe += u * tt, me += u * rt, _e += u * nt, ge += u * at, he += u * it, ue += u * Xe, de += u * We, fe += u * Pe, ae += u * st, be += u * ct, u = B[2], ce += u * Ve, pe += u * $e, le += u * qe, De += u * Ke, ze += u * Ge, Fe += u * Be, me += u * tt, _e += u * rt, ge += u * nt, he += u * at, ue += u * it, de += u * Xe, fe += u * We, ae += u * Pe, be += u * st, ye += u * ct, u = B[3], pe += u * Ve, le += u * $e, De += u * qe, ze += u * Ke, Fe += u * Ge, me += u * Be, _e += u * tt, ge += u * rt, he += u * nt, ue += u * at, de += u * it, fe += u * Xe, ae += u * We, be += u * Pe, ye += u * st, ie += u * ct, u = B[4], le += u * Ve, De += u * $e, ze += u * qe, Fe += u * Ke, me += u * Ge, _e += u * Be, ge += u * tt, he += u * rt, ue += u * nt, de += u * at, fe += u * it, ae += u * Xe, be += u * We, ye += u * Pe, ie += u * st, ve += u * ct, u = B[5], De += u * Ve, ze += u * $e, Fe += u * qe, me += u * Ke, _e += u * Ge, ge += u * Be, he += u * tt, ue += u * rt, de += u * nt, fe += u * at, ae += u * it, be += u * Xe, ye += u * We, ie += u * Pe, ve += u * st, Se += u * ct, u = B[6], ze += u * Ve, Fe += u * $e, me += u * qe, _e += u * Ke, ge += u * Ge, he += u * Be, ue += u * tt, de += u * rt, fe += u * nt, ae += u * at, be += u * it, ye += u * Xe, ie += u * We, ve += u * Pe, Se += u * st, Ce += u * ct, u = B[7], Fe += u * Ve, me += u * $e, _e += u * qe, ge += u * Ke, he += u * Ge, ue += u * Be, de += u * tt, fe += u * rt, ae += u * nt, be += u * at, ye += u * it, ie += u * Xe, ve += u * We, Se += u * Pe, Ce += u * st, Te += u * ct, u = B[8], me += u * Ve, _e += u * $e, ge += u * qe, he += u * Ke, ue += u * Ge, de += u * Be, fe += u * tt, ae += u * rt, be += u * nt, ye += u * at, ie += u * it, ve += u * Xe, Se += u * We, Ce += u * Pe, Te += u * st, Ae += u * ct, u = B[9], _e += u * Ve, ge += u * $e, he += u * qe, ue += u * Ke, de += u * Ge, fe += u * Be, ae += u * tt, be += u * rt, ye += u * nt, ie += u * at, ve += u * it, Se += u * Xe, Ce += u * We, Te += u * Pe, Ae += u * st, Jt += u * ct, u = B[10], ge += u * Ve, he += u * $e, ue += u * qe, de += u * Ke, fe += u * Ge, ae += u * Be, be += u * tt, ye += u * rt, ie += u * nt, ve += u * at, Se += u * it, Ce += u * Xe, Te += u * We, Ae += u * Pe, Jt += u * st, nr += u * ct, u = B[11], he += u * Ve, ue += u * $e, de += u * qe, fe += u * Ke, ae += u * Ge, be += u * Be, ye += u * tt, ie += u * rt, ve += u * nt, Se += u * at, Ce += u * it, Te += u * Xe, Ae += u * We, Jt += u * Pe, nr += u * st, Rr += u * ct, u = B[12], ue += u * Ve, de += u * $e, fe += u * qe, ae += u * Ke, be += u * Ge, ye += u * Be, ie += u * tt, ve += u * rt, Se += u * nt, Ce += u * at, Te += u * it, Ae += u * Xe, Jt += u * We, nr += u * Pe, Rr += u * st, Ut += u * ct, u = B[13], de += u * Ve, fe += u * $e, ae += u * qe, be += u * Ke, ye += u * Ge, ie += u * Be, ve += u * tt, Se += u * rt, Ce += u * nt, Te += u * at, Ae += u * it, Jt += u * Xe, nr += u * We, Rr += u * Pe, Ut += u * st, tn += u * ct, u = B[14], fe += u * Ve, ae += u * $e, be += u * qe, ye += u * Ke, ie += u * Ge, ve += u * Be, Se += u * tt, Ce += u * rt, Te += u * nt, Ae += u * at, Jt += u * it, nr += u * Xe, Rr += u * We, Ut += u * Pe, tn += u * st, ua += u * ct, u = B[15], ae += u * Ve, be += u * $e, ye += u * qe, ie += u * Ke, ve += u * Ge, Se += u * Be, Ce += u * tt, Te += u * rt, Ae += u * nt, Jt += u * at, nr += u * it, Rr += u * Xe, Ut += u * We, tn += u * Pe, ua += u * st, mi += u * ct, G += 38 * be, Y += 38 * ye, ce += 38 * ie, pe += 38 * ve, le += 38 * Se, De += 38 * Ce, ze += 38 * Te, Fe += 38 * Ae, me += 38 * Jt, _e += 38 * nr, ge += 38 * Rr, he += 38 * Ut, ue += 38 * tn, de += 38 * ua, fe += 38 * mi, O = 1, u = G + O + 65535, O = Math.floor(u / 65536), G = u - O * 65536, u = Y + O + 65535, O = Math.floor(u / 65536), Y = u - O * 65536, u = ce + O + 65535, O = Math.floor(u / 65536), ce = u - O * 65536, u = pe + O + 65535, O = Math.floor(u / 65536), pe = u - O * 65536, u = le + O + 65535, O = Math.floor(u / 65536), le = u - O * 65536, u = De + O + 65535, O = Math.floor(u / 65536), De = u - O * 65536, u = ze + O + 65535, O = Math.floor(u / 65536), ze = u - O * 65536, u = Fe + O + 65535, O = Math.floor(u / 65536), Fe = u - O * 65536, u = me + O + 65535, O = Math.floor(u / 65536), me = u - O * 65536, u = _e + O + 65535, O = Math.floor(u / 65536), _e = u - O * 65536, u = ge + O + 65535, O = Math.floor(u / 65536), ge = u - O * 65536, u = he + O + 65535, O = Math.floor(u / 65536), he = u - O * 65536, u = ue + O + 65535, O = Math.floor(u / 65536), ue = u - O * 65536, u = de + O + 65535, O = Math.floor(u / 65536), de = u - O * 65536, u = fe + O + 65535, O = Math.floor(u / 65536), fe = u - O * 65536, u = ae + O + 65535, O = Math.floor(u / 65536), ae = u - O * 65536, G += O - 1 + 37 * (O - 1), O = 1, u = G + O + 65535, O = Math.floor(u / 65536), G = u - O * 65536, u = Y + O + 65535, O = Math.floor(u / 65536), Y = u - O * 65536, u = ce + O + 65535, O = Math.floor(u / 65536), ce = u - O * 65536, u = pe + O + 65535, O = Math.floor(u / 65536), pe = u - O * 65536, u = le + O + 65535, O = Math.floor(u / 65536), le = u - O * 65536, u = De + O + 65535, O = Math.floor(u / 65536), De = u - O * 65536, u = ze + O + 65535, O = Math.floor(u / 65536), ze = u - O * 65536, u = Fe + O + 65535, O = Math.floor(u / 65536), Fe = u - O * 65536, u = me + O + 65535, O = Math.floor(u / 65536), me = u - O * 65536, u = _e + O + 65535, O = Math.floor(u / 65536), _e = u - O * 65536, u = ge + O + 65535, O = Math.floor(u / 65536), ge = u - O * 65536, u = he + O + 65535, O = Math.floor(u / 65536), he = u - O * 65536, u = ue + O + 65535, O = Math.floor(u / 65536), ue = u - O * 65536, u = de + O + 65535, O = Math.floor(u / 65536), de = u - O * 65536, u = fe + O + 65535, O = Math.floor(u / 65536), fe = u - O * 65536, u = ae + O + 65535, O = Math.floor(u / 65536), ae = u - O * 65536, G += O - 1 + 37 * (O - 1), $[0] = G, $[1] = Y, $[2] = ce, $[3] = pe, $[4] = le, $[5] = De, $[6] = ze, $[7] = Fe, $[8] = me, $[9] = _e, $[10] = ge, $[11] = he, $[12] = ue, $[13] = de, $[14] = fe, $[15] = ae;
  }
  function h($, B) {
    o($, B, B);
  }
  function U($, B) {
    const R = a();
    let u;
    for (u = 0; u < 16; u++)
      R[u] = B[u];
    for (u = 253; u >= 0; u--)
      h(R, R), u !== 2 && u !== 4 && o(R, R, B);
    for (u = 0; u < 16; u++)
      $[u] = R[u];
  }
  function E($, B) {
    const R = a();
    let u;
    for (u = 0; u < 16; u++)
      R[u] = B[u];
    for (u = 250; u >= 0; u--)
      h(R, R), u !== 1 && o(R, R, B);
    for (u = 0; u < 16; u++)
      $[u] = R[u];
  }
  function T($, B) {
    const R = a(), u = a(), O = a(), G = a(), Y = a(), ce = a(), pe = a(), le = a(), De = a();
    b(R, $[1], $[0]), b(De, B[1], B[0]), o(R, R, De), D(u, $[0], $[1]), D(De, B[0], B[1]), o(u, u, De), o(O, $[3], B[3]), o(O, O, f), o(G, $[2], B[2]), D(G, G, G), b(Y, u, R), b(ce, G, O), D(pe, G, O), D(le, u, R), o($[0], Y, ce), o($[1], le, pe), o($[2], pe, ce), o($[3], Y, le);
  }
  function P($, B, R) {
    for (let u = 0; u < 4; u++)
      S($[u], B[u], R);
  }
  function z($, B) {
    const R = a(), u = a(), O = a();
    U(O, B[2]), o(R, B[0], O), o(u, B[1], O), I($, u), $[31] ^= C(R) << 7;
  }
  function v($, B, R) {
    g($[0], c), g($[1], s), g($[2], s), g($[3], c);
    for (let u = 255; u >= 0; --u) {
      const O = R[u / 8 | 0] >> (u & 7) & 1;
      P($, B, O), T(B, $), T($, $), P($, B, O);
    }
  }
  function y($, B) {
    const R = [a(), a(), a(), a()];
    g(R[0], l), g(R[1], p), g(R[2], s), o(R[3], l, p), v($, R, B);
  }
  function L($) {
    if ($.length !== e.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${e.SEED_LENGTH} bytes`);
    const B = (0, r.hash)($);
    B[0] &= 248, B[31] &= 127, B[31] |= 64;
    const R = new Uint8Array(32), u = [a(), a(), a(), a()];
    y(u, B), z(R, u);
    const O = new Uint8Array(64);
    return O.set($), O.set(R, 32), {
      publicKey: R,
      secretKey: O
    };
  }
  e.generateKeyPairFromSeed = L;
  function M($) {
    const B = (0, t.randomBytes)(32, $), R = L(B);
    return (0, n.wipe)(B), R;
  }
  e.generateKeyPair = M;
  function H($) {
    if ($.length !== e.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${e.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array($.subarray(32));
  }
  e.extractPublicKeyFromSecretKey = H;
  const F = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function j($, B) {
    let R, u, O, G;
    for (u = 63; u >= 32; --u) {
      for (R = 0, O = u - 32, G = u - 12; O < G; ++O)
        B[O] += R - 16 * B[u] * F[O - (u - 32)], R = Math.floor((B[O] + 128) / 256), B[O] -= R * 256;
      B[O] += R, B[u] = 0;
    }
    for (R = 0, O = 0; O < 32; O++)
      B[O] += R - (B[31] >> 4) * F[O], R = B[O] >> 8, B[O] &= 255;
    for (O = 0; O < 32; O++)
      B[O] -= R * F[O];
    for (u = 0; u < 32; u++)
      B[u + 1] += B[u] >> 8, $[u] = B[u] & 255;
  }
  function V($) {
    const B = new Float64Array(64);
    for (let R = 0; R < 64; R++)
      B[R] = $[R];
    for (let R = 0; R < 64; R++)
      $[R] = 0;
    j($, B);
  }
  function W($, B) {
    const R = new Float64Array(64), u = [a(), a(), a(), a()], O = (0, r.hash)($.subarray(0, 32));
    O[0] &= 248, O[31] &= 127, O[31] |= 64;
    const G = new Uint8Array(64);
    G.set(O.subarray(32), 32);
    const Y = new r.SHA512();
    Y.update(G.subarray(32)), Y.update(B);
    const ce = Y.digest();
    Y.clean(), V(ce), y(u, ce), z(G, u), Y.reset(), Y.update(G.subarray(0, 32)), Y.update($.subarray(32)), Y.update(B);
    const pe = Y.digest();
    V(pe);
    for (let le = 0; le < 32; le++)
      R[le] = ce[le];
    for (let le = 0; le < 32; le++)
      for (let De = 0; De < 32; De++)
        R[le + De] += pe[le] * O[De];
    return j(G.subarray(32), R), G;
  }
  e.sign = W;
  function K($, B) {
    const R = a(), u = a(), O = a(), G = a(), Y = a(), ce = a(), pe = a();
    return g($[2], s), _($[1], B), h(O, $[1]), o(G, O, d), b(O, O, $[2]), D(G, $[2], G), h(Y, G), h(ce, Y), o(pe, ce, Y), o(R, pe, O), o(R, R, G), E(R, R), o(R, R, O), o(R, R, G), o(R, R, G), o($[0], R, G), h(u, $[0]), o(u, u, G), x(u, O) && o($[0], $[0], w), h(u, $[0]), o(u, u, G), x(u, O) ? -1 : (C($[0]) === B[31] >> 7 && b($[0], c, $[0]), o($[3], $[0], $[1]), 0);
  }
  function Q($, B, R) {
    const u = new Uint8Array(32), O = [a(), a(), a(), a()], G = [a(), a(), a(), a()];
    if (R.length !== e.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${e.SIGNATURE_LENGTH} bytes`);
    if (K(G, $))
      return !1;
    const Y = new r.SHA512();
    Y.update(R.subarray(0, 32)), Y.update($), Y.update(B);
    const ce = Y.digest();
    return V(ce), v(O, G, ce), y(G, R.subarray(32)), T(O, G), z(u, O), !N(R, u);
  }
  e.verify = Q;
  function Z($) {
    let B = [a(), a(), a(), a()];
    if (K(B, $))
      throw new Error("Ed25519: invalid public key");
    let R = a(), u = a(), O = B[1];
    D(R, s, O), b(u, s, O), U(u, u), o(R, R, u);
    let G = new Uint8Array(32);
    return I(G, R), G;
  }
  e.convertPublicKeyToX25519 = Z;
  function te($) {
    const B = (0, r.hash)($.subarray(0, 32));
    B[0] &= 248, B[31] &= 127, B[31] |= 64;
    const R = new Uint8Array(B.subarray(0, 32));
    return (0, n.wipe)(B), R;
  }
  e.convertSecretKeyToX25519 = te;
})(Eo);
const Z6 = "EdDSA", Y6 = "JWT", Zl = ".", Yl = "base64url", X6 = "utf8", J6 = "utf8", Q6 = ":", e3 = "did", t3 = "key", Ed = "base58btc", r3 = "z", n3 = "K36", a3 = 32;
function vo(e) {
  return globalThis.Buffer != null ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e;
}
function Xl(e = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? vo(globalThis.Buffer.allocUnsafe(e)) : new Uint8Array(e);
}
function Pc(e, t) {
  t || (t = e.reduce((a, i) => a + i.length, 0));
  const r = Xl(t);
  let n = 0;
  for (const a of e)
    r.set(a, n), n += a.length;
  return vo(r);
}
function i3(e, t) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var a = 0; a < e.length; a++) {
    var i = e.charAt(a), c = i.charCodeAt(0);
    if (r[c] !== 255)
      throw new TypeError(i + " is ambiguous");
    r[c] = a;
  }
  var s = e.length, d = e.charAt(0), f = Math.log(s) / Math.log(256), l = Math.log(256) / Math.log(s);
  function p(m) {
    if (m instanceof Uint8Array || (ArrayBuffer.isView(m) ? m = new Uint8Array(m.buffer, m.byteOffset, m.byteLength) : Array.isArray(m) && (m = Uint8Array.from(m))), !(m instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (m.length === 0)
      return "";
    for (var S = 0, I = 0, N = 0, x = m.length; N !== x && m[N] === 0; )
      N++, S++;
    for (var C = (x - N) * l + 1 >>> 0, _ = new Uint8Array(C); N !== x; ) {
      for (var D = m[N], b = 0, o = C - 1; (D !== 0 || b < I) && o !== -1; o--, b++)
        D += 256 * _[o] >>> 0, _[o] = D % s >>> 0, D = D / s >>> 0;
      if (D !== 0)
        throw new Error("Non-zero carry");
      I = b, N++;
    }
    for (var h = C - I; h !== C && _[h] === 0; )
      h++;
    for (var U = d.repeat(S); h < C; ++h)
      U += e.charAt(_[h]);
    return U;
  }
  function w(m) {
    if (typeof m != "string")
      throw new TypeError("Expected String");
    if (m.length === 0)
      return new Uint8Array();
    var S = 0;
    if (m[S] !== " ") {
      for (var I = 0, N = 0; m[S] === d; )
        I++, S++;
      for (var x = (m.length - S) * f + 1 >>> 0, C = new Uint8Array(x); m[S]; ) {
        var _ = r[m.charCodeAt(S)];
        if (_ === 255)
          return;
        for (var D = 0, b = x - 1; (_ !== 0 || D < N) && b !== -1; b--, D++)
          _ += s * C[b] >>> 0, C[b] = _ % 256 >>> 0, _ = _ / 256 >>> 0;
        if (_ !== 0)
          throw new Error("Non-zero carry");
        N = D, S++;
      }
      if (m[S] !== " ") {
        for (var o = x - N; o !== x && C[o] === 0; )
          o++;
        for (var h = new Uint8Array(I + (x - o)), U = I; o !== x; )
          h[U++] = C[o++];
        return h;
      }
    }
  }
  function g(m) {
    var S = w(m);
    if (S)
      return S;
    throw new Error(`Non-${t} character`);
  }
  return {
    encode: p,
    decodeUnsafe: w,
    decode: g
  };
}
var s3 = i3, c3 = s3;
const o3 = (e) => {
  if (e instanceof Uint8Array && e.constructor.name === "Uint8Array")
    return e;
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (ArrayBuffer.isView(e))
    return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
  throw new Error("Unknown type, must be binary type");
}, f3 = (e) => new TextEncoder().encode(e), d3 = (e) => new TextDecoder().decode(e);
class l3 {
  constructor(t, r, n) {
    this.name = t, this.prefix = r, this.baseEncode = n;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class u3 {
  constructor(t, r, n) {
    if (this.name = t, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return Jl(this, t);
  }
}
class h3 {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return Jl(this, t);
  }
  decode(t) {
    const r = t[0], n = this.decoders[r];
    if (n)
      return n.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const Jl = (e, t) => new h3({
  ...e.decoders || { [e.prefix]: e },
  ...t.decoders || { [t.prefix]: t }
});
class b3 {
  constructor(t, r, n, a) {
    this.name = t, this.prefix = r, this.baseEncode = n, this.baseDecode = a, this.encoder = new l3(t, r, n), this.decoder = new u3(t, r, a);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const bs = ({ name: e, prefix: t, encode: r, decode: n }) => new b3(e, t, r, n), ri = ({ prefix: e, name: t, alphabet: r }) => {
  const { encode: n, decode: a } = c3(r, t);
  return bs({
    prefix: e,
    name: t,
    encode: n,
    decode: (i) => o3(a(i))
  });
}, p3 = (e, t, r, n) => {
  const a = {};
  for (let l = 0; l < t.length; ++l)
    a[t[l]] = l;
  let i = e.length;
  for (; e[i - 1] === "="; )
    --i;
  const c = new Uint8Array(i * r / 8 | 0);
  let s = 0, d = 0, f = 0;
  for (let l = 0; l < i; ++l) {
    const p = a[e[l]];
    if (p === void 0)
      throw new SyntaxError(`Non-${n} character`);
    d = d << r | p, s += r, s >= 8 && (s -= 8, c[f++] = 255 & d >> s);
  }
  if (s >= r || 255 & d << 8 - s)
    throw new SyntaxError("Unexpected end of data");
  return c;
}, g3 = (e, t, r) => {
  const n = t[t.length - 1] === "=", a = (1 << r) - 1;
  let i = "", c = 0, s = 0;
  for (let d = 0; d < e.length; ++d)
    for (s = s << 8 | e[d], c += 8; c > r; )
      c -= r, i += t[a & s >> c];
  if (c && (i += t[a & s << r - c]), n)
    for (; i.length * r & 7; )
      i += "=";
  return i;
}, gt = ({ name: e, prefix: t, bitsPerChar: r, alphabet: n }) => bs({
  prefix: t,
  name: e,
  encode(a) {
    return g3(a, n, r);
  },
  decode(a) {
    return p3(a, n, r, e);
  }
}), _3 = bs({
  prefix: "\0",
  name: "identity",
  encode: (e) => d3(e),
  decode: (e) => f3(e)
}), y3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: _3
}, Symbol.toStringTag, { value: "Module" })), w3 = gt({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), m3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: w3
}, Symbol.toStringTag, { value: "Module" })), E3 = gt({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), v3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: E3
}, Symbol.toStringTag, { value: "Module" })), x3 = ri({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), S3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: x3
}, Symbol.toStringTag, { value: "Module" })), D3 = gt({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), A3 = gt({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), I3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: D3,
  base16upper: A3
}, Symbol.toStringTag, { value: "Module" })), C3 = gt({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), T3 = gt({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), O3 = gt({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), N3 = gt({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), R3 = gt({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), L3 = gt({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), P3 = gt({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), k3 = gt({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), U3 = gt({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), F3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: C3,
  base32hex: R3,
  base32hexpad: P3,
  base32hexpadupper: k3,
  base32hexupper: L3,
  base32pad: O3,
  base32padupper: N3,
  base32upper: T3,
  base32z: U3
}, Symbol.toStringTag, { value: "Module" })), $3 = ri({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), B3 = ri({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), M3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: $3,
  base36upper: B3
}, Symbol.toStringTag, { value: "Module" })), H3 = ri({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), z3 = ri({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), j3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: H3,
  base58flickr: z3
}, Symbol.toStringTag, { value: "Module" })), V3 = gt({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), q3 = gt({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), K3 = gt({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), G3 = gt({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), W3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: V3,
  base64pad: q3,
  base64url: K3,
  base64urlpad: G3
}, Symbol.toStringTag, { value: "Module" })), Ql = Array.from(""), Z3 = Ql.reduce((e, t, r) => (e[r] = t, e), []), Y3 = Ql.reduce((e, t, r) => (e[t.codePointAt(0)] = r, e), []);
function X3(e) {
  return e.reduce((t, r) => (t += Z3[r], t), "");
}
function J3(e) {
  const t = [];
  for (const r of e) {
    const n = Y3[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    t.push(n);
  }
  return new Uint8Array(t);
}
const Q3 = bs({
  prefix: "",
  name: "base256emoji",
  encode: X3,
  decode: J3
}), e5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: Q3
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const vd = {
  ...y3,
  ...m3,
  ...v3,
  ...S3,
  ...I3,
  ...F3,
  ...M3,
  ...j3,
  ...W3,
  ...e5
};
function eu(e, t, r, n) {
  return {
    name: e,
    prefix: t,
    encoder: {
      name: e,
      prefix: t,
      encode: r
    },
    decoder: { decode: n }
  };
}
const xd = eu("utf8", "u", (e) => "u" + new TextDecoder("utf8").decode(e), (e) => new TextEncoder().encode(e.substring(1))), Ys = eu("ascii", "a", (e) => {
  let t = "a";
  for (let r = 0; r < e.length; r++)
    t += String.fromCharCode(e[r]);
  return t;
}, (e) => {
  e = e.substring(1);
  const t = Xl(e.length);
  for (let r = 0; r < e.length; r++)
    t[r] = e.charCodeAt(r);
  return t;
}), tu = {
  utf8: xd,
  "utf-8": xd,
  hex: vd.base16,
  latin1: Ys,
  ascii: Ys,
  binary: Ys,
  ...vd
};
function Tt(e, t = "utf8") {
  const r = tu[t];
  if (!r)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString("utf8") : r.encoder.encode(e).substring(1);
}
function Rt(e, t = "utf8") {
  const r = tu[t];
  if (!r)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? vo(globalThis.Buffer.from(e, "utf-8")) : r.decoder.decode(`${r.prefix}${e}`);
}
function Wi(e) {
  return Tt(Rt(mo(e), X6), Yl);
}
function ru(e) {
  const t = Rt(n3, Ed), r = r3 + Tt(Pc([t, e]), Ed);
  return [e3, t3, r].join(Q6);
}
function t5(e) {
  return Tt(e, Yl);
}
function r5(e) {
  return Rt([Wi(e.header), Wi(e.payload)].join(Zl), J6);
}
function n5(e) {
  return [
    Wi(e.header),
    Wi(e.payload),
    t5(e.signature)
  ].join(Zl);
}
function Sd(e = ra.randomBytes(a3)) {
  return Eo.generateKeyPairFromSeed(e);
}
async function a5(e, t, r, n, a = re.fromMiliseconds(Date.now())) {
  const i = { alg: Z6, typ: Y6 }, c = ru(n.publicKey), s = a + r, d = { iss: c, sub: e, aud: t, iat: a, exp: s }, f = r5({ header: i, payload: d }), l = Eo.sign(n.secretKey, f);
  return n5({ header: i, payload: d, signature: l });
}
var xo = {}, ps = {};
Object.defineProperty(ps, "__esModule", { value: !0 });
var wt = se, kc = jt, i5 = 20;
function s5(e, t, r) {
  for (var n = 1634760805, a = 857760878, i = 2036477234, c = 1797285236, s = r[3] << 24 | r[2] << 16 | r[1] << 8 | r[0], d = r[7] << 24 | r[6] << 16 | r[5] << 8 | r[4], f = r[11] << 24 | r[10] << 16 | r[9] << 8 | r[8], l = r[15] << 24 | r[14] << 16 | r[13] << 8 | r[12], p = r[19] << 24 | r[18] << 16 | r[17] << 8 | r[16], w = r[23] << 24 | r[22] << 16 | r[21] << 8 | r[20], g = r[27] << 24 | r[26] << 16 | r[25] << 8 | r[24], m = r[31] << 24 | r[30] << 16 | r[29] << 8 | r[28], S = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], I = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], N = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], x = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], C = n, _ = a, D = i, b = c, o = s, h = d, U = f, E = l, T = p, P = w, z = g, v = m, y = S, L = I, M = N, H = x, F = 0; F < i5; F += 2)
    C = C + o | 0, y ^= C, y = y >>> 32 - 16 | y << 16, T = T + y | 0, o ^= T, o = o >>> 32 - 12 | o << 12, _ = _ + h | 0, L ^= _, L = L >>> 32 - 16 | L << 16, P = P + L | 0, h ^= P, h = h >>> 32 - 12 | h << 12, D = D + U | 0, M ^= D, M = M >>> 32 - 16 | M << 16, z = z + M | 0, U ^= z, U = U >>> 32 - 12 | U << 12, b = b + E | 0, H ^= b, H = H >>> 32 - 16 | H << 16, v = v + H | 0, E ^= v, E = E >>> 32 - 12 | E << 12, D = D + U | 0, M ^= D, M = M >>> 32 - 8 | M << 8, z = z + M | 0, U ^= z, U = U >>> 32 - 7 | U << 7, b = b + E | 0, H ^= b, H = H >>> 32 - 8 | H << 8, v = v + H | 0, E ^= v, E = E >>> 32 - 7 | E << 7, _ = _ + h | 0, L ^= _, L = L >>> 32 - 8 | L << 8, P = P + L | 0, h ^= P, h = h >>> 32 - 7 | h << 7, C = C + o | 0, y ^= C, y = y >>> 32 - 8 | y << 8, T = T + y | 0, o ^= T, o = o >>> 32 - 7 | o << 7, C = C + h | 0, H ^= C, H = H >>> 32 - 16 | H << 16, z = z + H | 0, h ^= z, h = h >>> 32 - 12 | h << 12, _ = _ + U | 0, y ^= _, y = y >>> 32 - 16 | y << 16, v = v + y | 0, U ^= v, U = U >>> 32 - 12 | U << 12, D = D + E | 0, L ^= D, L = L >>> 32 - 16 | L << 16, T = T + L | 0, E ^= T, E = E >>> 32 - 12 | E << 12, b = b + o | 0, M ^= b, M = M >>> 32 - 16 | M << 16, P = P + M | 0, o ^= P, o = o >>> 32 - 12 | o << 12, D = D + E | 0, L ^= D, L = L >>> 32 - 8 | L << 8, T = T + L | 0, E ^= T, E = E >>> 32 - 7 | E << 7, b = b + o | 0, M ^= b, M = M >>> 32 - 8 | M << 8, P = P + M | 0, o ^= P, o = o >>> 32 - 7 | o << 7, _ = _ + U | 0, y ^= _, y = y >>> 32 - 8 | y << 8, v = v + y | 0, U ^= v, U = U >>> 32 - 7 | U << 7, C = C + h | 0, H ^= C, H = H >>> 32 - 8 | H << 8, z = z + H | 0, h ^= z, h = h >>> 32 - 7 | h << 7;
  wt.writeUint32LE(C + n | 0, e, 0), wt.writeUint32LE(_ + a | 0, e, 4), wt.writeUint32LE(D + i | 0, e, 8), wt.writeUint32LE(b + c | 0, e, 12), wt.writeUint32LE(o + s | 0, e, 16), wt.writeUint32LE(h + d | 0, e, 20), wt.writeUint32LE(U + f | 0, e, 24), wt.writeUint32LE(E + l | 0, e, 28), wt.writeUint32LE(T + p | 0, e, 32), wt.writeUint32LE(P + w | 0, e, 36), wt.writeUint32LE(z + g | 0, e, 40), wt.writeUint32LE(v + m | 0, e, 44), wt.writeUint32LE(y + S | 0, e, 48), wt.writeUint32LE(L + I | 0, e, 52), wt.writeUint32LE(M + N | 0, e, 56), wt.writeUint32LE(H + x | 0, e, 60);
}
function nu(e, t, r, n, a) {
  if (a === void 0 && (a = 0), e.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (n.length < r.length)
    throw new Error("ChaCha: destination is shorter than source");
  var i, c;
  if (a === 0) {
    if (t.length !== 8 && t.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    i = new Uint8Array(16), c = i.length - t.length, i.set(t, c);
  } else {
    if (t.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    i = t, c = a;
  }
  for (var s = new Uint8Array(64), d = 0; d < r.length; d += 64) {
    s5(s, i, e);
    for (var f = d; f < d + 64 && f < r.length; f++)
      n[f] = r[f] ^ s[f - d];
    o5(i, 0, c);
  }
  return kc.wipe(s), a === 0 && kc.wipe(i), n;
}
ps.streamXOR = nu;
function c5(e, t, r, n) {
  return n === void 0 && (n = 0), kc.wipe(r), nu(e, t, r, r, n);
}
ps.stream = c5;
function o5(e, t, r) {
  for (var n = 1; r--; )
    n = n + (e[t] & 255) | 0, e[t] = n & 255, n >>>= 8, t++;
  if (n > 0)
    throw new Error("ChaCha: counter overflow");
}
var au = {}, Jr = {};
Object.defineProperty(Jr, "__esModule", { value: !0 });
function f5(e, t, r) {
  return ~(e - 1) & t | e - 1 & r;
}
Jr.select = f5;
function d5(e, t) {
  return (e | 0) - (t | 0) - 1 >>> 31 & 1;
}
Jr.lessOrEqual = d5;
function iu(e, t) {
  if (e.length !== t.length)
    return 0;
  for (var r = 0, n = 0; n < e.length; n++)
    r |= e[n] ^ t[n];
  return 1 & r - 1 >>> 8;
}
Jr.compare = iu;
function l5(e, t) {
  return e.length === 0 || t.length === 0 ? !1 : iu(e, t) !== 0;
}
Jr.equal = l5;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  var t = Jr, r = jt;
  e.DIGEST_LENGTH = 16;
  var n = (
    /** @class */
    function() {
      function c(s) {
        this.digestLength = e.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var d = s[0] | s[1] << 8;
        this._r[0] = d & 8191;
        var f = s[2] | s[3] << 8;
        this._r[1] = (d >>> 13 | f << 3) & 8191;
        var l = s[4] | s[5] << 8;
        this._r[2] = (f >>> 10 | l << 6) & 7939;
        var p = s[6] | s[7] << 8;
        this._r[3] = (l >>> 7 | p << 9) & 8191;
        var w = s[8] | s[9] << 8;
        this._r[4] = (p >>> 4 | w << 12) & 255, this._r[5] = w >>> 1 & 8190;
        var g = s[10] | s[11] << 8;
        this._r[6] = (w >>> 14 | g << 2) & 8191;
        var m = s[12] | s[13] << 8;
        this._r[7] = (g >>> 11 | m << 5) & 8065;
        var S = s[14] | s[15] << 8;
        this._r[8] = (m >>> 8 | S << 8) & 8191, this._r[9] = S >>> 5 & 127, this._pad[0] = s[16] | s[17] << 8, this._pad[1] = s[18] | s[19] << 8, this._pad[2] = s[20] | s[21] << 8, this._pad[3] = s[22] | s[23] << 8, this._pad[4] = s[24] | s[25] << 8, this._pad[5] = s[26] | s[27] << 8, this._pad[6] = s[28] | s[29] << 8, this._pad[7] = s[30] | s[31] << 8;
      }
      return c.prototype._blocks = function(s, d, f) {
        for (var l = this._fin ? 0 : 2048, p = this._h[0], w = this._h[1], g = this._h[2], m = this._h[3], S = this._h[4], I = this._h[5], N = this._h[6], x = this._h[7], C = this._h[8], _ = this._h[9], D = this._r[0], b = this._r[1], o = this._r[2], h = this._r[3], U = this._r[4], E = this._r[5], T = this._r[6], P = this._r[7], z = this._r[8], v = this._r[9]; f >= 16; ) {
          var y = s[d + 0] | s[d + 1] << 8;
          p += y & 8191;
          var L = s[d + 2] | s[d + 3] << 8;
          w += (y >>> 13 | L << 3) & 8191;
          var M = s[d + 4] | s[d + 5] << 8;
          g += (L >>> 10 | M << 6) & 8191;
          var H = s[d + 6] | s[d + 7] << 8;
          m += (M >>> 7 | H << 9) & 8191;
          var F = s[d + 8] | s[d + 9] << 8;
          S += (H >>> 4 | F << 12) & 8191, I += F >>> 1 & 8191;
          var j = s[d + 10] | s[d + 11] << 8;
          N += (F >>> 14 | j << 2) & 8191;
          var V = s[d + 12] | s[d + 13] << 8;
          x += (j >>> 11 | V << 5) & 8191;
          var W = s[d + 14] | s[d + 15] << 8;
          C += (V >>> 8 | W << 8) & 8191, _ += W >>> 5 | l;
          var K = 0, Q = K;
          Q += p * D, Q += w * (5 * v), Q += g * (5 * z), Q += m * (5 * P), Q += S * (5 * T), K = Q >>> 13, Q &= 8191, Q += I * (5 * E), Q += N * (5 * U), Q += x * (5 * h), Q += C * (5 * o), Q += _ * (5 * b), K += Q >>> 13, Q &= 8191;
          var Z = K;
          Z += p * b, Z += w * D, Z += g * (5 * v), Z += m * (5 * z), Z += S * (5 * P), K = Z >>> 13, Z &= 8191, Z += I * (5 * T), Z += N * (5 * E), Z += x * (5 * U), Z += C * (5 * h), Z += _ * (5 * o), K += Z >>> 13, Z &= 8191;
          var te = K;
          te += p * o, te += w * b, te += g * D, te += m * (5 * v), te += S * (5 * z), K = te >>> 13, te &= 8191, te += I * (5 * P), te += N * (5 * T), te += x * (5 * E), te += C * (5 * U), te += _ * (5 * h), K += te >>> 13, te &= 8191;
          var $ = K;
          $ += p * h, $ += w * o, $ += g * b, $ += m * D, $ += S * (5 * v), K = $ >>> 13, $ &= 8191, $ += I * (5 * z), $ += N * (5 * P), $ += x * (5 * T), $ += C * (5 * E), $ += _ * (5 * U), K += $ >>> 13, $ &= 8191;
          var B = K;
          B += p * U, B += w * h, B += g * o, B += m * b, B += S * D, K = B >>> 13, B &= 8191, B += I * (5 * v), B += N * (5 * z), B += x * (5 * P), B += C * (5 * T), B += _ * (5 * E), K += B >>> 13, B &= 8191;
          var R = K;
          R += p * E, R += w * U, R += g * h, R += m * o, R += S * b, K = R >>> 13, R &= 8191, R += I * D, R += N * (5 * v), R += x * (5 * z), R += C * (5 * P), R += _ * (5 * T), K += R >>> 13, R &= 8191;
          var u = K;
          u += p * T, u += w * E, u += g * U, u += m * h, u += S * o, K = u >>> 13, u &= 8191, u += I * b, u += N * D, u += x * (5 * v), u += C * (5 * z), u += _ * (5 * P), K += u >>> 13, u &= 8191;
          var O = K;
          O += p * P, O += w * T, O += g * E, O += m * U, O += S * h, K = O >>> 13, O &= 8191, O += I * o, O += N * b, O += x * D, O += C * (5 * v), O += _ * (5 * z), K += O >>> 13, O &= 8191;
          var G = K;
          G += p * z, G += w * P, G += g * T, G += m * E, G += S * U, K = G >>> 13, G &= 8191, G += I * h, G += N * o, G += x * b, G += C * D, G += _ * (5 * v), K += G >>> 13, G &= 8191;
          var Y = K;
          Y += p * v, Y += w * z, Y += g * P, Y += m * T, Y += S * E, K = Y >>> 13, Y &= 8191, Y += I * U, Y += N * h, Y += x * o, Y += C * b, Y += _ * D, K += Y >>> 13, Y &= 8191, K = (K << 2) + K | 0, K = K + Q | 0, Q = K & 8191, K = K >>> 13, Z += K, p = Q, w = Z, g = te, m = $, S = B, I = R, N = u, x = O, C = G, _ = Y, d += 16, f -= 16;
        }
        this._h[0] = p, this._h[1] = w, this._h[2] = g, this._h[3] = m, this._h[4] = S, this._h[5] = I, this._h[6] = N, this._h[7] = x, this._h[8] = C, this._h[9] = _;
      }, c.prototype.finish = function(s, d) {
        d === void 0 && (d = 0);
        var f = new Uint16Array(10), l, p, w, g;
        if (this._leftover) {
          for (g = this._leftover, this._buffer[g++] = 1; g < 16; g++)
            this._buffer[g] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (l = this._h[1] >>> 13, this._h[1] &= 8191, g = 2; g < 10; g++)
          this._h[g] += l, l = this._h[g] >>> 13, this._h[g] &= 8191;
        for (this._h[0] += l * 5, l = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += l, l = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += l, f[0] = this._h[0] + 5, l = f[0] >>> 13, f[0] &= 8191, g = 1; g < 10; g++)
          f[g] = this._h[g] + l, l = f[g] >>> 13, f[g] &= 8191;
        for (f[9] -= 8192, p = (l ^ 1) - 1, g = 0; g < 10; g++)
          f[g] &= p;
        for (p = ~p, g = 0; g < 10; g++)
          this._h[g] = this._h[g] & p | f[g];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, w = this._h[0] + this._pad[0], this._h[0] = w & 65535, g = 1; g < 8; g++)
          w = (this._h[g] + this._pad[g] | 0) + (w >>> 16) | 0, this._h[g] = w & 65535;
        return s[d + 0] = this._h[0] >>> 0, s[d + 1] = this._h[0] >>> 8, s[d + 2] = this._h[1] >>> 0, s[d + 3] = this._h[1] >>> 8, s[d + 4] = this._h[2] >>> 0, s[d + 5] = this._h[2] >>> 8, s[d + 6] = this._h[3] >>> 0, s[d + 7] = this._h[3] >>> 8, s[d + 8] = this._h[4] >>> 0, s[d + 9] = this._h[4] >>> 8, s[d + 10] = this._h[5] >>> 0, s[d + 11] = this._h[5] >>> 8, s[d + 12] = this._h[6] >>> 0, s[d + 13] = this._h[6] >>> 8, s[d + 14] = this._h[7] >>> 0, s[d + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, c.prototype.update = function(s) {
        var d = 0, f = s.length, l;
        if (this._leftover) {
          l = 16 - this._leftover, l > f && (l = f);
          for (var p = 0; p < l; p++)
            this._buffer[this._leftover + p] = s[d + p];
          if (f -= l, d += l, this._leftover += l, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (f >= 16 && (l = f - f % 16, this._blocks(s, d, l), d += l, f -= l), f) {
          for (var p = 0; p < f; p++)
            this._buffer[this._leftover + p] = s[d + p];
          this._leftover += f;
        }
        return this;
      }, c.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var s = new Uint8Array(16);
        return this.finish(s), s;
      }, c.prototype.clean = function() {
        return r.wipe(this._buffer), r.wipe(this._r), r.wipe(this._h), r.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, c;
    }()
  );
  e.Poly1305 = n;
  function a(c, s) {
    var d = new n(c);
    d.update(s);
    var f = d.digest();
    return d.clean(), f;
  }
  e.oneTimeAuth = a;
  function i(c, s) {
    return c.length !== e.DIGEST_LENGTH || s.length !== e.DIGEST_LENGTH ? !1 : t.equal(c, s);
  }
  e.equal = i;
})(au);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  var t = ps, r = au, n = jt, a = se, i = Jr;
  e.KEY_LENGTH = 32, e.NONCE_LENGTH = 12, e.TAG_LENGTH = 16;
  var c = new Uint8Array(16), s = (
    /** @class */
    function() {
      function d(f) {
        if (this.nonceLength = e.NONCE_LENGTH, this.tagLength = e.TAG_LENGTH, f.length !== e.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(f);
      }
      return d.prototype.seal = function(f, l, p, w) {
        if (f.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var g = new Uint8Array(16);
        g.set(f, g.length - f.length);
        var m = new Uint8Array(32);
        t.stream(this._key, g, m, 4);
        var S = l.length + this.tagLength, I;
        if (w) {
          if (w.length !== S)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          I = w;
        } else
          I = new Uint8Array(S);
        return t.streamXOR(this._key, g, l, I, 4), this._authenticate(I.subarray(I.length - this.tagLength, I.length), m, I.subarray(0, I.length - this.tagLength), p), n.wipe(g), I;
      }, d.prototype.open = function(f, l, p, w) {
        if (f.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (l.length < this.tagLength)
          return null;
        var g = new Uint8Array(16);
        g.set(f, g.length - f.length);
        var m = new Uint8Array(32);
        t.stream(this._key, g, m, 4);
        var S = new Uint8Array(this.tagLength);
        if (this._authenticate(S, m, l.subarray(0, l.length - this.tagLength), p), !i.equal(S, l.subarray(l.length - this.tagLength, l.length)))
          return null;
        var I = l.length - this.tagLength, N;
        if (w) {
          if (w.length !== I)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          N = w;
        } else
          N = new Uint8Array(I);
        return t.streamXOR(this._key, g, l.subarray(0, l.length - this.tagLength), N, 4), n.wipe(g), N;
      }, d.prototype.clean = function() {
        return n.wipe(this._key), this;
      }, d.prototype._authenticate = function(f, l, p, w) {
        var g = new r.Poly1305(l);
        w && (g.update(w), w.length % 16 > 0 && g.update(c.subarray(w.length % 16))), g.update(p), p.length % 16 > 0 && g.update(c.subarray(p.length % 16));
        var m = new Uint8Array(8);
        w && a.writeUint64LE(w.length, m), g.update(m), a.writeUint64LE(p.length, m), g.update(m);
        for (var S = g.digest(), I = 0; I < S.length; I++)
          f[I] = S[I];
        g.clean(), n.wipe(S), n.wipe(m);
      }, d;
    }()
  );
  e.ChaCha20Poly1305 = s;
})(xo);
var su = {}, ni = {}, So = {};
Object.defineProperty(So, "__esModule", { value: !0 });
function u5(e) {
  return typeof e.saveState < "u" && typeof e.restoreState < "u" && typeof e.cleanSavedState < "u";
}
So.isSerializableHash = u5;
Object.defineProperty(ni, "__esModule", { value: !0 });
var ar = So, h5 = Jr, b5 = jt, cu = (
  /** @class */
  function() {
    function e(t, r) {
      this._finished = !1, this._inner = new t(), this._outer = new t(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var n = new Uint8Array(this.blockSize);
      r.length > this.blockSize ? this._inner.update(r).finish(n).clean() : n.set(r);
      for (var a = 0; a < n.length; a++)
        n[a] ^= 54;
      this._inner.update(n);
      for (var a = 0; a < n.length; a++)
        n[a] ^= 106;
      this._outer.update(n), ar.isSerializableHash(this._inner) && ar.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), b5.wipe(n);
    }
    return e.prototype.reset = function() {
      if (!ar.isSerializableHash(this._inner) || !ar.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, e.prototype.clean = function() {
      ar.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), ar.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, e.prototype.update = function(t) {
      return this._inner.update(t), this;
    }, e.prototype.finish = function(t) {
      return this._finished ? (this._outer.finish(t), this) : (this._inner.finish(t), this._outer.update(t.subarray(0, this.digestLength)).finish(t), this._finished = !0, this);
    }, e.prototype.digest = function() {
      var t = new Uint8Array(this.digestLength);
      return this.finish(t), t;
    }, e.prototype.saveState = function() {
      if (!ar.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, e.prototype.restoreState = function(t) {
      if (!ar.isSerializableHash(this._inner) || !ar.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(t), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, e.prototype.cleanSavedState = function(t) {
      if (!ar.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(t);
    }, e;
  }()
);
ni.HMAC = cu;
function p5(e, t, r) {
  var n = new cu(e, t);
  n.update(r);
  var a = n.digest();
  return n.clean(), a;
}
ni.hmac = p5;
ni.equal = h5.equal;
Object.defineProperty(su, "__esModule", { value: !0 });
var Dd = ni, Ad = jt, g5 = (
  /** @class */
  function() {
    function e(t, r, n, a) {
      n === void 0 && (n = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = t, this._info = a;
      var i = Dd.hmac(this._hash, n, r);
      this._hmac = new Dd.HMAC(t, i), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return e.prototype._fillBuffer = function() {
      this._counter[0]++;
      var t = this._counter[0];
      if (t === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), t > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, e.prototype.expand = function(t) {
      for (var r = new Uint8Array(t), n = 0; n < r.length; n++)
        this._bufpos === this._buffer.length && this._fillBuffer(), r[n] = this._buffer[this._bufpos++];
      return r;
    }, e.prototype.clean = function() {
      this._hmac.clean(), Ad.wipe(this._buffer), Ad.wipe(this._counter), this._bufpos = 0;
    }, e;
  }()
), _5 = su.HKDF = g5, gs = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  var t = se, r = jt;
  e.DIGEST_LENGTH = 32, e.BLOCK_SIZE = 64;
  var n = (
    /** @class */
    function() {
      function s() {
        this.digestLength = e.DIGEST_LENGTH, this.blockSize = e.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return s.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, s.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, s.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._temp), this.reset();
      }, s.prototype.update = function(d, f) {
        if (f === void 0 && (f = d.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var l = 0;
        if (this._bytesHashed += f, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && f > 0; )
            this._buffer[this._bufferLength++] = d[l++], f--;
          this._bufferLength === this.blockSize && (i(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (f >= this.blockSize && (l = i(this._temp, this._state, d, l, f), f %= this.blockSize); f > 0; )
          this._buffer[this._bufferLength++] = d[l++], f--;
        return this;
      }, s.prototype.finish = function(d) {
        if (!this._finished) {
          var f = this._bytesHashed, l = this._bufferLength, p = f / 536870912 | 0, w = f << 3, g = f % 64 < 56 ? 64 : 128;
          this._buffer[l] = 128;
          for (var m = l + 1; m < g - 8; m++)
            this._buffer[m] = 0;
          t.writeUint32BE(p, this._buffer, g - 8), t.writeUint32BE(w, this._buffer, g - 4), i(this._temp, this._state, this._buffer, 0, g), this._finished = !0;
        }
        for (var m = 0; m < this.digestLength / 4; m++)
          t.writeUint32BE(this._state[m], d, m * 4);
        return this;
      }, s.prototype.digest = function() {
        var d = new Uint8Array(this.digestLength);
        return this.finish(d), d;
      }, s.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, s.prototype.restoreState = function(d) {
        return this._state.set(d.state), this._bufferLength = d.bufferLength, d.buffer && this._buffer.set(d.buffer), this._bytesHashed = d.bytesHashed, this._finished = !1, this;
      }, s.prototype.cleanSavedState = function(d) {
        r.wipe(d.state), d.buffer && r.wipe(d.buffer), d.bufferLength = 0, d.bytesHashed = 0;
      }, s;
    }()
  );
  e.SHA256 = n;
  var a = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function i(s, d, f, l, p) {
    for (; p >= 64; ) {
      for (var w = d[0], g = d[1], m = d[2], S = d[3], I = d[4], N = d[5], x = d[6], C = d[7], _ = 0; _ < 16; _++) {
        var D = l + _ * 4;
        s[_] = t.readUint32BE(f, D);
      }
      for (var _ = 16; _ < 64; _++) {
        var b = s[_ - 2], o = (b >>> 17 | b << 32 - 17) ^ (b >>> 19 | b << 32 - 19) ^ b >>> 10;
        b = s[_ - 15];
        var h = (b >>> 7 | b << 32 - 7) ^ (b >>> 18 | b << 32 - 18) ^ b >>> 3;
        s[_] = (o + s[_ - 7] | 0) + (h + s[_ - 16] | 0);
      }
      for (var _ = 0; _ < 64; _++) {
        var o = (((I >>> 6 | I << 26) ^ (I >>> 11 | I << 21) ^ (I >>> 25 | I << 7)) + (I & N ^ ~I & x) | 0) + (C + (a[_] + s[_] | 0) | 0) | 0, h = ((w >>> 2 | w << 32 - 2) ^ (w >>> 13 | w << 32 - 13) ^ (w >>> 22 | w << 32 - 22)) + (w & g ^ w & m ^ g & m) | 0;
        C = x, x = N, N = I, I = S + o | 0, S = m, m = g, g = w, w = o + h | 0;
      }
      d[0] += w, d[1] += g, d[2] += m, d[3] += S, d[4] += I, d[5] += N, d[6] += x, d[7] += C, l += 64, p -= 64;
    }
    return l;
  }
  function c(s) {
    var d = new n();
    d.update(s);
    var f = d.digest();
    return d.clean(), f;
  }
  e.hash = c;
})(gs);
var Do = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.sharedKey = e.generateKeyPair = e.generateKeyPairFromSeed = e.scalarMultBase = e.scalarMult = e.SHARED_KEY_LENGTH = e.SECRET_KEY_LENGTH = e.PUBLIC_KEY_LENGTH = void 0;
  const t = ra, r = jt;
  e.PUBLIC_KEY_LENGTH = 32, e.SECRET_KEY_LENGTH = 32, e.SHARED_KEY_LENGTH = 32;
  function n(_) {
    const D = new Float64Array(16);
    if (_)
      for (let b = 0; b < _.length; b++)
        D[b] = _[b];
    return D;
  }
  const a = new Uint8Array(32);
  a[0] = 9;
  const i = n([56129, 1]);
  function c(_) {
    let D = 1;
    for (let b = 0; b < 16; b++) {
      let o = _[b] + D + 65535;
      D = Math.floor(o / 65536), _[b] = o - D * 65536;
    }
    _[0] += D - 1 + 37 * (D - 1);
  }
  function s(_, D, b) {
    const o = ~(b - 1);
    for (let h = 0; h < 16; h++) {
      const U = o & (_[h] ^ D[h]);
      _[h] ^= U, D[h] ^= U;
    }
  }
  function d(_, D) {
    const b = n(), o = n();
    for (let h = 0; h < 16; h++)
      o[h] = D[h];
    c(o), c(o), c(o);
    for (let h = 0; h < 2; h++) {
      b[0] = o[0] - 65517;
      for (let E = 1; E < 15; E++)
        b[E] = o[E] - 65535 - (b[E - 1] >> 16 & 1), b[E - 1] &= 65535;
      b[15] = o[15] - 32767 - (b[14] >> 16 & 1);
      const U = b[15] >> 16 & 1;
      b[14] &= 65535, s(o, b, 1 - U);
    }
    for (let h = 0; h < 16; h++)
      _[2 * h] = o[h] & 255, _[2 * h + 1] = o[h] >> 8;
  }
  function f(_, D) {
    for (let b = 0; b < 16; b++)
      _[b] = D[2 * b] + (D[2 * b + 1] << 8);
    _[15] &= 32767;
  }
  function l(_, D, b) {
    for (let o = 0; o < 16; o++)
      _[o] = D[o] + b[o];
  }
  function p(_, D, b) {
    for (let o = 0; o < 16; o++)
      _[o] = D[o] - b[o];
  }
  function w(_, D, b) {
    let o, h, U = 0, E = 0, T = 0, P = 0, z = 0, v = 0, y = 0, L = 0, M = 0, H = 0, F = 0, j = 0, V = 0, W = 0, K = 0, Q = 0, Z = 0, te = 0, $ = 0, B = 0, R = 0, u = 0, O = 0, G = 0, Y = 0, ce = 0, pe = 0, le = 0, De = 0, ze = 0, Fe = 0, me = b[0], _e = b[1], ge = b[2], he = b[3], ue = b[4], de = b[5], fe = b[6], ae = b[7], be = b[8], ye = b[9], ie = b[10], ve = b[11], Se = b[12], Ce = b[13], Te = b[14], Ae = b[15];
    o = D[0], U += o * me, E += o * _e, T += o * ge, P += o * he, z += o * ue, v += o * de, y += o * fe, L += o * ae, M += o * be, H += o * ye, F += o * ie, j += o * ve, V += o * Se, W += o * Ce, K += o * Te, Q += o * Ae, o = D[1], E += o * me, T += o * _e, P += o * ge, z += o * he, v += o * ue, y += o * de, L += o * fe, M += o * ae, H += o * be, F += o * ye, j += o * ie, V += o * ve, W += o * Se, K += o * Ce, Q += o * Te, Z += o * Ae, o = D[2], T += o * me, P += o * _e, z += o * ge, v += o * he, y += o * ue, L += o * de, M += o * fe, H += o * ae, F += o * be, j += o * ye, V += o * ie, W += o * ve, K += o * Se, Q += o * Ce, Z += o * Te, te += o * Ae, o = D[3], P += o * me, z += o * _e, v += o * ge, y += o * he, L += o * ue, M += o * de, H += o * fe, F += o * ae, j += o * be, V += o * ye, W += o * ie, K += o * ve, Q += o * Se, Z += o * Ce, te += o * Te, $ += o * Ae, o = D[4], z += o * me, v += o * _e, y += o * ge, L += o * he, M += o * ue, H += o * de, F += o * fe, j += o * ae, V += o * be, W += o * ye, K += o * ie, Q += o * ve, Z += o * Se, te += o * Ce, $ += o * Te, B += o * Ae, o = D[5], v += o * me, y += o * _e, L += o * ge, M += o * he, H += o * ue, F += o * de, j += o * fe, V += o * ae, W += o * be, K += o * ye, Q += o * ie, Z += o * ve, te += o * Se, $ += o * Ce, B += o * Te, R += o * Ae, o = D[6], y += o * me, L += o * _e, M += o * ge, H += o * he, F += o * ue, j += o * de, V += o * fe, W += o * ae, K += o * be, Q += o * ye, Z += o * ie, te += o * ve, $ += o * Se, B += o * Ce, R += o * Te, u += o * Ae, o = D[7], L += o * me, M += o * _e, H += o * ge, F += o * he, j += o * ue, V += o * de, W += o * fe, K += o * ae, Q += o * be, Z += o * ye, te += o * ie, $ += o * ve, B += o * Se, R += o * Ce, u += o * Te, O += o * Ae, o = D[8], M += o * me, H += o * _e, F += o * ge, j += o * he, V += o * ue, W += o * de, K += o * fe, Q += o * ae, Z += o * be, te += o * ye, $ += o * ie, B += o * ve, R += o * Se, u += o * Ce, O += o * Te, G += o * Ae, o = D[9], H += o * me, F += o * _e, j += o * ge, V += o * he, W += o * ue, K += o * de, Q += o * fe, Z += o * ae, te += o * be, $ += o * ye, B += o * ie, R += o * ve, u += o * Se, O += o * Ce, G += o * Te, Y += o * Ae, o = D[10], F += o * me, j += o * _e, V += o * ge, W += o * he, K += o * ue, Q += o * de, Z += o * fe, te += o * ae, $ += o * be, B += o * ye, R += o * ie, u += o * ve, O += o * Se, G += o * Ce, Y += o * Te, ce += o * Ae, o = D[11], j += o * me, V += o * _e, W += o * ge, K += o * he, Q += o * ue, Z += o * de, te += o * fe, $ += o * ae, B += o * be, R += o * ye, u += o * ie, O += o * ve, G += o * Se, Y += o * Ce, ce += o * Te, pe += o * Ae, o = D[12], V += o * me, W += o * _e, K += o * ge, Q += o * he, Z += o * ue, te += o * de, $ += o * fe, B += o * ae, R += o * be, u += o * ye, O += o * ie, G += o * ve, Y += o * Se, ce += o * Ce, pe += o * Te, le += o * Ae, o = D[13], W += o * me, K += o * _e, Q += o * ge, Z += o * he, te += o * ue, $ += o * de, B += o * fe, R += o * ae, u += o * be, O += o * ye, G += o * ie, Y += o * ve, ce += o * Se, pe += o * Ce, le += o * Te, De += o * Ae, o = D[14], K += o * me, Q += o * _e, Z += o * ge, te += o * he, $ += o * ue, B += o * de, R += o * fe, u += o * ae, O += o * be, G += o * ye, Y += o * ie, ce += o * ve, pe += o * Se, le += o * Ce, De += o * Te, ze += o * Ae, o = D[15], Q += o * me, Z += o * _e, te += o * ge, $ += o * he, B += o * ue, R += o * de, u += o * fe, O += o * ae, G += o * be, Y += o * ye, ce += o * ie, pe += o * ve, le += o * Se, De += o * Ce, ze += o * Te, Fe += o * Ae, U += 38 * Z, E += 38 * te, T += 38 * $, P += 38 * B, z += 38 * R, v += 38 * u, y += 38 * O, L += 38 * G, M += 38 * Y, H += 38 * ce, F += 38 * pe, j += 38 * le, V += 38 * De, W += 38 * ze, K += 38 * Fe, h = 1, o = U + h + 65535, h = Math.floor(o / 65536), U = o - h * 65536, o = E + h + 65535, h = Math.floor(o / 65536), E = o - h * 65536, o = T + h + 65535, h = Math.floor(o / 65536), T = o - h * 65536, o = P + h + 65535, h = Math.floor(o / 65536), P = o - h * 65536, o = z + h + 65535, h = Math.floor(o / 65536), z = o - h * 65536, o = v + h + 65535, h = Math.floor(o / 65536), v = o - h * 65536, o = y + h + 65535, h = Math.floor(o / 65536), y = o - h * 65536, o = L + h + 65535, h = Math.floor(o / 65536), L = o - h * 65536, o = M + h + 65535, h = Math.floor(o / 65536), M = o - h * 65536, o = H + h + 65535, h = Math.floor(o / 65536), H = o - h * 65536, o = F + h + 65535, h = Math.floor(o / 65536), F = o - h * 65536, o = j + h + 65535, h = Math.floor(o / 65536), j = o - h * 65536, o = V + h + 65535, h = Math.floor(o / 65536), V = o - h * 65536, o = W + h + 65535, h = Math.floor(o / 65536), W = o - h * 65536, o = K + h + 65535, h = Math.floor(o / 65536), K = o - h * 65536, o = Q + h + 65535, h = Math.floor(o / 65536), Q = o - h * 65536, U += h - 1 + 37 * (h - 1), h = 1, o = U + h + 65535, h = Math.floor(o / 65536), U = o - h * 65536, o = E + h + 65535, h = Math.floor(o / 65536), E = o - h * 65536, o = T + h + 65535, h = Math.floor(o / 65536), T = o - h * 65536, o = P + h + 65535, h = Math.floor(o / 65536), P = o - h * 65536, o = z + h + 65535, h = Math.floor(o / 65536), z = o - h * 65536, o = v + h + 65535, h = Math.floor(o / 65536), v = o - h * 65536, o = y + h + 65535, h = Math.floor(o / 65536), y = o - h * 65536, o = L + h + 65535, h = Math.floor(o / 65536), L = o - h * 65536, o = M + h + 65535, h = Math.floor(o / 65536), M = o - h * 65536, o = H + h + 65535, h = Math.floor(o / 65536), H = o - h * 65536, o = F + h + 65535, h = Math.floor(o / 65536), F = o - h * 65536, o = j + h + 65535, h = Math.floor(o / 65536), j = o - h * 65536, o = V + h + 65535, h = Math.floor(o / 65536), V = o - h * 65536, o = W + h + 65535, h = Math.floor(o / 65536), W = o - h * 65536, o = K + h + 65535, h = Math.floor(o / 65536), K = o - h * 65536, o = Q + h + 65535, h = Math.floor(o / 65536), Q = o - h * 65536, U += h - 1 + 37 * (h - 1), _[0] = U, _[1] = E, _[2] = T, _[3] = P, _[4] = z, _[5] = v, _[6] = y, _[7] = L, _[8] = M, _[9] = H, _[10] = F, _[11] = j, _[12] = V, _[13] = W, _[14] = K, _[15] = Q;
  }
  function g(_, D) {
    w(_, D, D);
  }
  function m(_, D) {
    const b = n();
    for (let o = 0; o < 16; o++)
      b[o] = D[o];
    for (let o = 253; o >= 0; o--)
      g(b, b), o !== 2 && o !== 4 && w(b, b, D);
    for (let o = 0; o < 16; o++)
      _[o] = b[o];
  }
  function S(_, D) {
    const b = new Uint8Array(32), o = new Float64Array(80), h = n(), U = n(), E = n(), T = n(), P = n(), z = n();
    for (let M = 0; M < 31; M++)
      b[M] = _[M];
    b[31] = _[31] & 127 | 64, b[0] &= 248, f(o, D);
    for (let M = 0; M < 16; M++)
      U[M] = o[M];
    h[0] = T[0] = 1;
    for (let M = 254; M >= 0; --M) {
      const H = b[M >>> 3] >>> (M & 7) & 1;
      s(h, U, H), s(E, T, H), l(P, h, E), p(h, h, E), l(E, U, T), p(U, U, T), g(T, P), g(z, h), w(h, E, h), w(E, U, P), l(P, h, E), p(h, h, E), g(U, h), p(E, T, z), w(h, E, i), l(h, h, T), w(E, E, h), w(h, T, z), w(T, U, o), g(U, P), s(h, U, H), s(E, T, H);
    }
    for (let M = 0; M < 16; M++)
      o[M + 16] = h[M], o[M + 32] = E[M], o[M + 48] = U[M], o[M + 64] = T[M];
    const v = o.subarray(32), y = o.subarray(16);
    m(v, v), w(y, y, v);
    const L = new Uint8Array(32);
    return d(L, y), L;
  }
  e.scalarMult = S;
  function I(_) {
    return S(_, a);
  }
  e.scalarMultBase = I;
  function N(_) {
    if (_.length !== e.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${e.SECRET_KEY_LENGTH} bytes`);
    const D = new Uint8Array(_);
    return {
      publicKey: I(D),
      secretKey: D
    };
  }
  e.generateKeyPairFromSeed = N;
  function x(_) {
    const D = (0, t.randomBytes)(32, _), b = N(D);
    return (0, r.wipe)(D), b;
  }
  e.generateKeyPair = x;
  function C(_, D, b = !1) {
    if (_.length !== e.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (D.length !== e.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const o = S(_, D);
    if (b) {
      let h = 0;
      for (let U = 0; U < o.length; U++)
        h |= o[U];
      if (h === 0)
        throw new Error("X25519: invalid shared key");
    }
    return o;
  }
  e.sharedKey = C;
})(Do);
var Id = globalThis && globalThis.__spreadArray || function(e, t, r) {
  if (r || arguments.length === 2)
    for (var n = 0, a = t.length, i; n < a; n++)
      (i || !(n in t)) && (i || (i = Array.prototype.slice.call(t, 0, n)), i[n] = t[n]);
  return e.concat(i || Array.prototype.slice.call(t));
}, y5 = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.name = t, this.version = r, this.os = n, this.type = "browser";
    }
    return e;
  }()
), w5 = (
  /** @class */
  function() {
    function e(t) {
      this.version = t, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return e;
  }()
), m5 = (
  /** @class */
  function() {
    function e(t, r, n, a) {
      this.name = t, this.version = r, this.os = n, this.bot = a, this.type = "bot-device";
    }
    return e;
  }()
), E5 = (
  /** @class */
  function() {
    function e() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return e;
  }()
), v5 = (
  /** @class */
  function() {
    function e() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return e;
  }()
), x5 = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, S5 = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, Cd = 3, D5 = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", x5]
], Td = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function ou(e) {
  return e ? Od(e) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new v5() : typeof navigator < "u" ? Od(navigator.userAgent) : C5();
}
function A5(e) {
  return e !== "" && D5.reduce(function(t, r) {
    var n = r[0], a = r[1];
    if (t)
      return t;
    var i = a.exec(e);
    return !!i && [n, i];
  }, !1);
}
function Od(e) {
  var t = A5(e);
  if (!t)
    return null;
  var r = t[0], n = t[1];
  if (r === "searchbot")
    return new E5();
  var a = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  a ? a.length < Cd && (a = Id(Id([], a, !0), T5(Cd - a.length), !0)) : a = [];
  var i = a.join("."), c = I5(e), s = S5.exec(e);
  return s && s[1] ? new m5(r, i, c, s[1]) : new y5(r, i, c);
}
function I5(e) {
  for (var t = 0, r = Td.length; t < r; t++) {
    var n = Td[t], a = n[0], i = n[1], c = i.exec(e);
    if (c)
      return a;
  }
  return null;
}
function C5() {
  var e = typeof process < "u" && process.version;
  return e ? new w5(process.version.slice(1)) : null;
}
function T5(e) {
  for (var t = [], r = 0; r < e; r++)
    t.push("0");
  return t;
}
var Re = {};
Object.defineProperty(Re, "__esModule", { value: !0 });
Re.getLocalStorage = Re.getLocalStorageOrThrow = Re.getCrypto = Re.getCryptoOrThrow = du = Re.getLocation = Re.getLocationOrThrow = Ao = Re.getNavigator = Re.getNavigatorOrThrow = fu = Re.getDocument = Re.getDocumentOrThrow = Re.getFromWindowOrThrow = Re.getFromWindow = void 0;
function In(e) {
  let t;
  return typeof window < "u" && typeof window[e] < "u" && (t = window[e]), t;
}
Re.getFromWindow = In;
function na(e) {
  const t = In(e);
  if (!t)
    throw new Error(`${e} is not defined in Window`);
  return t;
}
Re.getFromWindowOrThrow = na;
function O5() {
  return na("document");
}
Re.getDocumentOrThrow = O5;
function N5() {
  return In("document");
}
var fu = Re.getDocument = N5;
function R5() {
  return na("navigator");
}
Re.getNavigatorOrThrow = R5;
function L5() {
  return In("navigator");
}
var Ao = Re.getNavigator = L5;
function P5() {
  return na("location");
}
Re.getLocationOrThrow = P5;
function k5() {
  return In("location");
}
var du = Re.getLocation = k5;
function U5() {
  return na("crypto");
}
Re.getCryptoOrThrow = U5;
function F5() {
  return In("crypto");
}
Re.getCrypto = F5;
function $5() {
  return na("localStorage");
}
Re.getLocalStorageOrThrow = $5;
function B5() {
  return In("localStorage");
}
Re.getLocalStorage = B5;
var Io = {};
Object.defineProperty(Io, "__esModule", { value: !0 });
var lu = Io.getWindowMetadata = void 0;
const Nd = Re;
function M5() {
  let e, t;
  try {
    e = Nd.getDocumentOrThrow(), t = Nd.getLocationOrThrow();
  } catch {
    return null;
  }
  function r() {
    const p = e.getElementsByTagName("link"), w = [];
    for (let g = 0; g < p.length; g++) {
      const m = p[g], S = m.getAttribute("rel");
      if (S && S.toLowerCase().indexOf("icon") > -1) {
        const I = m.getAttribute("href");
        if (I)
          if (I.toLowerCase().indexOf("https:") === -1 && I.toLowerCase().indexOf("http:") === -1 && I.indexOf("//") !== 0) {
            let N = t.protocol + "//" + t.host;
            if (I.indexOf("/") === 0)
              N += I;
            else {
              const x = t.pathname.split("/");
              x.pop();
              const C = x.join("/");
              N += C + "/" + I;
            }
            w.push(N);
          } else if (I.indexOf("//") === 0) {
            const N = t.protocol + I;
            w.push(N);
          } else
            w.push(I);
      }
    }
    return w;
  }
  function n(...p) {
    const w = e.getElementsByTagName("meta");
    for (let g = 0; g < w.length; g++) {
      const m = w[g], S = ["itemprop", "property", "name"].map((I) => m.getAttribute(I)).filter((I) => I ? p.includes(I) : !1);
      if (S.length && S) {
        const I = m.getAttribute("content");
        if (I)
          return I;
      }
    }
    return "";
  }
  function a() {
    let p = n("name", "og:site_name", "og:title", "twitter:title");
    return p || (p = e.title), p;
  }
  function i() {
    return n("description", "og:description", "twitter:description", "keywords");
  }
  const c = a(), s = i(), d = t.origin, f = r();
  return {
    description: s,
    url: d,
    icons: f,
    name: c
  };
}
lu = Io.getWindowMetadata = M5;
var Ma = {}, H5 = (e) => encodeURIComponent(e).replace(/[!'()*]/g, (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`), uu = "%[a-f0-9]{2}", Rd = new RegExp("(" + uu + ")|([^%]+?)", "gi"), Ld = new RegExp("(" + uu + ")+", "gi");
function Uc(e, t) {
  try {
    return [decodeURIComponent(e.join(""))];
  } catch {
  }
  if (e.length === 1)
    return e;
  t = t || 1;
  var r = e.slice(0, t), n = e.slice(t);
  return Array.prototype.concat.call([], Uc(r), Uc(n));
}
function z5(e) {
  try {
    return decodeURIComponent(e);
  } catch {
    for (var t = e.match(Rd) || [], r = 1; r < t.length; r++)
      e = Uc(t, r).join(""), t = e.match(Rd) || [];
    return e;
  }
}
function j5(e) {
  for (var t = {
    "%FE%FF": "",
    "%FF%FE": ""
  }, r = Ld.exec(e); r; ) {
    try {
      t[r[0]] = decodeURIComponent(r[0]);
    } catch {
      var n = z5(r[0]);
      n !== r[0] && (t[r[0]] = n);
    }
    r = Ld.exec(e);
  }
  t["%C2"] = "";
  for (var a = Object.keys(t), i = 0; i < a.length; i++) {
    var c = a[i];
    e = e.replace(new RegExp(c, "g"), t[c]);
  }
  return e;
}
var V5 = function(e) {
  if (typeof e != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof e + "`");
  try {
    return e = e.replace(/\+/g, " "), decodeURIComponent(e);
  } catch {
    return j5(e);
  }
}, q5 = (e, t) => {
  if (!(typeof e == "string" && typeof t == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (t === "")
    return [e];
  const r = e.indexOf(t);
  return r === -1 ? [e] : [
    e.slice(0, r),
    e.slice(r + t.length)
  ];
}, K5 = function(e, t) {
  for (var r = {}, n = Object.keys(e), a = Array.isArray(t), i = 0; i < n.length; i++) {
    var c = n[i], s = e[c];
    (a ? t.indexOf(c) !== -1 : t(c, s, e)) && (r[c] = s);
  }
  return r;
};
(function(e) {
  const t = H5, r = V5, n = q5, a = K5, i = (x) => x == null, c = Symbol("encodeFragmentIdentifier");
  function s(x) {
    switch (x.arrayFormat) {
      case "index":
        return (C) => (_, D) => {
          const b = _.length;
          return D === void 0 || x.skipNull && D === null || x.skipEmptyString && D === "" ? _ : D === null ? [..._, [l(C, x), "[", b, "]"].join("")] : [
            ..._,
            [l(C, x), "[", l(b, x), "]=", l(D, x)].join("")
          ];
        };
      case "bracket":
        return (C) => (_, D) => D === void 0 || x.skipNull && D === null || x.skipEmptyString && D === "" ? _ : D === null ? [..._, [l(C, x), "[]"].join("")] : [..._, [l(C, x), "[]=", l(D, x)].join("")];
      case "colon-list-separator":
        return (C) => (_, D) => D === void 0 || x.skipNull && D === null || x.skipEmptyString && D === "" ? _ : D === null ? [..._, [l(C, x), ":list="].join("")] : [..._, [l(C, x), ":list=", l(D, x)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const C = x.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (_) => (D, b) => b === void 0 || x.skipNull && b === null || x.skipEmptyString && b === "" ? D : (b = b === null ? "" : b, D.length === 0 ? [[l(_, x), C, l(b, x)].join("")] : [[D, l(b, x)].join(x.arrayFormatSeparator)]);
      }
      default:
        return (C) => (_, D) => D === void 0 || x.skipNull && D === null || x.skipEmptyString && D === "" ? _ : D === null ? [..._, l(C, x)] : [..._, [l(C, x), "=", l(D, x)].join("")];
    }
  }
  function d(x) {
    let C;
    switch (x.arrayFormat) {
      case "index":
        return (_, D, b) => {
          if (C = /\[(\d*)\]$/.exec(_), _ = _.replace(/\[\d*\]$/, ""), !C) {
            b[_] = D;
            return;
          }
          b[_] === void 0 && (b[_] = {}), b[_][C[1]] = D;
        };
      case "bracket":
        return (_, D, b) => {
          if (C = /(\[\])$/.exec(_), _ = _.replace(/\[\]$/, ""), !C) {
            b[_] = D;
            return;
          }
          if (b[_] === void 0) {
            b[_] = [D];
            return;
          }
          b[_] = [].concat(b[_], D);
        };
      case "colon-list-separator":
        return (_, D, b) => {
          if (C = /(:list)$/.exec(_), _ = _.replace(/:list$/, ""), !C) {
            b[_] = D;
            return;
          }
          if (b[_] === void 0) {
            b[_] = [D];
            return;
          }
          b[_] = [].concat(b[_], D);
        };
      case "comma":
      case "separator":
        return (_, D, b) => {
          const o = typeof D == "string" && D.includes(x.arrayFormatSeparator), h = typeof D == "string" && !o && p(D, x).includes(x.arrayFormatSeparator);
          D = h ? p(D, x) : D;
          const U = o || h ? D.split(x.arrayFormatSeparator).map((E) => p(E, x)) : D === null ? D : p(D, x);
          b[_] = U;
        };
      case "bracket-separator":
        return (_, D, b) => {
          const o = /(\[\])$/.test(_);
          if (_ = _.replace(/\[\]$/, ""), !o) {
            b[_] = D && p(D, x);
            return;
          }
          const h = D === null ? [] : D.split(x.arrayFormatSeparator).map((U) => p(U, x));
          if (b[_] === void 0) {
            b[_] = h;
            return;
          }
          b[_] = [].concat(b[_], h);
        };
      default:
        return (_, D, b) => {
          if (b[_] === void 0) {
            b[_] = D;
            return;
          }
          b[_] = [].concat(b[_], D);
        };
    }
  }
  function f(x) {
    if (typeof x != "string" || x.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function l(x, C) {
    return C.encode ? C.strict ? t(x) : encodeURIComponent(x) : x;
  }
  function p(x, C) {
    return C.decode ? r(x) : x;
  }
  function w(x) {
    return Array.isArray(x) ? x.sort() : typeof x == "object" ? w(Object.keys(x)).sort((C, _) => Number(C) - Number(_)).map((C) => x[C]) : x;
  }
  function g(x) {
    const C = x.indexOf("#");
    return C !== -1 && (x = x.slice(0, C)), x;
  }
  function m(x) {
    let C = "";
    const _ = x.indexOf("#");
    return _ !== -1 && (C = x.slice(_)), C;
  }
  function S(x) {
    x = g(x);
    const C = x.indexOf("?");
    return C === -1 ? "" : x.slice(C + 1);
  }
  function I(x, C) {
    return C.parseNumbers && !Number.isNaN(Number(x)) && typeof x == "string" && x.trim() !== "" ? x = Number(x) : C.parseBooleans && x !== null && (x.toLowerCase() === "true" || x.toLowerCase() === "false") && (x = x.toLowerCase() === "true"), x;
  }
  function N(x, C) {
    C = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, C), f(C.arrayFormatSeparator);
    const _ = d(C), D = /* @__PURE__ */ Object.create(null);
    if (typeof x != "string" || (x = x.trim().replace(/^[?#&]/, ""), !x))
      return D;
    for (const b of x.split("&")) {
      if (b === "")
        continue;
      let [o, h] = n(C.decode ? b.replace(/\+/g, " ") : b, "=");
      h = h === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(C.arrayFormat) ? h : p(h, C), _(p(o, C), h, D);
    }
    for (const b of Object.keys(D)) {
      const o = D[b];
      if (typeof o == "object" && o !== null)
        for (const h of Object.keys(o))
          o[h] = I(o[h], C);
      else
        D[b] = I(o, C);
    }
    return C.sort === !1 ? D : (C.sort === !0 ? Object.keys(D).sort() : Object.keys(D).sort(C.sort)).reduce((b, o) => {
      const h = D[o];
      return h && typeof h == "object" && !Array.isArray(h) ? b[o] = w(h) : b[o] = h, b;
    }, /* @__PURE__ */ Object.create(null));
  }
  e.extract = S, e.parse = N, e.stringify = (x, C) => {
    if (!x)
      return "";
    C = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, C), f(C.arrayFormatSeparator);
    const _ = (h) => C.skipNull && i(x[h]) || C.skipEmptyString && x[h] === "", D = s(C), b = {};
    for (const h of Object.keys(x))
      _(h) || (b[h] = x[h]);
    const o = Object.keys(b);
    return C.sort !== !1 && o.sort(C.sort), o.map((h) => {
      const U = x[h];
      return U === void 0 ? "" : U === null ? l(h, C) : Array.isArray(U) ? U.length === 0 && C.arrayFormat === "bracket-separator" ? l(h, C) + "[]" : U.reduce(D(h), []).join("&") : l(h, C) + "=" + l(U, C);
    }).filter((h) => h.length > 0).join("&");
  }, e.parseUrl = (x, C) => {
    C = Object.assign({
      decode: !0
    }, C);
    const [_, D] = n(x, "#");
    return Object.assign(
      {
        url: _.split("?")[0] || "",
        query: N(S(x), C)
      },
      C && C.parseFragmentIdentifier && D ? { fragmentIdentifier: p(D, C) } : {}
    );
  }, e.stringifyUrl = (x, C) => {
    C = Object.assign({
      encode: !0,
      strict: !0,
      [c]: !0
    }, C);
    const _ = g(x.url).split("?")[0] || "", D = e.extract(x.url), b = e.parse(D, { sort: !1 }), o = Object.assign(b, x.query);
    let h = e.stringify(o, C);
    h && (h = `?${h}`);
    let U = m(x.url);
    return x.fragmentIdentifier && (U = `#${C[c] ? l(x.fragmentIdentifier, C) : x.fragmentIdentifier}`), `${_}${h}${U}`;
  }, e.pick = (x, C, _) => {
    _ = Object.assign({
      parseFragmentIdentifier: !0,
      [c]: !1
    }, _);
    const { url: D, query: b, fragmentIdentifier: o } = e.parseUrl(x, _);
    return e.stringifyUrl({
      url: D,
      query: a(b, C),
      fragmentIdentifier: o
    }, _);
  }, e.exclude = (x, C, _) => {
    const D = Array.isArray(C) ? (b) => !C.includes(b) : (b, o) => !C(b, o);
    return e.pick(x, D, _);
  };
})(Ma);
const G5 = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
}, hu = ":";
function W5(e) {
  const { namespace: t, reference: r } = e;
  return [t, r].join(hu);
}
function Z5(e) {
  const [t, r, n] = e.split(hu);
  return { namespace: t, reference: r, address: n };
}
function Y5(e, t) {
  const r = [];
  return e.forEach((n) => {
    const a = t(n);
    r.includes(a) || r.push(a);
  }), r;
}
function X5(e) {
  const { namespace: t, reference: r } = Z5(e);
  return W5({ namespace: t, reference: r });
}
function J5(e) {
  return Y5(e, X5);
}
function bu(e, t = []) {
  const r = [];
  return Object.keys(e).forEach((n) => {
    if (t.length && !t.includes(n))
      return;
    const a = e[n];
    r.push(...a.accounts);
  }), r;
}
function pu(e, t = []) {
  const r = [];
  return Object.keys(e).forEach((n) => {
    if (t.length && !t.includes(n))
      return;
    const a = e[n];
    r.push(...J5(a.accounts));
  }), r;
}
function Q5(e, t = []) {
  const r = [];
  return Object.keys(e).forEach((n) => {
    if (t.length && !t.includes(n))
      return;
    const a = e[n];
    r.push(...Co(n, a));
  }), r;
}
function Co(e, t) {
  return e.includes(":") ? [e] : t.chains || [];
}
const gu = "base10", Ct = "base16", Fc = "base64pad", To = "utf8", _u = 0, Cn = 1, e8 = 0, Pd = 1, $c = 12, Oo = 32;
function t8() {
  const e = Do.generateKeyPair();
  return { privateKey: Tt(e.secretKey, Ct), publicKey: Tt(e.publicKey, Ct) };
}
function Bc() {
  const e = ra.randomBytes(Oo);
  return Tt(e, Ct);
}
function r8(e, t) {
  const r = Do.sharedKey(Rt(e, Ct), Rt(t, Ct)), n = new _5(gs.SHA256, r).expand(Oo);
  return Tt(n, Ct);
}
function n8(e) {
  const t = gs.hash(Rt(e, Ct));
  return Tt(t, Ct);
}
function Vn(e) {
  const t = gs.hash(Rt(e, To));
  return Tt(t, Ct);
}
function a8(e) {
  return Rt(`${e}`, gu);
}
function ai(e) {
  return Number(Tt(e, gu));
}
function i8(e) {
  const t = a8(typeof e.type < "u" ? e.type : _u);
  if (ai(t) === Cn && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const r = typeof e.senderPublicKey < "u" ? Rt(e.senderPublicKey, Ct) : void 0, n = typeof e.iv < "u" ? Rt(e.iv, Ct) : ra.randomBytes($c), a = new xo.ChaCha20Poly1305(Rt(e.symKey, Ct)).seal(n, Rt(e.message, To));
  return c8({ type: t, sealed: a, iv: n, senderPublicKey: r });
}
function s8(e) {
  const t = new xo.ChaCha20Poly1305(Rt(e.symKey, Ct)), { sealed: r, iv: n } = Zi(e.encoded), a = t.open(n, r);
  if (a === null)
    throw new Error("Failed to decrypt");
  return Tt(a, To);
}
function c8(e) {
  if (ai(e.type) === Cn) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return Tt(Pc([e.type, e.senderPublicKey, e.iv, e.sealed]), Fc);
  }
  return Tt(Pc([e.type, e.iv, e.sealed]), Fc);
}
function Zi(e) {
  const t = Rt(e, Fc), r = t.slice(e8, Pd), n = Pd;
  if (ai(r) === Cn) {
    const s = n + Oo, d = s + $c, f = t.slice(n, s), l = t.slice(s, d), p = t.slice(d);
    return { type: r, sealed: p, iv: l, senderPublicKey: f };
  }
  const a = n + $c, i = t.slice(n, a), c = t.slice(a);
  return { type: r, sealed: c, iv: i };
}
function o8(e, t) {
  const r = Zi(e);
  return yu({ type: ai(r.type), senderPublicKey: typeof r.senderPublicKey < "u" ? Tt(r.senderPublicKey, Ct) : void 0, receiverPublicKey: t?.receiverPublicKey });
}
function yu(e) {
  const t = e?.type || _u;
  if (t === Cn) {
    if (typeof e?.senderPublicKey > "u")
      throw new Error("missing sender public key");
    if (typeof e?.receiverPublicKey > "u")
      throw new Error("missing receiver public key");
  }
  return { type: t, senderPublicKey: e?.senderPublicKey, receiverPublicKey: e?.receiverPublicKey };
}
function kd(e) {
  return e.type === Cn && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
var f8 = Object.defineProperty, Ud = Object.getOwnPropertySymbols, d8 = Object.prototype.hasOwnProperty, l8 = Object.prototype.propertyIsEnumerable, Fd = (e, t, r) => t in e ? f8(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, $d = (e, t) => {
  for (var r in t || (t = {}))
    d8.call(t, r) && Fd(e, r, t[r]);
  if (Ud)
    for (var r of Ud(t))
      l8.call(t, r) && Fd(e, r, t[r]);
  return e;
};
const u8 = "ReactNative", bn = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, h8 = "js";
function No() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function wu() {
  return !fu() && !!Ao() && navigator.product === u8;
}
function Ro() {
  return !No() && !!Ao();
}
function mu() {
  return wu() ? bn.reactNative : No() ? bn.node : Ro() ? bn.browser : bn.unknown;
}
function b8(e, t) {
  let r = Ma.parse(e);
  return r = $d($d({}, r), t), e = Ma.stringify(r), e;
}
function p8() {
  return lu() || { name: "", description: "", url: "", icons: [""] };
}
function g8() {
  const e = ou();
  if (e === null)
    return "unknown";
  const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [t, e.name, e.version].join("-") : [t, e.version].join("-");
}
function _8() {
  var e;
  const t = mu();
  return t === bn.browser ? [t, ((e = du()) == null ? void 0 : e.host) || "unknown"].join(":") : t;
}
function y8(e, t, r) {
  const n = g8(), a = _8();
  return [[e, t].join("-"), [h8, r].join("-"), n, a].join("/");
}
function w8({ protocol: e, version: t, relayUrl: r, sdkVersion: n, auth: a, projectId: i, useOnCloseEvent: c }) {
  const s = r.split("?"), d = y8(e, t, n), f = { auth: a, ua: d, projectId: i, useOnCloseEvent: c || void 0 }, l = b8(s[1] || "", f);
  return s[0] + "?" + l;
}
function pn(e, t) {
  return e.filter((r) => t.includes(r)).length === e.length;
}
function Eu(e) {
  return Object.fromEntries(e.entries());
}
function vu(e) {
  return new Map(Object.entries(e));
}
function Fn(e = re.FIVE_MINUTES, t) {
  const r = re.toMiliseconds(e || re.FIVE_MINUTES);
  let n, a, i;
  return { resolve: (c) => {
    i && n && (clearTimeout(i), n(c));
  }, reject: (c) => {
    i && a && (clearTimeout(i), a(c));
  }, done: () => new Promise((c, s) => {
    i = setTimeout(() => {
      s(new Error(t));
    }, r), n = c, a = s;
  }) };
}
function Yi(e, t, r) {
  return new Promise(async (n, a) => {
    const i = setTimeout(() => a(new Error(r)), t);
    try {
      const c = await e;
      n(c);
    } catch (c) {
      a(c);
    }
    clearTimeout(i);
  });
}
function xu(e, t) {
  if (typeof t == "string" && t.startsWith(`${e}:`))
    return t;
  if (e.toLowerCase() === "topic") {
    if (typeof t != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof t != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function m8(e) {
  return xu("topic", e);
}
function E8(e) {
  return xu("id", e);
}
function Su(e) {
  const [t, r] = e.split(":"), n = { id: void 0, topic: void 0 };
  if (t === "topic" && typeof r == "string")
    n.topic = r;
  else if (t === "id" && Number.isInteger(Number(r)))
    n.id = Number(r);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${r}`);
  return n;
}
function fr(e, t) {
  return re.fromMiliseconds((t || Date.now()) + re.toMiliseconds(e));
}
function $r(e) {
  return Date.now() >= re.toMiliseconds(e);
}
function Ze(e, t) {
  return `${e}${t ? `:${t}` : ""}`;
}
async function v8({ id: e, topic: t, wcDeepLink: r }) {
  try {
    if (!r)
      return;
    let a = (typeof r == "string" ? JSON.parse(r) : r)?.href;
    if (typeof a != "string")
      return;
    a.endsWith("/") && (a = a.slice(0, -1));
    const i = `${a}/wc?requestId=${e}&sessionTopic=${t}`, c = mu();
    c === bn.browser ? window.open(i, "_self", "noreferrer noopener") : c === bn.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i);
  } catch (n) {
    console.error(n);
  }
}
const x8 = "irn";
function Mc(e) {
  return e?.relay || { protocol: x8 };
}
function Mi(e) {
  const t = G5[e];
  if (typeof t > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return t;
}
var S8 = Object.defineProperty, Bd = Object.getOwnPropertySymbols, D8 = Object.prototype.hasOwnProperty, A8 = Object.prototype.propertyIsEnumerable, Md = (e, t, r) => t in e ? S8(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, I8 = (e, t) => {
  for (var r in t || (t = {}))
    D8.call(t, r) && Md(e, r, t[r]);
  if (Bd)
    for (var r of Bd(t))
      A8.call(t, r) && Md(e, r, t[r]);
  return e;
};
function C8(e, t = "-") {
  const r = {}, n = "relay" + t;
  return Object.keys(e).forEach((a) => {
    if (a.startsWith(n)) {
      const i = a.replace(n, ""), c = e[a];
      r[i] = c;
    }
  }), r;
}
function T8(e) {
  const t = e.indexOf(":"), r = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, n = e.substring(0, t), a = e.substring(t + 1, r).split("@"), i = typeof r < "u" ? e.substring(r) : "", c = Ma.parse(i);
  return { protocol: n, topic: O8(a[0]), version: parseInt(a[1], 10), symKey: c.symKey, relay: C8(c) };
}
function O8(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function N8(e, t = "-") {
  const r = "relay", n = {};
  return Object.keys(e).forEach((a) => {
    const i = r + t + a;
    e[a] && (n[i] = e[a]);
  }), n;
}
function R8(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + Ma.stringify(I8({ symKey: e.symKey }, N8(e.relay)));
}
function aa(e) {
  const t = [];
  return e.forEach((r) => {
    const [n, a] = r.split(":");
    t.push(`${n}:${a}`);
  }), t;
}
function L8(e) {
  const t = [];
  return Object.values(e).forEach((r) => {
    t.push(...aa(r.accounts));
  }), t;
}
function P8(e, t) {
  const r = [];
  return Object.values(e).forEach((n) => {
    aa(n.accounts).includes(t) && r.push(...n.methods);
  }), r;
}
function k8(e, t) {
  const r = [];
  return Object.values(e).forEach((n) => {
    aa(n.accounts).includes(t) && r.push(...n.events);
  }), r;
}
function U8(e, t) {
  const r = Hi(e, t);
  if (r)
    throw new Error(r.message);
  const n = {};
  for (const [a, i] of Object.entries(e))
    n[a] = { methods: i.methods, events: i.events, chains: i.accounts.map((c) => `${c.split(":")[0]}:${c.split(":")[1]}`) };
  return n;
}
const F8 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, $8 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function X(e, t) {
  const { message: r, code: n } = $8[e];
  return { message: t ? `${r} ${t}` : r, code: n };
}
function Qe(e, t) {
  const { message: r, code: n } = F8[e];
  return { message: t ? `${r} ${t}` : r, code: n };
}
function ii(e, t) {
  return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : !0 : !1;
}
function La(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function At(e) {
  return typeof e > "u";
}
function lt(e, t) {
  return t && At(e) ? !0 : typeof e == "string" && !!e.trim().length;
}
function Lo(e, t) {
  return t && At(e) ? !0 : typeof e == "number" && !isNaN(e);
}
function B8(e, t) {
  const { requiredNamespaces: r } = t, n = Object.keys(e.namespaces), a = Object.keys(r);
  let i = !0;
  return pn(a, n) ? (n.forEach((c) => {
    const { accounts: s, methods: d, events: f } = e.namespaces[c], l = aa(s), p = r[c];
    (!pn(Co(c, p), l) || !pn(p.methods, d) || !pn(p.events, f)) && (i = !1);
  }), i) : !1;
}
function Po(e) {
  return lt(e, !1) && e.includes(":") ? e.split(":").length === 2 : !1;
}
function M8(e) {
  if (lt(e, !1) && e.includes(":")) {
    const t = e.split(":");
    if (t.length === 3) {
      const r = t[0] + ":" + t[1];
      return !!t[2] && Po(r);
    }
  }
  return !1;
}
function H8(e) {
  if (lt(e, !1))
    try {
      return typeof new URL(e) < "u";
    } catch {
      return !1;
    }
  return !1;
}
function z8(e) {
  var t;
  return (t = e?.proposer) == null ? void 0 : t.publicKey;
}
function j8(e) {
  return e?.topic;
}
function V8(e, t) {
  let r = null;
  return lt(e?.publicKey, !1) || (r = X("MISSING_OR_INVALID", `${t} controller public key should be a string`)), r;
}
function Hd(e) {
  let t = !0;
  return ii(e) ? e.length && (t = e.every((r) => lt(r, !1))) : t = !1, t;
}
function q8(e, t, r) {
  let n = null;
  return ii(t) ? t.forEach((a) => {
    n || (!Po(a) || !a.includes(e)) && (n = Qe("UNSUPPORTED_CHAINS", `${r}, chain ${a} should be a string and conform to "namespace:chainId" format`));
  }) : n = Qe("UNSUPPORTED_CHAINS", `${r}, chains ${t} should be an array of strings conforming to "namespace:chainId" format`), n;
}
function K8(e, t) {
  let r = null;
  return Object.entries(e).forEach(([n, a]) => {
    if (r)
      return;
    const i = q8(n, Co(n, a), `${t} requiredNamespace`);
    i && (r = i);
  }), r;
}
function G8(e, t) {
  let r = null;
  return ii(e) ? e.forEach((n) => {
    r || M8(n) || (r = Qe("UNSUPPORTED_ACCOUNTS", `${t}, account ${n} should be a string and conform to "namespace:chainId:address" format`));
  }) : r = Qe("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r;
}
function W8(e, t) {
  let r = null;
  return Object.values(e).forEach((n) => {
    if (r)
      return;
    const a = G8(n?.accounts, `${t} namespace`);
    a && (r = a);
  }), r;
}
function Z8(e, t) {
  let r = null;
  return Hd(e?.methods) ? Hd(e?.events) || (r = Qe("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : r = Qe("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), r;
}
function Du(e, t) {
  let r = null;
  return Object.values(e).forEach((n) => {
    if (r)
      return;
    const a = Z8(n, `${t}, namespace`);
    a && (r = a);
  }), r;
}
function Y8(e, t, r) {
  let n = null;
  if (e && La(e)) {
    const a = Du(e, t);
    a && (n = a);
    const i = K8(e, t);
    i && (n = i);
  } else
    n = X("MISSING_OR_INVALID", `${t}, ${r} should be an object with data`);
  return n;
}
function Hi(e, t) {
  let r = null;
  if (e && La(e)) {
    const n = Du(e, t);
    n && (r = n);
    const a = W8(e, t);
    a && (r = a);
  } else
    r = X("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
  return r;
}
function Au(e) {
  return lt(e.protocol, !0);
}
function X8(e, t) {
  let r = !1;
  return t && !e ? r = !0 : e && ii(e) && e.length && e.forEach((n) => {
    r = Au(n);
  }), r;
}
function J8(e) {
  return typeof e == "number";
}
function Ot(e) {
  return typeof e < "u" && typeof e !== null;
}
function Q8(e) {
  return !(!e || typeof e != "object" || !e.code || !Lo(e.code, !1) || !e.message || !lt(e.message, !1));
}
function e4(e) {
  return !(At(e) || !lt(e.method, !1));
}
function t4(e) {
  return !(At(e) || At(e.result) && At(e.error) || !Lo(e.id, !1) || !lt(e.jsonrpc, !1));
}
function r4(e) {
  return !(At(e) || !lt(e.name, !1));
}
function zd(e, t) {
  return !(!Po(t) || !L8(e).includes(t));
}
function n4(e, t, r) {
  return lt(r, !1) ? P8(e, t).includes(r) : !1;
}
function a4(e, t, r) {
  return lt(r, !1) ? k8(e, t).includes(r) : !1;
}
function jd(e, t, r) {
  let n = null;
  const a = i4(e), i = s4(t), c = Object.keys(a), s = Object.keys(i), d = Vd(Object.keys(e)), f = Vd(Object.keys(t)), l = d.filter((p) => !f.includes(p));
  return l.length && (n = X("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l.toString()}
      Received: ${Object.keys(t).toString()}`)), pn(c, s) || (n = X("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${c.toString()}
      Approved: ${s.toString()}`)), Object.keys(t).forEach((p) => {
    if (!p.includes(":") || n)
      return;
    const w = aa(t[p].accounts);
    w.includes(p) || (n = X("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${p}
        Required: ${p}
        Approved: ${w.toString()}`));
  }), c.forEach((p) => {
    n || (pn(a[p].methods, i[p].methods) ? pn(a[p].events, i[p].events) || (n = X("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${p}`)) : n = X("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${p}`));
  }), n;
}
function i4(e) {
  const t = {};
  return Object.keys(e).forEach((r) => {
    var n;
    r.includes(":") ? t[r] = e[r] : (n = e[r].chains) == null || n.forEach((a) => {
      t[a] = { methods: e[r].methods, events: e[r].events };
    });
  }), t;
}
function Vd(e) {
  return [...new Set(e.map((t) => t.includes(":") ? t.split(":")[0] : t))];
}
function s4(e) {
  const t = {};
  return Object.keys(e).forEach((r) => {
    r.includes(":") ? t[r] = e[r] : aa(e[r].accounts)?.forEach((a) => {
      t[a] = { accounts: e[r].accounts.filter((i) => i.includes(`${a}:`)), methods: e[r].methods, events: e[r].events };
    });
  }), t;
}
function c4(e, t) {
  return Lo(e, !1) && e <= t.max && e >= t.min;
}
const o4 = "PARSE_ERROR", f4 = "INVALID_REQUEST", d4 = "METHOD_NOT_FOUND", l4 = "INVALID_PARAMS", Iu = "INTERNAL_ERROR", ko = "SERVER_ERROR", u4 = [-32700, -32600, -32601, -32602, -32603], Pa = {
  [o4]: { code: -32700, message: "Parse error" },
  [f4]: { code: -32600, message: "Invalid Request" },
  [d4]: { code: -32601, message: "Method not found" },
  [l4]: { code: -32602, message: "Invalid params" },
  [Iu]: { code: -32603, message: "Internal error" },
  [ko]: { code: -32e3, message: "Server error" }
}, Cu = ko;
function h4(e) {
  return u4.includes(e);
}
function qd(e) {
  return Object.keys(Pa).includes(e) ? Pa[e] : Pa[Cu];
}
function b4(e) {
  const t = Object.values(Pa).find((r) => r.code === e);
  return t || Pa[Cu];
}
function p4(e, t, r) {
  return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r} RPC url at ${t}`) : e;
}
var Tu = {}, Er = {}, Kd;
function g4() {
  if (Kd)
    return Er;
  Kd = 1, Object.defineProperty(Er, "__esModule", { value: !0 }), Er.isBrowserCryptoAvailable = Er.getSubtleCrypto = Er.getBrowerCrypto = void 0;
  function e() {
    return Et?.crypto || Et?.msCrypto || {};
  }
  Er.getBrowerCrypto = e;
  function t() {
    const n = e();
    return n.subtle || n.webkitSubtle;
  }
  Er.getSubtleCrypto = t;
  function r() {
    return !!e() && !!t();
  }
  return Er.isBrowserCryptoAvailable = r, Er;
}
var vr = {}, Gd;
function _4() {
  if (Gd)
    return vr;
  Gd = 1, Object.defineProperty(vr, "__esModule", { value: !0 }), vr.isBrowser = vr.isNode = vr.isReactNative = void 0;
  function e() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  vr.isReactNative = e;
  function t() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  vr.isNode = t;
  function r() {
    return !e() && !t();
  }
  return vr.isBrowser = r, vr;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  const t = Xt;
  t.__exportStar(g4(), e), t.__exportStar(_4(), e);
})(Tu);
function Ou(e = 3) {
  const t = Date.now() * Math.pow(10, e), r = Math.floor(Math.random() * Math.pow(10, e));
  return t + r;
}
function Uo(e = 6) {
  return BigInt(Ou(e));
}
function _s(e, t, r) {
  return {
    id: r || Ou(),
    jsonrpc: "2.0",
    method: e,
    params: t
  };
}
function ys(e, t) {
  return {
    id: e,
    jsonrpc: "2.0",
    result: t
  };
}
function ws(e, t, r) {
  return {
    id: e,
    jsonrpc: "2.0",
    error: y4(t, r)
  };
}
function y4(e, t) {
  return typeof e > "u" ? qd(Iu) : (typeof e == "string" && (e = Object.assign(Object.assign({}, qd(ko)), { message: e })), typeof t < "u" && (e.data = t), h4(e.code) && (e = b4(e.code)), e);
}
class Nu {
}
class w4 extends Nu {
  constructor(t) {
    super();
  }
}
class m4 extends Nu {
  constructor() {
    super();
  }
}
class E4 extends m4 {
  constructor(t) {
    super();
  }
}
const v4 = "^wss?:";
function x4(e) {
  const t = e.match(new RegExp(/^\w+:/, "gi"));
  if (!(!t || !t.length))
    return t[0];
}
function S4(e, t) {
  const r = x4(e);
  return typeof r > "u" ? !1 : new RegExp(t).test(r);
}
function Wd(e) {
  return S4(e, v4);
}
function D4(e) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(e);
}
function Ru(e) {
  return typeof e == "object" && "id" in e && "jsonrpc" in e && e.jsonrpc === "2.0";
}
function Fo(e) {
  return Ru(e) && "method" in e;
}
function ms(e) {
  return Ru(e) && (Dr(e) || er(e));
}
function Dr(e) {
  return "result" in e;
}
function er(e) {
  return "error" in e;
}
class Lu extends E4 {
  constructor(t) {
    super(t), this.events = new zt.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, r) {
    this.events.on(t, r);
  }
  once(t, r) {
    this.events.once(t, r);
  }
  off(t, r) {
    this.events.off(t, r);
  }
  removeListener(t, r) {
    this.events.removeListener(t, r);
  }
  async request(t, r) {
    return this.requestStrict(_s(t.method, t.params || [], t.id || Uo().toString()), r);
  }
  async requestStrict(t, r) {
    return new Promise(async (n, a) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (i) {
          a(i);
        }
      this.events.on(`${t.id}`, (i) => {
        er(i) ? a(i.error) : n(i.result);
      });
      try {
        await this.connection.send(t, r);
      } catch (i) {
        a(i);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), ms(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", {
      type: t.method,
      data: t.params
    });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
}
const Zd = 10, A4 = () => typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : require("ws"), I4 = () => typeof window < "u", C4 = A4();
class T4 {
  constructor(t) {
    if (this.url = t, this.events = new zt.EventEmitter(), this.registering = !1, !Wd(t))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    this.url = t;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(t, r) {
    this.events.on(t, r);
  }
  once(t, r) {
    this.events.once(t, r);
  }
  off(t, r) {
    this.events.off(t, r);
  }
  removeListener(t, r) {
    this.events.removeListener(t, r);
  }
  async open(t = this.url) {
    await this.register(t);
  }
  async close() {
    return new Promise((t, r) => {
      if (typeof this.socket > "u") {
        r(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n) => {
        this.onClose(n), t();
      }, this.socket.close();
    });
  }
  async send(t, r) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(mo(t));
    } catch (n) {
      this.onError(t.id, n);
    }
  }
  register(t = this.url) {
    if (!Wd(t))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, a) => {
        this.events.once("register_error", (i) => {
          this.resetMaxListeners(), a(i);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return a(new Error("WebSocket connection is missing or invalid"));
          n(this.socket);
        });
      });
    }
    return this.url = t, this.registering = !0, new Promise((r, n) => {
      const a = Tu.isReactNative() ? void 0 : { rejectUnauthorized: !D4(t) }, i = new C4(t, [], a);
      I4() ? i.onerror = (c) => {
        const s = c;
        n(this.emitError(s.error));
      } : i.on("error", (c) => {
        n(this.emitError(c));
      }), i.onopen = () => {
        this.onOpen(i), r(i);
      };
    });
  }
  onOpen(t) {
    t.onmessage = (r) => this.onPayload(r), t.onclose = (r) => this.onClose(r), this.socket = t, this.registering = !1, this.events.emit("open");
  }
  onClose(t) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", t);
  }
  onPayload(t) {
    if (typeof t.data > "u")
      return;
    const r = typeof t.data == "string" ? Hl(t.data) : t.data;
    this.events.emit("payload", r);
  }
  onError(t, r) {
    const n = this.parseError(r), a = n.message || n.toString(), i = ws(t, a);
    this.events.emit("payload", i);
  }
  parseError(t, r = this.url) {
    return p4(t, r, "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > Zd && this.events.setMaxListeners(Zd);
  }
  emitError(t) {
    const r = this.parseError(new Error(t?.message || `WebSocket connection failed for URL: ${this.url}`));
    return this.events.emit("register_error", r), r;
  }
}
var Xi = { exports: {} };
Xi.exports;
(function(e, t) {
  var r = 200, n = "__lodash_hash_undefined__", a = 1, i = 2, c = 9007199254740991, s = "[object Arguments]", d = "[object Array]", f = "[object AsyncFunction]", l = "[object Boolean]", p = "[object Date]", w = "[object Error]", g = "[object Function]", m = "[object GeneratorFunction]", S = "[object Map]", I = "[object Number]", N = "[object Null]", x = "[object Object]", C = "[object Promise]", _ = "[object Proxy]", D = "[object RegExp]", b = "[object Set]", o = "[object String]", h = "[object Symbol]", U = "[object Undefined]", E = "[object WeakMap]", T = "[object ArrayBuffer]", P = "[object DataView]", z = "[object Float32Array]", v = "[object Float64Array]", y = "[object Int8Array]", L = "[object Int16Array]", M = "[object Int32Array]", H = "[object Uint8Array]", F = "[object Uint8ClampedArray]", j = "[object Uint16Array]", V = "[object Uint32Array]", W = /[\\^$.*+?()[\]{}|]/g, K = /^\[object .+?Constructor\]$/, Q = /^(?:0|[1-9]\d*)$/, Z = {};
  Z[z] = Z[v] = Z[y] = Z[L] = Z[M] = Z[H] = Z[F] = Z[j] = Z[V] = !0, Z[s] = Z[d] = Z[T] = Z[l] = Z[P] = Z[p] = Z[w] = Z[g] = Z[S] = Z[I] = Z[x] = Z[D] = Z[b] = Z[o] = Z[E] = !1;
  var te = typeof Et == "object" && Et && Et.Object === Object && Et, $ = typeof self == "object" && self && self.Object === Object && self, B = te || $ || Function("return this")(), R = t && !t.nodeType && t, u = R && !0 && e && !e.nodeType && e, O = u && u.exports === R, G = O && te.process, Y = function() {
    try {
      return G && G.binding && G.binding("util");
    } catch {
    }
  }(), ce = Y && Y.isTypedArray;
  function pe(A, k) {
    for (var q = -1, J = A == null ? 0 : A.length, Le = 0, oe = []; ++q < J; ) {
      var Me = A[q];
      k(Me, q, A) && (oe[Le++] = Me);
    }
    return oe;
  }
  function le(A, k) {
    for (var q = -1, J = k.length, Le = A.length; ++q < J; )
      A[Le + q] = k[q];
    return A;
  }
  function De(A, k) {
    for (var q = -1, J = A == null ? 0 : A.length; ++q < J; )
      if (k(A[q], q, A))
        return !0;
    return !1;
  }
  function ze(A, k) {
    for (var q = -1, J = Array(A); ++q < A; )
      J[q] = k(q);
    return J;
  }
  function Fe(A) {
    return function(k) {
      return A(k);
    };
  }
  function me(A, k) {
    return A.has(k);
  }
  function _e(A, k) {
    return A?.[k];
  }
  function ge(A) {
    var k = -1, q = Array(A.size);
    return A.forEach(function(J, Le) {
      q[++k] = [Le, J];
    }), q;
  }
  function he(A, k) {
    return function(q) {
      return A(k(q));
    };
  }
  function ue(A) {
    var k = -1, q = Array(A.size);
    return A.forEach(function(J) {
      q[++k] = J;
    }), q;
  }
  var de = Array.prototype, fe = Function.prototype, ae = Object.prototype, be = B["__core-js_shared__"], ye = fe.toString, ie = ae.hasOwnProperty, ve = function() {
    var A = /[^.]+$/.exec(be && be.keys && be.keys.IE_PROTO || "");
    return A ? "Symbol(src)_1." + A : "";
  }(), Se = ae.toString, Ce = RegExp(
    "^" + ye.call(ie).replace(W, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Te = O ? B.Buffer : void 0, Ae = B.Symbol, Jt = B.Uint8Array, nr = ae.propertyIsEnumerable, Rr = de.splice, Ut = Ae ? Ae.toStringTag : void 0, tn = Object.getOwnPropertySymbols, ua = Te ? Te.isBuffer : void 0, mi = he(Object.keys, Object), Ve = Nn(B, "DataView"), $e = Nn(B, "Map"), qe = Nn(B, "Promise"), Ke = Nn(B, "Set"), Ge = Nn(B, "WeakMap"), Be = Nn(Object, "create"), tt = nn(Ve), rt = nn($e), nt = nn(qe), at = nn(Ke), it = nn(Ge), Xe = Ae ? Ae.prototype : void 0, We = Xe ? Xe.valueOf : void 0;
  function Pe(A) {
    var k = -1, q = A == null ? 0 : A.length;
    for (this.clear(); ++k < q; ) {
      var J = A[k];
      this.set(J[0], J[1]);
    }
  }
  function st() {
    this.__data__ = Be ? Be(null) : {}, this.size = 0;
  }
  function ct(A) {
    var k = this.has(A) && delete this.__data__[A];
    return this.size -= k ? 1 : 0, k;
  }
  function Bb(A) {
    var k = this.__data__;
    if (Be) {
      var q = k[A];
      return q === n ? void 0 : q;
    }
    return ie.call(k, A) ? k[A] : void 0;
  }
  function Mb(A) {
    var k = this.__data__;
    return Be ? k[A] !== void 0 : ie.call(k, A);
  }
  function Hb(A, k) {
    var q = this.__data__;
    return this.size += this.has(A) ? 0 : 1, q[A] = Be && k === void 0 ? n : k, this;
  }
  Pe.prototype.clear = st, Pe.prototype.delete = ct, Pe.prototype.get = Bb, Pe.prototype.has = Mb, Pe.prototype.set = Hb;
  function wr(A) {
    var k = -1, q = A == null ? 0 : A.length;
    for (this.clear(); ++k < q; ) {
      var J = A[k];
      this.set(J[0], J[1]);
    }
  }
  function zb() {
    this.__data__ = [], this.size = 0;
  }
  function jb(A) {
    var k = this.__data__, q = vi(k, A);
    if (q < 0)
      return !1;
    var J = k.length - 1;
    return q == J ? k.pop() : Rr.call(k, q, 1), --this.size, !0;
  }
  function Vb(A) {
    var k = this.__data__, q = vi(k, A);
    return q < 0 ? void 0 : k[q][1];
  }
  function qb(A) {
    return vi(this.__data__, A) > -1;
  }
  function Kb(A, k) {
    var q = this.__data__, J = vi(q, A);
    return J < 0 ? (++this.size, q.push([A, k])) : q[J][1] = k, this;
  }
  wr.prototype.clear = zb, wr.prototype.delete = jb, wr.prototype.get = Vb, wr.prototype.has = qb, wr.prototype.set = Kb;
  function rn(A) {
    var k = -1, q = A == null ? 0 : A.length;
    for (this.clear(); ++k < q; ) {
      var J = A[k];
      this.set(J[0], J[1]);
    }
  }
  function Gb() {
    this.size = 0, this.__data__ = {
      hash: new Pe(),
      map: new ($e || wr)(),
      string: new Pe()
    };
  }
  function Wb(A) {
    var k = xi(this, A).delete(A);
    return this.size -= k ? 1 : 0, k;
  }
  function Zb(A) {
    return xi(this, A).get(A);
  }
  function Yb(A) {
    return xi(this, A).has(A);
  }
  function Xb(A, k) {
    var q = xi(this, A), J = q.size;
    return q.set(A, k), this.size += q.size == J ? 0 : 1, this;
  }
  rn.prototype.clear = Gb, rn.prototype.delete = Wb, rn.prototype.get = Zb, rn.prototype.has = Yb, rn.prototype.set = Xb;
  function Ei(A) {
    var k = -1, q = A == null ? 0 : A.length;
    for (this.__data__ = new rn(); ++k < q; )
      this.add(A[k]);
  }
  function Jb(A) {
    return this.__data__.set(A, n), this;
  }
  function Qb(A) {
    return this.__data__.has(A);
  }
  Ei.prototype.add = Ei.prototype.push = Jb, Ei.prototype.has = Qb;
  function Lr(A) {
    var k = this.__data__ = new wr(A);
    this.size = k.size;
  }
  function e2() {
    this.__data__ = new wr(), this.size = 0;
  }
  function t2(A) {
    var k = this.__data__, q = k.delete(A);
    return this.size = k.size, q;
  }
  function r2(A) {
    return this.__data__.get(A);
  }
  function n2(A) {
    return this.__data__.has(A);
  }
  function a2(A, k) {
    var q = this.__data__;
    if (q instanceof wr) {
      var J = q.__data__;
      if (!$e || J.length < r - 1)
        return J.push([A, k]), this.size = ++q.size, this;
      q = this.__data__ = new rn(J);
    }
    return q.set(A, k), this.size = q.size, this;
  }
  Lr.prototype.clear = e2, Lr.prototype.delete = t2, Lr.prototype.get = r2, Lr.prototype.has = n2, Lr.prototype.set = a2;
  function i2(A, k) {
    var q = Si(A), J = !q && m2(A), Le = !q && !J && Ms(A), oe = !q && !J && !Le && Gf(A), Me = q || J || Le || oe, ot = Me ? ze(A.length, String) : [], ht = ot.length;
    for (var Ue in A)
      (k || ie.call(A, Ue)) && !(Me && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Ue == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Le && (Ue == "offset" || Ue == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      oe && (Ue == "buffer" || Ue == "byteLength" || Ue == "byteOffset") || // Skip index properties.
      p2(Ue, ht))) && ot.push(Ue);
    return ot;
  }
  function vi(A, k) {
    for (var q = A.length; q--; )
      if (jf(A[q][0], k))
        return q;
    return -1;
  }
  function s2(A, k, q) {
    var J = k(A);
    return Si(A) ? J : le(J, q(A));
  }
  function ha(A) {
    return A == null ? A === void 0 ? U : N : Ut && Ut in Object(A) ? h2(A) : w2(A);
  }
  function Bf(A) {
    return ba(A) && ha(A) == s;
  }
  function Mf(A, k, q, J, Le) {
    return A === k ? !0 : A == null || k == null || !ba(A) && !ba(k) ? A !== A && k !== k : c2(A, k, q, J, Mf, Le);
  }
  function c2(A, k, q, J, Le, oe) {
    var Me = Si(A), ot = Si(k), ht = Me ? d : Pr(A), Ue = ot ? d : Pr(k);
    ht = ht == s ? x : ht, Ue = Ue == s ? x : Ue;
    var Ft = ht == x, Qt = Ue == x, yt = ht == Ue;
    if (yt && Ms(A)) {
      if (!Ms(k))
        return !1;
      Me = !0, Ft = !1;
    }
    if (yt && !Ft)
      return oe || (oe = new Lr()), Me || Gf(A) ? Hf(A, k, q, J, Le, oe) : l2(A, k, ht, q, J, Le, oe);
    if (!(q & a)) {
      var Vt = Ft && ie.call(A, "__wrapped__"), qt = Qt && ie.call(k, "__wrapped__");
      if (Vt || qt) {
        var kr = Vt ? A.value() : A, mr = qt ? k.value() : k;
        return oe || (oe = new Lr()), Le(kr, mr, q, J, oe);
      }
    }
    return yt ? (oe || (oe = new Lr()), u2(A, k, q, J, Le, oe)) : !1;
  }
  function o2(A) {
    if (!Kf(A) || _2(A))
      return !1;
    var k = Vf(A) ? Ce : K;
    return k.test(nn(A));
  }
  function f2(A) {
    return ba(A) && qf(A.length) && !!Z[ha(A)];
  }
  function d2(A) {
    if (!y2(A))
      return mi(A);
    var k = [];
    for (var q in Object(A))
      ie.call(A, q) && q != "constructor" && k.push(q);
    return k;
  }
  function Hf(A, k, q, J, Le, oe) {
    var Me = q & a, ot = A.length, ht = k.length;
    if (ot != ht && !(Me && ht > ot))
      return !1;
    var Ue = oe.get(A);
    if (Ue && oe.get(k))
      return Ue == k;
    var Ft = -1, Qt = !0, yt = q & i ? new Ei() : void 0;
    for (oe.set(A, k), oe.set(k, A); ++Ft < ot; ) {
      var Vt = A[Ft], qt = k[Ft];
      if (J)
        var kr = Me ? J(qt, Vt, Ft, k, A, oe) : J(Vt, qt, Ft, A, k, oe);
      if (kr !== void 0) {
        if (kr)
          continue;
        Qt = !1;
        break;
      }
      if (yt) {
        if (!De(k, function(mr, an) {
          if (!me(yt, an) && (Vt === mr || Le(Vt, mr, q, J, oe)))
            return yt.push(an);
        })) {
          Qt = !1;
          break;
        }
      } else if (!(Vt === qt || Le(Vt, qt, q, J, oe))) {
        Qt = !1;
        break;
      }
    }
    return oe.delete(A), oe.delete(k), Qt;
  }
  function l2(A, k, q, J, Le, oe, Me) {
    switch (q) {
      case P:
        if (A.byteLength != k.byteLength || A.byteOffset != k.byteOffset)
          return !1;
        A = A.buffer, k = k.buffer;
      case T:
        return !(A.byteLength != k.byteLength || !oe(new Jt(A), new Jt(k)));
      case l:
      case p:
      case I:
        return jf(+A, +k);
      case w:
        return A.name == k.name && A.message == k.message;
      case D:
      case o:
        return A == k + "";
      case S:
        var ot = ge;
      case b:
        var ht = J & a;
        if (ot || (ot = ue), A.size != k.size && !ht)
          return !1;
        var Ue = Me.get(A);
        if (Ue)
          return Ue == k;
        J |= i, Me.set(A, k);
        var Ft = Hf(ot(A), ot(k), J, Le, oe, Me);
        return Me.delete(A), Ft;
      case h:
        if (We)
          return We.call(A) == We.call(k);
    }
    return !1;
  }
  function u2(A, k, q, J, Le, oe) {
    var Me = q & a, ot = zf(A), ht = ot.length, Ue = zf(k), Ft = Ue.length;
    if (ht != Ft && !Me)
      return !1;
    for (var Qt = ht; Qt--; ) {
      var yt = ot[Qt];
      if (!(Me ? yt in k : ie.call(k, yt)))
        return !1;
    }
    var Vt = oe.get(A);
    if (Vt && oe.get(k))
      return Vt == k;
    var qt = !0;
    oe.set(A, k), oe.set(k, A);
    for (var kr = Me; ++Qt < ht; ) {
      yt = ot[Qt];
      var mr = A[yt], an = k[yt];
      if (J)
        var Wf = Me ? J(an, mr, yt, k, A, oe) : J(mr, an, yt, A, k, oe);
      if (!(Wf === void 0 ? mr === an || Le(mr, an, q, J, oe) : Wf)) {
        qt = !1;
        break;
      }
      kr || (kr = yt == "constructor");
    }
    if (qt && !kr) {
      var Di = A.constructor, Ai = k.constructor;
      Di != Ai && "constructor" in A && "constructor" in k && !(typeof Di == "function" && Di instanceof Di && typeof Ai == "function" && Ai instanceof Ai) && (qt = !1);
    }
    return oe.delete(A), oe.delete(k), qt;
  }
  function zf(A) {
    return s2(A, x2, b2);
  }
  function xi(A, k) {
    var q = A.__data__;
    return g2(k) ? q[typeof k == "string" ? "string" : "hash"] : q.map;
  }
  function Nn(A, k) {
    var q = _e(A, k);
    return o2(q) ? q : void 0;
  }
  function h2(A) {
    var k = ie.call(A, Ut), q = A[Ut];
    try {
      A[Ut] = void 0;
      var J = !0;
    } catch {
    }
    var Le = Se.call(A);
    return J && (k ? A[Ut] = q : delete A[Ut]), Le;
  }
  var b2 = tn ? function(A) {
    return A == null ? [] : (A = Object(A), pe(tn(A), function(k) {
      return nr.call(A, k);
    }));
  } : S2, Pr = ha;
  (Ve && Pr(new Ve(new ArrayBuffer(1))) != P || $e && Pr(new $e()) != S || qe && Pr(qe.resolve()) != C || Ke && Pr(new Ke()) != b || Ge && Pr(new Ge()) != E) && (Pr = function(A) {
    var k = ha(A), q = k == x ? A.constructor : void 0, J = q ? nn(q) : "";
    if (J)
      switch (J) {
        case tt:
          return P;
        case rt:
          return S;
        case nt:
          return C;
        case at:
          return b;
        case it:
          return E;
      }
    return k;
  });
  function p2(A, k) {
    return k = k ?? c, !!k && (typeof A == "number" || Q.test(A)) && A > -1 && A % 1 == 0 && A < k;
  }
  function g2(A) {
    var k = typeof A;
    return k == "string" || k == "number" || k == "symbol" || k == "boolean" ? A !== "__proto__" : A === null;
  }
  function _2(A) {
    return !!ve && ve in A;
  }
  function y2(A) {
    var k = A && A.constructor, q = typeof k == "function" && k.prototype || ae;
    return A === q;
  }
  function w2(A) {
    return Se.call(A);
  }
  function nn(A) {
    if (A != null) {
      try {
        return ye.call(A);
      } catch {
      }
      try {
        return A + "";
      } catch {
      }
    }
    return "";
  }
  function jf(A, k) {
    return A === k || A !== A && k !== k;
  }
  var m2 = Bf(function() {
    return arguments;
  }()) ? Bf : function(A) {
    return ba(A) && ie.call(A, "callee") && !nr.call(A, "callee");
  }, Si = Array.isArray;
  function E2(A) {
    return A != null && qf(A.length) && !Vf(A);
  }
  var Ms = ua || D2;
  function v2(A, k) {
    return Mf(A, k);
  }
  function Vf(A) {
    if (!Kf(A))
      return !1;
    var k = ha(A);
    return k == g || k == m || k == f || k == _;
  }
  function qf(A) {
    return typeof A == "number" && A > -1 && A % 1 == 0 && A <= c;
  }
  function Kf(A) {
    var k = typeof A;
    return A != null && (k == "object" || k == "function");
  }
  function ba(A) {
    return A != null && typeof A == "object";
  }
  var Gf = ce ? Fe(ce) : f2;
  function x2(A) {
    return E2(A) ? i2(A) : d2(A);
  }
  function S2() {
    return [];
  }
  function D2() {
    return !1;
  }
  e.exports = v2;
})(Xi, Xi.exports);
var O4 = Xi.exports;
const N4 = /* @__PURE__ */ os(O4);
function R4(e, t) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var a = 0; a < e.length; a++) {
    var i = e.charAt(a), c = i.charCodeAt(0);
    if (r[c] !== 255)
      throw new TypeError(i + " is ambiguous");
    r[c] = a;
  }
  var s = e.length, d = e.charAt(0), f = Math.log(s) / Math.log(256), l = Math.log(256) / Math.log(s);
  function p(m) {
    if (m instanceof Uint8Array || (ArrayBuffer.isView(m) ? m = new Uint8Array(m.buffer, m.byteOffset, m.byteLength) : Array.isArray(m) && (m = Uint8Array.from(m))), !(m instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (m.length === 0)
      return "";
    for (var S = 0, I = 0, N = 0, x = m.length; N !== x && m[N] === 0; )
      N++, S++;
    for (var C = (x - N) * l + 1 >>> 0, _ = new Uint8Array(C); N !== x; ) {
      for (var D = m[N], b = 0, o = C - 1; (D !== 0 || b < I) && o !== -1; o--, b++)
        D += 256 * _[o] >>> 0, _[o] = D % s >>> 0, D = D / s >>> 0;
      if (D !== 0)
        throw new Error("Non-zero carry");
      I = b, N++;
    }
    for (var h = C - I; h !== C && _[h] === 0; )
      h++;
    for (var U = d.repeat(S); h < C; ++h)
      U += e.charAt(_[h]);
    return U;
  }
  function w(m) {
    if (typeof m != "string")
      throw new TypeError("Expected String");
    if (m.length === 0)
      return new Uint8Array();
    var S = 0;
    if (m[S] !== " ") {
      for (var I = 0, N = 0; m[S] === d; )
        I++, S++;
      for (var x = (m.length - S) * f + 1 >>> 0, C = new Uint8Array(x); m[S]; ) {
        var _ = r[m.charCodeAt(S)];
        if (_ === 255)
          return;
        for (var D = 0, b = x - 1; (_ !== 0 || D < N) && b !== -1; b--, D++)
          _ += s * C[b] >>> 0, C[b] = _ % 256 >>> 0, _ = _ / 256 >>> 0;
        if (_ !== 0)
          throw new Error("Non-zero carry");
        N = D, S++;
      }
      if (m[S] !== " ") {
        for (var o = x - N; o !== x && C[o] === 0; )
          o++;
        for (var h = new Uint8Array(I + (x - o)), U = I; o !== x; )
          h[U++] = C[o++];
        return h;
      }
    }
  }
  function g(m) {
    var S = w(m);
    if (S)
      return S;
    throw new Error(`Non-${t} character`);
  }
  return { encode: p, decodeUnsafe: w, decode: g };
}
var L4 = R4, P4 = L4;
const Pu = (e) => {
  if (e instanceof Uint8Array && e.constructor.name === "Uint8Array")
    return e;
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (ArrayBuffer.isView(e))
    return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
  throw new Error("Unknown type, must be binary type");
}, k4 = (e) => new TextEncoder().encode(e), U4 = (e) => new TextDecoder().decode(e);
class F4 {
  constructor(t, r, n) {
    this.name = t, this.prefix = r, this.baseEncode = n;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class $4 {
  constructor(t, r, n) {
    if (this.name = t, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ku(this, t);
  }
}
class B4 {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ku(this, t);
  }
  decode(t) {
    const r = t[0], n = this.decoders[r];
    if (n)
      return n.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const ku = (e, t) => new B4({ ...e.decoders || { [e.prefix]: e }, ...t.decoders || { [t.prefix]: t } });
class M4 {
  constructor(t, r, n, a) {
    this.name = t, this.prefix = r, this.baseEncode = n, this.baseDecode = a, this.encoder = new F4(t, r, n), this.decoder = new $4(t, r, a);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const Es = ({ name: e, prefix: t, encode: r, decode: n }) => new M4(e, t, r, n), si = ({ prefix: e, name: t, alphabet: r }) => {
  const { encode: n, decode: a } = P4(r, t);
  return Es({ prefix: e, name: t, encode: n, decode: (i) => Pu(a(i)) });
}, H4 = (e, t, r, n) => {
  const a = {};
  for (let l = 0; l < t.length; ++l)
    a[t[l]] = l;
  let i = e.length;
  for (; e[i - 1] === "="; )
    --i;
  const c = new Uint8Array(i * r / 8 | 0);
  let s = 0, d = 0, f = 0;
  for (let l = 0; l < i; ++l) {
    const p = a[e[l]];
    if (p === void 0)
      throw new SyntaxError(`Non-${n} character`);
    d = d << r | p, s += r, s >= 8 && (s -= 8, c[f++] = 255 & d >> s);
  }
  if (s >= r || 255 & d << 8 - s)
    throw new SyntaxError("Unexpected end of data");
  return c;
}, z4 = (e, t, r) => {
  const n = t[t.length - 1] === "=", a = (1 << r) - 1;
  let i = "", c = 0, s = 0;
  for (let d = 0; d < e.length; ++d)
    for (s = s << 8 | e[d], c += 8; c > r; )
      c -= r, i += t[a & s >> c];
  if (c && (i += t[a & s << r - c]), n)
    for (; i.length * r & 7; )
      i += "=";
  return i;
}, _t = ({ name: e, prefix: t, bitsPerChar: r, alphabet: n }) => Es({ prefix: t, name: e, encode(a) {
  return z4(a, n, r);
}, decode(a) {
  return H4(a, n, r, e);
} }), j4 = Es({ prefix: "\0", name: "identity", encode: (e) => U4(e), decode: (e) => k4(e) });
var V4 = Object.freeze({ __proto__: null, identity: j4 });
const q4 = _t({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var K4 = Object.freeze({ __proto__: null, base2: q4 });
const G4 = _t({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var W4 = Object.freeze({ __proto__: null, base8: G4 });
const Z4 = si({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Y4 = Object.freeze({ __proto__: null, base10: Z4 });
const X4 = _t({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), J4 = _t({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Q4 = Object.freeze({ __proto__: null, base16: X4, base16upper: J4 });
const e7 = _t({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), t7 = _t({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), r7 = _t({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), n7 = _t({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), a7 = _t({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), i7 = _t({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), s7 = _t({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), c7 = _t({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), o7 = _t({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var f7 = Object.freeze({ __proto__: null, base32: e7, base32upper: t7, base32pad: r7, base32padupper: n7, base32hex: a7, base32hexupper: i7, base32hexpad: s7, base32hexpadupper: c7, base32z: o7 });
const d7 = si({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), l7 = si({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var u7 = Object.freeze({ __proto__: null, base36: d7, base36upper: l7 });
const h7 = si({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), b7 = si({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var p7 = Object.freeze({ __proto__: null, base58btc: h7, base58flickr: b7 });
const g7 = _t({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), _7 = _t({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), y7 = _t({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), w7 = _t({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var m7 = Object.freeze({ __proto__: null, base64: g7, base64pad: _7, base64url: y7, base64urlpad: w7 });
const Uu = Array.from(""), E7 = Uu.reduce((e, t, r) => (e[r] = t, e), []), v7 = Uu.reduce((e, t, r) => (e[t.codePointAt(0)] = r, e), []);
function x7(e) {
  return e.reduce((t, r) => (t += E7[r], t), "");
}
function S7(e) {
  const t = [];
  for (const r of e) {
    const n = v7[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    t.push(n);
  }
  return new Uint8Array(t);
}
const D7 = Es({ prefix: "", name: "base256emoji", encode: x7, decode: S7 });
var A7 = Object.freeze({ __proto__: null, base256emoji: D7 }), I7 = Fu, Yd = 128, C7 = 127, T7 = ~C7, O7 = Math.pow(2, 31);
function Fu(e, t, r) {
  t = t || [], r = r || 0;
  for (var n = r; e >= O7; )
    t[r++] = e & 255 | Yd, e /= 128;
  for (; e & T7; )
    t[r++] = e & 255 | Yd, e >>>= 7;
  return t[r] = e | 0, Fu.bytes = r - n + 1, t;
}
var N7 = Hc, R7 = 128, Xd = 127;
function Hc(e, n) {
  var r = 0, n = n || 0, a = 0, i = n, c, s = e.length;
  do {
    if (i >= s)
      throw Hc.bytes = 0, new RangeError("Could not decode varint");
    c = e[i++], r += a < 28 ? (c & Xd) << a : (c & Xd) * Math.pow(2, a), a += 7;
  } while (c >= R7);
  return Hc.bytes = i - n, r;
}
var L7 = Math.pow(2, 7), P7 = Math.pow(2, 14), k7 = Math.pow(2, 21), U7 = Math.pow(2, 28), F7 = Math.pow(2, 35), $7 = Math.pow(2, 42), B7 = Math.pow(2, 49), M7 = Math.pow(2, 56), H7 = Math.pow(2, 63), z7 = function(e) {
  return e < L7 ? 1 : e < P7 ? 2 : e < k7 ? 3 : e < U7 ? 4 : e < F7 ? 5 : e < $7 ? 6 : e < B7 ? 7 : e < M7 ? 8 : e < H7 ? 9 : 10;
}, j7 = { encode: I7, decode: N7, encodingLength: z7 }, $u = j7;
const Jd = (e, t, r = 0) => ($u.encode(e, t, r), t), Qd = (e) => $u.encodingLength(e), zc = (e, t) => {
  const r = t.byteLength, n = Qd(e), a = n + Qd(r), i = new Uint8Array(a + r);
  return Jd(e, i, 0), Jd(r, i, n), i.set(t, a), new V7(e, r, t, i);
};
class V7 {
  constructor(t, r, n, a) {
    this.code = t, this.size = r, this.digest = n, this.bytes = a;
  }
}
const Bu = ({ name: e, code: t, encode: r }) => new q7(e, t, r);
class q7 {
  constructor(t, r, n) {
    this.name = t, this.code = r, this.encode = n;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const r = this.encode(t);
      return r instanceof Uint8Array ? zc(this.code, r) : r.then((n) => zc(this.code, n));
    } else
      throw Error("Unknown type, must be binary type");
  }
}
const Mu = (e) => async (t) => new Uint8Array(await crypto.subtle.digest(e, t)), K7 = Bu({ name: "sha2-256", code: 18, encode: Mu("SHA-256") }), G7 = Bu({ name: "sha2-512", code: 19, encode: Mu("SHA-512") });
var W7 = Object.freeze({ __proto__: null, sha256: K7, sha512: G7 });
const Hu = 0, Z7 = "identity", zu = Pu, Y7 = (e) => zc(Hu, zu(e)), X7 = { code: Hu, name: Z7, encode: zu, digest: Y7 };
var J7 = Object.freeze({ __proto__: null, identity: X7 });
new TextEncoder(), new TextDecoder();
const e0 = { ...V4, ...K4, ...W4, ...Y4, ...Q4, ...f7, ...u7, ...p7, ...m7, ...A7 };
({ ...W7, ...J7 });
function ju(e) {
  return globalThis.Buffer != null ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e;
}
function Q7(e = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? ju(globalThis.Buffer.allocUnsafe(e)) : new Uint8Array(e);
}
function Vu(e, t, r, n) {
  return { name: e, prefix: t, encoder: { name: e, prefix: t, encode: r }, decoder: { decode: n } };
}
const t0 = Vu("utf8", "u", (e) => "u" + new TextDecoder("utf8").decode(e), (e) => new TextEncoder().encode(e.substring(1))), Xs = Vu("ascii", "a", (e) => {
  let t = "a";
  for (let r = 0; r < e.length; r++)
    t += String.fromCharCode(e[r]);
  return t;
}, (e) => {
  e = e.substring(1);
  const t = Q7(e.length);
  for (let r = 0; r < e.length; r++)
    t[r] = e.charCodeAt(r);
  return t;
}), e9 = { utf8: t0, "utf-8": t0, hex: e0.base16, latin1: Xs, ascii: Xs, binary: Xs, ...e0 };
function t9(e, t = "utf8") {
  const r = e9[t];
  if (!r)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? ju(globalThis.Buffer.from(e, "utf-8")) : r.decoder.decode(`${r.prefix}${e}`);
}
const qu = "wc", r9 = 2, $o = "core", Kr = `${qu}@2:${$o}:`, n9 = { name: $o, logger: "error" }, a9 = { database: ":memory:" }, i9 = "crypto", r0 = "client_ed25519_seed", s9 = re.ONE_DAY, c9 = "keychain", o9 = "0.3", f9 = "messages", d9 = "0.3", l9 = re.SIX_HOURS, u9 = "publisher", Ku = "irn", h9 = "error", Gu = "wss://relay.walletconnect.com", b9 = "relayer", He = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, p9 = "_subscription", va = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, g9 = re.ONE_SECOND / 2, _9 = "2.8.1", y9 = 1e4, w9 = "0.3", m9 = "WALLETCONNECT_CLIENT_ID", or = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, E9 = "subscription", v9 = "0.3", x9 = re.FIVE_SECONDS * 1e3, S9 = "pairing", D9 = "0.3", xa = { wc_pairingDelete: { req: { ttl: re.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: re.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: re.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: re.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: re.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: re.ONE_DAY, prompt: !1, tag: 0 } } }, ir = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, A9 = "history", I9 = "0.3", C9 = "expirer", Gt = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, T9 = "0.3", Js = "verify-api", n0 = "https://verify.walletconnect.com";
class O9 {
  constructor(t, r) {
    this.core = t, this.logger = r, this.keychain = /* @__PURE__ */ new Map(), this.name = c9, this.version = o9, this.initialized = !1, this.storagePrefix = Kr, this.init = async () => {
      if (!this.initialized) {
        const n = await this.getKeyChain();
        typeof n < "u" && (this.keychain = n), this.initialized = !0;
      }
    }, this.has = (n) => (this.isInitialized(), this.keychain.has(n)), this.set = async (n, a) => {
      this.isInitialized(), this.keychain.set(n, a), await this.persist();
    }, this.get = (n) => {
      this.isInitialized();
      const a = this.keychain.get(n);
      if (typeof a > "u") {
        const { message: i } = X("NO_MATCHING_KEY", `${this.name}: ${n}`);
        throw new Error(i);
      }
      return a;
    }, this.del = async (n) => {
      this.isInitialized(), this.keychain.delete(n), await this.persist();
    }, this.core = t, this.logger = xe.generateChildLogger(r, this.name);
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setKeyChain(t) {
    await this.core.storage.setItem(this.storageKey, Eu(t));
  }
  async getKeyChain() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? vu(t) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = X("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class N9 {
  constructor(t, r, n) {
    this.core = t, this.logger = r, this.name = i9, this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (a) => (this.isInitialized(), this.keychain.has(a)), this.getClientId = async () => {
      this.isInitialized();
      const a = await this.getClientSeed(), i = Sd(a);
      return ru(i.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const a = t8();
      return this.setPrivateKey(a.publicKey, a.privateKey);
    }, this.signJWT = async (a) => {
      this.isInitialized();
      const i = await this.getClientSeed(), c = Sd(i), s = Bc();
      return await a5(s, a, s9, c);
    }, this.generateSharedKey = (a, i, c) => {
      this.isInitialized();
      const s = this.getPrivateKey(a), d = r8(s, i);
      return this.setSymKey(d, c);
    }, this.setSymKey = async (a, i) => {
      this.isInitialized();
      const c = i || n8(a);
      return await this.keychain.set(c, a), c;
    }, this.deleteKeyPair = async (a) => {
      this.isInitialized(), await this.keychain.del(a);
    }, this.deleteSymKey = async (a) => {
      this.isInitialized(), await this.keychain.del(a);
    }, this.encode = async (a, i, c) => {
      this.isInitialized();
      const s = yu(c), d = mo(i);
      if (kd(s)) {
        const w = s.senderPublicKey, g = s.receiverPublicKey;
        a = await this.generateSharedKey(w, g);
      }
      const f = this.getSymKey(a), { type: l, senderPublicKey: p } = s;
      return i8({ type: l, symKey: f, message: d, senderPublicKey: p });
    }, this.decode = async (a, i, c) => {
      this.isInitialized();
      const s = o8(i, c);
      if (kd(s)) {
        const l = s.receiverPublicKey, p = s.senderPublicKey;
        a = await this.generateSharedKey(l, p);
      }
      const d = this.getSymKey(a), f = s8({ symKey: d, encoded: i });
      return Hl(f);
    }, this.getPayloadType = (a) => {
      const i = Zi(a);
      return ai(i.type);
    }, this.getPayloadSenderPublicKey = (a) => {
      const i = Zi(a);
      return i.senderPublicKey ? Tt(i.senderPublicKey, Ct) : void 0;
    }, this.core = t, this.logger = xe.generateChildLogger(r, this.name), this.keychain = n || new O9(this.core, this.logger);
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  async setPrivateKey(t, r) {
    return await this.keychain.set(t, r), t;
  }
  getPrivateKey(t) {
    return this.keychain.get(t);
  }
  async getClientSeed() {
    let t = "";
    try {
      t = this.keychain.get(r0);
    } catch {
      t = Bc(), await this.keychain.set(r0, t);
    }
    return t9(t, "base16");
  }
  getSymKey(t) {
    return this.keychain.get(t);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = X("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class R9 extends c6 {
  constructor(t, r) {
    super(t, r), this.logger = t, this.core = r, this.messages = /* @__PURE__ */ new Map(), this.name = f9, this.version = d9, this.initialized = !1, this.storagePrefix = Kr, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const n = await this.getRelayerMessages();
          typeof n < "u" && (this.messages = n), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (n) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (n, a) => {
      this.isInitialized();
      const i = Vn(a);
      let c = this.messages.get(n);
      return typeof c > "u" && (c = {}), typeof c[i] < "u" || (c[i] = a, this.messages.set(n, c), await this.persist()), i;
    }, this.get = (n) => {
      this.isInitialized();
      let a = this.messages.get(n);
      return typeof a > "u" && (a = {}), a;
    }, this.has = (n, a) => {
      this.isInitialized();
      const i = this.get(n), c = Vn(a);
      return typeof i[c] < "u";
    }, this.del = async (n) => {
      this.isInitialized(), this.messages.delete(n), await this.persist();
    }, this.logger = xe.generateChildLogger(t, this.name), this.core = r;
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setRelayerMessages(t) {
    await this.core.storage.setItem(this.storageKey, Eu(t));
  }
  async getRelayerMessages() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? vu(t) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = X("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class L9 extends o6 {
  constructor(t, r) {
    super(t, r), this.relayer = t, this.logger = r, this.events = new zt.EventEmitter(), this.name = u9, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = 1e4, this.publish = async (n, a, i) => {
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: a, opts: i } });
      try {
        const c = i?.ttl || l9, s = Mc(i), d = i?.prompt || !1, f = i?.tag || 0, l = i?.id || Uo().toString(), p = { topic: n, message: a, opts: { ttl: c, relay: s, prompt: d, tag: f, id: l } };
        this.queue.set(l, p);
        try {
          await await Yi(this.rpcPublish(n, a, c, s, d, f, l), this.publishTimeout), this.relayer.events.emit(He.publish, p);
        } catch {
          this.logger.debug("Publishing Payload stalled"), this.relayer.events.emit(He.connection_stalled);
          return;
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: a, opts: i } });
      } catch (c) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(c), c;
      }
    }, this.on = (n, a) => {
      this.events.on(n, a);
    }, this.once = (n, a) => {
      this.events.once(n, a);
    }, this.off = (n, a) => {
      this.events.off(n, a);
    }, this.removeListener = (n, a) => {
      this.events.removeListener(n, a);
    }, this.relayer = t, this.logger = xe.generateChildLogger(r, this.name), this.registerEventListeners();
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  rpcPublish(t, r, n, a, i, c, s) {
    var d, f, l, p;
    const w = { method: Mi(a.protocol).publish, params: { topic: t, message: r, ttl: n, prompt: i, tag: c }, id: s };
    return At((d = w.params) == null ? void 0 : d.prompt) && ((f = w.params) == null || delete f.prompt), At((l = w.params) == null ? void 0 : l.tag) && ((p = w.params) == null || delete p.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: w }), this.relayer.request(w);
  }
  onPublish(t) {
    this.queue.delete(t);
  }
  checkQueue() {
    this.queue.forEach(async (t) => {
      const { topic: r, message: n, opts: a } = t;
      await this.publish(r, n, a);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(ti.HEARTBEAT_EVENTS.pulse, () => {
      this.checkQueue();
    }), this.relayer.on(He.message_ack, (t) => {
      this.onPublish(t.id.toString());
    });
  }
}
class P9 {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (t, r) => {
      const n = this.get(t);
      this.exists(t, r) || this.map.set(t, [...n, r]);
    }, this.get = (t) => this.map.get(t) || [], this.exists = (t, r) => this.get(t).includes(r), this.delete = (t, r) => {
      if (typeof r > "u") {
        this.map.delete(t);
        return;
      }
      if (!this.map.has(t))
        return;
      const n = this.get(t);
      if (!this.exists(t, r))
        return;
      const a = n.filter((i) => i !== r);
      if (!a.length) {
        this.map.delete(t);
        return;
      }
      this.map.set(t, a);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var k9 = Object.defineProperty, U9 = Object.defineProperties, F9 = Object.getOwnPropertyDescriptors, a0 = Object.getOwnPropertySymbols, $9 = Object.prototype.hasOwnProperty, B9 = Object.prototype.propertyIsEnumerable, i0 = (e, t, r) => t in e ? k9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Sa = (e, t) => {
  for (var r in t || (t = {}))
    $9.call(t, r) && i0(e, r, t[r]);
  if (a0)
    for (var r of a0(t))
      B9.call(t, r) && i0(e, r, t[r]);
  return e;
}, Qs = (e, t) => U9(e, F9(t));
class M9 extends l6 {
  constructor(t, r) {
    super(t, r), this.relayer = t, this.logger = r, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new P9(), this.events = new zt.EventEmitter(), this.name = E9, this.version = v9, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = Kr, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restart(), this.registerEventListeners(), this.onEnable(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (n, a) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: a } });
      try {
        const i = Mc(a), c = { topic: n, relay: i };
        this.pending.set(n, c);
        const s = await this.rpcSubscribe(n, i);
        return this.onSubscribe(s, c), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: a } }), s;
      } catch (i) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(i), i;
      }
    }, this.unsubscribe = async (n, a) => {
      await this.restartToComplete(), this.isInitialized(), typeof a?.id < "u" ? await this.unsubscribeById(n, a.id, a) : await this.unsubscribeByTopic(n, a);
    }, this.isSubscribed = async (n) => this.topics.includes(n) ? !0 : await new Promise((a, i) => {
      const c = new re.Watch();
      c.start(this.pendingSubscriptionWatchLabel);
      const s = setInterval(() => {
        !this.pending.has(n) && this.topics.includes(n) && (clearInterval(s), c.stop(this.pendingSubscriptionWatchLabel), a(!0)), c.elapsed(this.pendingSubscriptionWatchLabel) >= x9 && (clearInterval(s), c.stop(this.pendingSubscriptionWatchLabel), i(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => !1), this.on = (n, a) => {
      this.events.on(n, a);
    }, this.once = (n, a) => {
      this.events.once(n, a);
    }, this.off = (n, a) => {
      this.events.off(n, a);
    }, this.removeListener = (n, a) => {
      this.events.removeListener(n, a);
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = t, this.logger = xe.generateChildLogger(r, this.name), this.clientId = "";
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(t, r) {
    let n = !1;
    try {
      n = this.getSubscription(t).topic === r;
    } catch {
    }
    return n;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(t, r) {
    const n = this.topicMap.get(t);
    await Promise.all(n.map(async (a) => await this.unsubscribeById(t, a, r)));
  }
  async unsubscribeById(t, r, n) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: t, id: r, opts: n } });
    try {
      const a = Mc(n);
      await this.rpcUnsubscribe(t, r, a);
      const i = Qe("USER_DISCONNECTED", `${this.name}, ${t}`);
      await this.onUnsubscribe(t, r, i), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: t, id: r, opts: n } });
    } catch (a) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(a), a;
    }
  }
  async rpcSubscribe(t, r) {
    const n = { method: Mi(r.protocol).subscribe, params: { topic: t } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      await await Yi(this.relayer.request(n), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(He.connection_stalled);
    }
    return Vn(t + this.clientId);
  }
  async rpcBatchSubscribe(t) {
    if (!t.length)
      return;
    const r = t[0].relay, n = { method: Mi(r.protocol).batchSubscribe, params: { topics: t.map((a) => a.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      return await await Yi(this.relayer.request(n), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(He.connection_stalled);
    }
  }
  rpcUnsubscribe(t, r, n) {
    const a = { method: Mi(n.protocol).unsubscribe, params: { topic: t, id: r } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: a }), this.relayer.request(a);
  }
  onSubscribe(t, r) {
    this.setSubscription(t, Qs(Sa({}, r), { id: t })), this.pending.delete(r.topic);
  }
  onBatchSubscribe(t) {
    t.length && t.forEach((r) => {
      this.setSubscription(r.id, Sa({}, r)), this.pending.delete(r.topic);
    });
  }
  async onUnsubscribe(t, r, n) {
    this.events.removeAllListeners(r), this.hasSubscription(r, t) && this.deleteSubscription(r, n), await this.relayer.messages.del(t);
  }
  async setRelayerSubscriptions(t) {
    await this.relayer.core.storage.setItem(this.storageKey, t);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(t, r) {
    this.subscriptions.has(t) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: t, subscription: r }), this.addSubscription(t, r));
  }
  addSubscription(t, r) {
    this.subscriptions.set(t, Sa({}, r)), this.topicMap.set(r.topic, t), this.events.emit(or.created, r);
  }
  getSubscription(t) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: t });
    const r = this.subscriptions.get(t);
    if (!r) {
      const { message: n } = X("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw new Error(n);
    }
    return r;
  }
  deleteSubscription(t, r) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: t, reason: r });
    const n = this.getSubscription(t);
    this.subscriptions.delete(t), this.topicMap.delete(n.topic, t), this.events.emit(or.deleted, Qs(Sa({}, n), { reason: r }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(or.sync);
  }
  async reset() {
    if (this.cached.length) {
      const t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < t; r++) {
        const n = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(n);
      }
    }
    this.events.emit(or.resubscribed);
  }
  async restore() {
    try {
      const t = await this.getRelayerSubscriptions();
      if (typeof t > "u" || !t.length)
        return;
      if (this.subscriptions.size) {
        const { message: r } = X("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(r);
      }
      this.cached = t, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(t);
    }
  }
  async batchSubscribe(t) {
    if (!t.length)
      return;
    const r = await this.rpcBatchSubscribe(t);
    ii(r) && this.onBatchSubscribe(r.map((n, a) => Qs(Sa({}, t[a]), { id: n })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (this.relayer.transportExplicitlyClosed)
      return;
    const t = [];
    this.pending.forEach((r) => {
      t.push(r);
    }), await this.batchSubscribe(t);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(ti.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(He.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(He.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(or.created, async (t) => {
      const r = or.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: t }), await this.persist();
    }), this.events.on(or.deleted, async (t) => {
      const r = or.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: t }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = X("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((t) => {
      const r = setInterval(() => {
        this.restartInProgress || (clearInterval(r), t());
      }, this.pollingInterval);
    });
  }
}
var H9 = Object.defineProperty, s0 = Object.getOwnPropertySymbols, z9 = Object.prototype.hasOwnProperty, j9 = Object.prototype.propertyIsEnumerable, c0 = (e, t, r) => t in e ? H9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, V9 = (e, t) => {
  for (var r in t || (t = {}))
    z9.call(t, r) && c0(e, r, t[r]);
  if (s0)
    for (var r of s0(t))
      j9.call(t, r) && c0(e, r, t[r]);
  return e;
};
class q9 extends f6 {
  constructor(t) {
    super(t), this.protocol = "wc", this.version = 2, this.events = new zt.EventEmitter(), this.name = b9, this.transportExplicitlyClosed = !1, this.initialized = !1, this.reconnecting = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.request = async (r) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(r);
      } catch (n) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(n), n;
      }
    }, this.core = t.core, this.logger = typeof t.logger < "u" && typeof t.logger != "string" ? xe.generateChildLogger(t.logger, this.name) : xe.pino(xe.getDefaultLoggerOptions({ level: t.logger || h9 })), this.messages = new R9(this.logger, t.core), this.subscriber = new M9(this, this.logger), this.publisher = new L9(this, this.logger), this.relayUrl = t?.relayUrl || Gu, this.projectId = t.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), await this.createProvider(), await Promise.all([this.messages.init(), this.transportOpen(), this.subscriber.init()]), this.registerEventListeners(), this.initialized = !0, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribted to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1);
    }, y9);
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(t, r, n) {
    this.isInitialized(), await this.publisher.publish(t, r, n), await this.recordMessageEvent({ topic: t, message: r, publishedAt: Date.now() });
  }
  async subscribe(t, r) {
    var n;
    this.isInitialized();
    let a = ((n = this.subscriber.topicMap.get(t)) == null ? void 0 : n[0]) || "";
    return a || (await Promise.all([new Promise((i) => {
      this.subscriber.once(or.created, (c) => {
        c.topic === t && i();
      });
    }), new Promise(async (i) => {
      a = await this.subscriber.subscribe(t, r), i();
    })]), a);
  }
  async unsubscribe(t, r) {
    this.isInitialized(), await this.subscriber.unsubscribe(t, r);
  }
  on(t, r) {
    this.events.on(t, r);
  }
  once(t, r) {
    this.events.once(t, r);
  }
  off(t, r) {
    this.events.off(t, r);
  }
  removeListener(t, r) {
    this.events.removeListener(t, r);
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, this.connected && (await this.provider.disconnect(), this.events.emit(He.transport_closed));
  }
  async transportOpen(t) {
    if (this.transportExplicitlyClosed = !1, !this.reconnecting) {
      this.relayUrl = t || this.relayUrl, this.reconnecting = !0;
      try {
        await Promise.all([new Promise((r) => {
          this.initialized || r(), this.subscriber.once(or.resubscribed, () => {
            r();
          });
        }), await Promise.race([new Promise(async (r, n) => {
          await Yi(this.provider.connect(), 5e3, "socket stalled").catch((a) => n(a)).then(() => r()).finally(() => this.removeListener(He.transport_closed, this.rejectTransportOpen));
        }), new Promise((r) => this.once(He.transport_closed, this.rejectTransportOpen))])]);
      } catch (r) {
        this.logger.error(r);
        const n = r;
        if (!this.isConnectionStalled(n.message))
          throw r;
        this.events.emit(He.transport_closed);
      } finally {
        this.reconnecting = !1;
      }
    }
  }
  async restartTransport(t) {
    this.transportExplicitlyClosed || this.reconnecting || (this.relayUrl = t || this.relayUrl, this.connected && await Promise.all([new Promise((r) => {
      this.provider.once(va.disconnect, () => {
        r();
      });
    }), this.transportClose()]), await this.createProvider(), await this.transportOpen());
  }
  isConnectionStalled(t) {
    return this.staleConnectionErrors.some((r) => t.includes(r));
  }
  rejectTransportOpen() {
    throw new Error("closeTransport called before connection was established");
  }
  async createProvider() {
    const t = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new Lu(new T4(w8({ sdkVersion: _9, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: t, useOnCloseEvent: !0 }))), this.registerProviderListeners();
  }
  async recordMessageEvent(t) {
    const { topic: r, message: n } = t;
    await this.messages.set(r, n);
  }
  async shouldIgnoreMessageEvent(t) {
    const { topic: r, message: n } = t;
    return await this.subscriber.isSubscribed(r) ? this.messages.has(r, n) : !0;
  }
  async onProviderPayload(t) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: t }), Fo(t)) {
      if (!t.method.endsWith(p9))
        return;
      const r = t.params, { topic: n, message: a, publishedAt: i } = r.data, c = { topic: n, message: a, publishedAt: i };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(V9({ type: "event", event: r.id }, c)), this.events.emit(r.id, c), await this.acknowledgePayload(t), await this.onMessageEvent(c);
    } else
      ms(t) && this.events.emit(He.message_ack, t);
  }
  async onMessageEvent(t) {
    await this.shouldIgnoreMessageEvent(t) || (this.events.emit(He.message, t), await this.recordMessageEvent(t));
  }
  async acknowledgePayload(t) {
    const r = ys(t.id, !0);
    await this.provider.connection.send(r);
  }
  registerProviderListeners() {
    this.provider.on(va.payload, (t) => this.onProviderPayload(t)), this.provider.on(va.connect, () => {
      this.events.emit(He.connect);
    }), this.provider.on(va.disconnect, () => {
      this.onProviderDisconnect();
    }), this.provider.on(va.error, (t) => {
      this.logger.error(t), this.events.emit(He.error, t);
    });
  }
  registerEventListeners() {
    this.events.on(He.connection_stalled, async () => {
      await this.restartTransport();
    });
  }
  onProviderDisconnect() {
    this.events.emit(He.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || setTimeout(async () => {
      await this.restartTransport();
    }, re.toMiliseconds(g9));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = X("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async toEstablishConnection() {
    if (!this.connected) {
      if (this.connecting)
        return await new Promise((t) => {
          const r = setInterval(() => {
            this.connected && (clearInterval(r), t());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
}
var K9 = Object.defineProperty, o0 = Object.getOwnPropertySymbols, G9 = Object.prototype.hasOwnProperty, W9 = Object.prototype.propertyIsEnumerable, f0 = (e, t, r) => t in e ? K9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, d0 = (e, t) => {
  for (var r in t || (t = {}))
    G9.call(t, r) && f0(e, r, t[r]);
  if (o0)
    for (var r of o0(t))
      W9.call(t, r) && f0(e, r, t[r]);
  return e;
};
class vs extends d6 {
  constructor(t, r, n, a = Kr, i = void 0) {
    super(t, r, n, a), this.core = t, this.logger = r, this.name = n, this.map = /* @__PURE__ */ new Map(), this.version = w9, this.cached = [], this.initialized = !1, this.storagePrefix = Kr, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((c) => {
        this.getKey && c !== null && !At(c) ? this.map.set(this.getKey(c), c) : z8(c) ? this.map.set(c.id, c) : j8(c) && this.map.set(c.topic, c);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (c, s) => {
      this.isInitialized(), this.map.has(c) ? await this.update(c, s) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: c, value: s }), this.map.set(c, s), await this.persist());
    }, this.get = (c) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: c }), this.getData(c)), this.getAll = (c) => (this.isInitialized(), c ? this.values.filter((s) => Object.keys(c).every((d) => N4(s[d], c[d]))) : this.values), this.update = async (c, s) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: c, update: s });
      const d = d0(d0({}, this.getData(c)), s);
      this.map.set(c, d), await this.persist();
    }, this.delete = async (c, s) => {
      this.isInitialized(), this.map.has(c) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: c, reason: s }), this.map.delete(c), await this.persist());
    }, this.logger = xe.generateChildLogger(r, this.name), this.storagePrefix = a, this.getKey = i;
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(t) {
    const r = this.map.get(t);
    if (!r) {
      const { message: n } = X("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw this.logger.error(n), new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const t = await this.getDataStore();
      if (typeof t > "u" || !t.length)
        return;
      if (this.map.size) {
        const { message: r } = X("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = t, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(t);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = X("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class Z9 {
  constructor(t, r) {
    this.core = t, this.logger = r, this.name = S9, this.version = D9, this.events = new Pl(), this.initialized = !1, this.storagePrefix = Kr, this.ignoredPayloadTypes = [Cn], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: n }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...n])];
    }, this.create = async () => {
      this.isInitialized();
      const n = Bc(), a = await this.core.crypto.setSymKey(n), i = fr(re.FIVE_MINUTES), c = { protocol: Ku }, s = { topic: a, expiry: i, relay: c, active: !1 }, d = R8({ protocol: this.core.protocol, version: this.core.version, topic: a, symKey: n, relay: c });
      return await this.pairings.set(a, s), await this.core.relayer.subscribe(a), this.core.expirer.set(a, i), { topic: a, uri: d };
    }, this.pair = async (n) => {
      this.isInitialized(), this.isValidPair(n);
      const { topic: a, symKey: i, relay: c } = T8(n.uri);
      if (this.pairings.keys.includes(a))
        throw new Error(`Pairing already exists: ${a}`);
      if (this.core.crypto.hasKeys(a))
        throw new Error(`Keychain already exists: ${a}`);
      const s = fr(re.FIVE_MINUTES), d = { topic: a, relay: c, expiry: s, active: !1 };
      return await this.pairings.set(a, d), await this.core.crypto.setSymKey(i, a), await this.core.relayer.subscribe(a, { relay: c }), this.core.expirer.set(a, s), n.activatePairing && await this.activate({ topic: a }), d;
    }, this.activate = async ({ topic: n }) => {
      this.isInitialized();
      const a = fr(re.THIRTY_DAYS);
      await this.pairings.update(n, { active: !0, expiry: a }), this.core.expirer.set(n, a);
    }, this.ping = async (n) => {
      this.isInitialized(), await this.isValidPing(n);
      const { topic: a } = n;
      if (this.pairings.keys.includes(a)) {
        const i = await this.sendRequest(a, "wc_pairingPing", {}), { done: c, resolve: s, reject: d } = Fn();
        this.events.once(Ze("pairing_ping", i), ({ error: f }) => {
          f ? d(f) : s();
        }), await c();
      }
    }, this.updateExpiry = async ({ topic: n, expiry: a }) => {
      this.isInitialized(), await this.pairings.update(n, { expiry: a });
    }, this.updateMetadata = async ({ topic: n, metadata: a }) => {
      this.isInitialized(), await this.pairings.update(n, { peerMetadata: a });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (n) => {
      this.isInitialized(), await this.isValidDisconnect(n);
      const { topic: a } = n;
      this.pairings.keys.includes(a) && (await this.sendRequest(a, "wc_pairingDelete", Qe("USER_DISCONNECTED")), await this.deletePairing(a));
    }, this.sendRequest = async (n, a, i) => {
      const c = _s(a, i), s = await this.core.crypto.encode(n, c), d = xa[a].req;
      return this.core.history.set(n, c), this.core.relayer.publish(n, s, d), c.id;
    }, this.sendResult = async (n, a, i) => {
      const c = ys(n, i), s = await this.core.crypto.encode(a, c), d = await this.core.history.get(a, n), f = xa[d.request.method].res;
      await this.core.relayer.publish(a, s, f), await this.core.history.resolve(c);
    }, this.sendError = async (n, a, i) => {
      const c = ws(n, i), s = await this.core.crypto.encode(a, c), d = await this.core.history.get(a, n), f = xa[d.request.method] ? xa[d.request.method].res : xa.unregistered_method.res;
      await this.core.relayer.publish(a, s, f), await this.core.history.resolve(c);
    }, this.deletePairing = async (n, a) => {
      await this.core.relayer.unsubscribe(n), await Promise.all([this.pairings.delete(n, Qe("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(n), a ? Promise.resolve() : this.core.expirer.del(n)]);
    }, this.cleanup = async () => {
      const n = this.pairings.getAll().filter((a) => $r(a.expiry));
      await Promise.all(n.map((a) => this.deletePairing(a.topic)));
    }, this.onRelayEventRequest = (n) => {
      const { topic: a, payload: i } = n, c = i.method;
      if (this.pairings.keys.includes(a))
        switch (c) {
          case "wc_pairingPing":
            return this.onPairingPingRequest(a, i);
          case "wc_pairingDelete":
            return this.onPairingDeleteRequest(a, i);
          default:
            return this.onUnknownRpcMethodRequest(a, i);
        }
    }, this.onRelayEventResponse = async (n) => {
      const { topic: a, payload: i } = n, c = (await this.core.history.get(a, i.id)).request.method;
      if (this.pairings.keys.includes(a))
        switch (c) {
          case "wc_pairingPing":
            return this.onPairingPingResponse(a, i);
          default:
            return this.onUnknownRpcMethodResponse(c);
        }
    }, this.onPairingPingRequest = async (n, a) => {
      const { id: i } = a;
      try {
        this.isValidPing({ topic: n }), await this.sendResult(i, n, !0), this.events.emit("pairing_ping", { id: i, topic: n });
      } catch (c) {
        await this.sendError(i, n, c), this.logger.error(c);
      }
    }, this.onPairingPingResponse = (n, a) => {
      const { id: i } = a;
      setTimeout(() => {
        Dr(a) ? this.events.emit(Ze("pairing_ping", i), {}) : er(a) && this.events.emit(Ze("pairing_ping", i), { error: a.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (n, a) => {
      const { id: i } = a;
      try {
        this.isValidDisconnect({ topic: n }), await this.deletePairing(n), this.events.emit("pairing_delete", { id: i, topic: n });
      } catch (c) {
        await this.sendError(i, n, c), this.logger.error(c);
      }
    }, this.onUnknownRpcMethodRequest = async (n, a) => {
      const { id: i, method: c } = a;
      try {
        if (this.registeredMethods.includes(c))
          return;
        const s = Qe("WC_METHOD_UNSUPPORTED", c);
        await this.sendError(i, n, s), this.logger.error(s);
      } catch (s) {
        await this.sendError(i, n, s), this.logger.error(s);
      }
    }, this.onUnknownRpcMethodResponse = (n) => {
      this.registeredMethods.includes(n) || this.logger.error(Qe("WC_METHOD_UNSUPPORTED", n));
    }, this.isValidPair = (n) => {
      if (!Ot(n)) {
        const { message: a } = X("MISSING_OR_INVALID", `pair() params: ${n}`);
        throw new Error(a);
      }
      if (!H8(n.uri)) {
        const { message: a } = X("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
        throw new Error(a);
      }
    }, this.isValidPing = async (n) => {
      if (!Ot(n)) {
        const { message: i } = X("MISSING_OR_INVALID", `ping() params: ${n}`);
        throw new Error(i);
      }
      const { topic: a } = n;
      await this.isValidPairingTopic(a);
    }, this.isValidDisconnect = async (n) => {
      if (!Ot(n)) {
        const { message: i } = X("MISSING_OR_INVALID", `disconnect() params: ${n}`);
        throw new Error(i);
      }
      const { topic: a } = n;
      await this.isValidPairingTopic(a);
    }, this.isValidPairingTopic = async (n) => {
      if (!lt(n, !1)) {
        const { message: a } = X("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
        throw new Error(a);
      }
      if (!this.pairings.keys.includes(n)) {
        const { message: a } = X("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
        throw new Error(a);
      }
      if ($r(this.pairings.get(n).expiry)) {
        await this.deletePairing(n);
        const { message: a } = X("EXPIRED", `pairing topic: ${n}`);
        throw new Error(a);
      }
    }, this.core = t, this.logger = xe.generateChildLogger(r, this.name), this.pairings = new vs(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = X("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(He.message, async (t) => {
      const { topic: r, message: n } = t;
      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n)))
        return;
      const a = await this.core.crypto.decode(r, n);
      Fo(a) ? (this.core.history.set(r, a), this.onRelayEventRequest({ topic: r, payload: a })) : ms(a) && (await this.core.history.resolve(a), this.onRelayEventResponse({ topic: r, payload: a }));
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(Gt.expired, async (t) => {
      const { topic: r } = Su(t.target);
      r && this.pairings.keys.includes(r) && (await this.deletePairing(r, !0), this.events.emit("pairing_expire", { topic: r }));
    });
  }
}
class Y9 extends s6 {
  constructor(t, r) {
    super(t, r), this.core = t, this.logger = r, this.records = /* @__PURE__ */ new Map(), this.events = new zt.EventEmitter(), this.name = A9, this.version = I9, this.cached = [], this.initialized = !1, this.storagePrefix = Kr, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (n, a, i) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: n, request: a, chainId: i }), this.records.has(a.id))
        return;
      const c = { id: a.id, topic: n, request: { method: a.method, params: a.params || null }, chainId: i };
      this.records.set(c.id, c), this.events.emit(ir.created, c);
    }, this.resolve = async (n) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: n }), !this.records.has(n.id))
        return;
      const a = await this.getRecord(n.id);
      typeof a.response > "u" && (a.response = er(n) ? { error: n.error } : { result: n.result }, this.records.set(a.id, a), this.events.emit(ir.updated, a));
    }, this.get = async (n, a) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: n, id: a }), await this.getRecord(a)), this.delete = (n, a) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: a }), this.values.forEach((i) => {
        if (i.topic === n) {
          if (typeof a < "u" && i.id !== a)
            return;
          this.records.delete(i.id), this.events.emit(ir.deleted, i);
        }
      });
    }, this.exists = async (n, a) => (this.isInitialized(), this.records.has(a) ? (await this.getRecord(a)).topic === n : !1), this.on = (n, a) => {
      this.events.on(n, a);
    }, this.once = (n, a) => {
      this.events.once(n, a);
    }, this.off = (n, a) => {
      this.events.off(n, a);
    }, this.removeListener = (n, a) => {
      this.events.removeListener(n, a);
    }, this.logger = xe.generateChildLogger(r, this.name);
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const t = [];
    return this.values.forEach((r) => {
      if (typeof r.response < "u")
        return;
      const n = { topic: r.topic, request: _s(r.request.method, r.request.params, r.id), chainId: r.chainId };
      return t.push(n);
    }), t;
  }
  async setJsonRpcRecords(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(t) {
    this.isInitialized();
    const r = this.records.get(t);
    if (!r) {
      const { message: n } = X("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(ir.sync);
  }
  async restore() {
    try {
      const t = await this.getJsonRpcRecords();
      if (typeof t > "u" || !t.length)
        return;
      if (this.records.size) {
        const { message: r } = X("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = t, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(t);
    }
  }
  registerEventListeners() {
    this.events.on(ir.created, (t) => {
      const r = ir.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: t }), this.persist();
    }), this.events.on(ir.updated, (t) => {
      const r = ir.updated;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: t }), this.persist();
    }), this.events.on(ir.deleted, (t) => {
      const r = ir.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: t }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = X("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class X9 extends u6 {
  constructor(t, r) {
    super(t, r), this.core = t, this.logger = r, this.expirations = /* @__PURE__ */ new Map(), this.events = new zt.EventEmitter(), this.name = C9, this.version = T9, this.cached = [], this.initialized = !1, this.storagePrefix = Kr, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (n) => {
      try {
        const a = this.formatTarget(n);
        return typeof this.getExpiration(a) < "u";
      } catch {
        return !1;
      }
    }, this.set = (n, a) => {
      this.isInitialized();
      const i = this.formatTarget(n), c = { target: i, expiry: a };
      this.expirations.set(i, c), this.checkExpiry(i, c), this.events.emit(Gt.created, { target: i, expiration: c });
    }, this.get = (n) => {
      this.isInitialized();
      const a = this.formatTarget(n);
      return this.getExpiration(a);
    }, this.del = (n) => {
      if (this.isInitialized(), this.has(n)) {
        const a = this.formatTarget(n), i = this.getExpiration(a);
        this.expirations.delete(a), this.events.emit(Gt.deleted, { target: a, expiration: i });
      }
    }, this.on = (n, a) => {
      this.events.on(n, a);
    }, this.once = (n, a) => {
      this.events.once(n, a);
    }, this.off = (n, a) => {
      this.events.off(n, a);
    }, this.removeListener = (n, a) => {
      this.events.removeListener(n, a);
    }, this.logger = xe.generateChildLogger(r, this.name);
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(t) {
    if (typeof t == "string")
      return m8(t);
    if (typeof t == "number")
      return E8(t);
    const { message: r } = X("UNKNOWN_TYPE", `Target type: ${typeof t}`);
    throw new Error(r);
  }
  async setExpirations(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(Gt.sync);
  }
  async restore() {
    try {
      const t = await this.getExpirations();
      if (typeof t > "u" || !t.length)
        return;
      if (this.expirations.size) {
        const { message: r } = X("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = t, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(t);
    }
  }
  getExpiration(t) {
    const r = this.expirations.get(t);
    if (!r) {
      const { message: n } = X("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw this.logger.error(n), new Error(n);
    }
    return r;
  }
  checkExpiry(t, r) {
    const { expiry: n } = r;
    re.toMiliseconds(n) - Date.now() <= 0 && this.expire(t, r);
  }
  expire(t, r) {
    this.expirations.delete(t), this.events.emit(Gt.expired, { target: t, expiration: r });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((t, r) => this.checkExpiry(r, t));
  }
  registerEventListeners() {
    this.core.heartbeat.on(ti.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(Gt.created, (t) => {
      const r = Gt.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: t }), this.persist();
    }), this.events.on(Gt.expired, (t) => {
      const r = Gt.expired;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: t }), this.persist();
    }), this.events.on(Gt.deleted, (t) => {
      const r = Gt.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: t }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = X("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class J9 extends h6 {
  constructor(t, r) {
    super(t, r), this.projectId = t, this.logger = r, this.name = Js, this.initialized = !1, this.init = async (n) => {
      wu() || !Ro() || (this.verifyUrl = n?.verifyUrl || n0, await this.createIframe());
    }, this.register = async (n) => {
      var a;
      this.initialized || await this.init(), this.iframe && ((a = this.iframe.contentWindow) == null || a.postMessage(n.attestationId, this.verifyUrl), this.logger.info(`postMessage sent: ${n.attestationId} ${this.verifyUrl}`));
    }, this.resolve = async (n) => {
      var a;
      if (this.isDevEnv)
        return "";
      this.logger.info(`resolving attestation: ${n.attestationId}`);
      const i = this.startAbortTimer(re.FIVE_SECONDS), c = await fetch(`${this.verifyUrl}/attestation/${n.attestationId}`, { signal: this.abortController.signal });
      return clearTimeout(i), c.status === 200 ? (a = await c.json()) == null ? void 0 : a.origin : "";
    }, this.createIframe = async () => {
      try {
        await Promise.race([new Promise((n, a) => {
          if (document.getElementById(Js))
            return n();
          const i = document.createElement("iframe");
          i.setAttribute("id", Js), i.setAttribute("src", `${this.verifyUrl}/${this.projectId}`), i.style.display = "none", i.addEventListener("load", () => {
            this.initialized = !0, n();
          }), i.addEventListener("error", (c) => {
            a(c);
          }), document.body.append(i), this.iframe = i;
        }), new Promise((n) => {
          setTimeout(() => n("iframe load timeout"), re.toMiliseconds(re.ONE_SECOND / 2));
        })]);
      } catch (n) {
        this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(n);
      }
    }, this.logger = xe.generateChildLogger(r, this.name), this.verifyUrl = n0, this.abortController = new AbortController(), this.isDevEnv = No() && process.env.IS_VITEST;
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  startAbortTimer(t) {
    return setTimeout(() => this.abortController.abort(), re.toMiliseconds(t));
  }
}
var Q9 = Object.defineProperty, l0 = Object.getOwnPropertySymbols, ep = Object.prototype.hasOwnProperty, tp = Object.prototype.propertyIsEnumerable, u0 = (e, t, r) => t in e ? Q9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, h0 = (e, t) => {
  for (var r in t || (t = {}))
    ep.call(t, r) && u0(e, r, t[r]);
  if (l0)
    for (var r of l0(t))
      tp.call(t, r) && u0(e, r, t[r]);
  return e;
};
let rp = class Wu extends i6 {
  constructor(t) {
    super(t), this.protocol = qu, this.version = r9, this.name = $o, this.events = new zt.EventEmitter(), this.initialized = !1, this.on = (n, a) => this.events.on(n, a), this.once = (n, a) => this.events.once(n, a), this.off = (n, a) => this.events.off(n, a), this.removeListener = (n, a) => this.events.removeListener(n, a), this.projectId = t?.projectId, this.relayUrl = t?.relayUrl || Gu;
    const r = typeof t?.logger < "u" && typeof t?.logger != "string" ? t.logger : xe.pino(xe.getDefaultLoggerOptions({ level: t?.logger || n9.logger }));
    this.logger = xe.generateChildLogger(r, this.name), this.heartbeat = new ti.HeartBeat(), this.crypto = new N9(this, this.logger, t?.keychain), this.history = new Y9(this, this.logger), this.expirer = new X9(this, this.logger), this.storage = t != null && t.storage ? t.storage : new z2(h0(h0({}, a9), t?.storageOptions)), this.relayer = new q9({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Z9(this, this.logger), this.verify = new J9(this.projectId || "", this.logger);
  }
  static async init(t) {
    const r = new Wu(t);
    await r.initialize();
    const n = await r.crypto.getClientId();
    return await r.storage.setItem(m9, n), r;
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (t) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, t), this.logger.error(t.message), t;
    }
  }
};
const np = rp, Zu = "wc", Yu = 2, Xu = "client", Bo = `${Zu}@${Yu}:${Xu}:`, ec = { name: Xu, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.com" }, ap = "WALLETCONNECT_DEEPLINK_CHOICE", ip = "proposal", sp = "Proposal expired", cp = "session", Ii = re.SEVEN_DAYS, op = "engine", Da = { wc_sessionPropose: { req: { ttl: re.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: re.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: re.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: re.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: re.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: re.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: re.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: re.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: re.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: re.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: re.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: re.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: re.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: re.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: re.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: re.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, tc = { min: re.FIVE_MINUTES, max: re.SEVEN_DAYS }, fp = "request", dp = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var lp = Object.defineProperty, up = Object.defineProperties, hp = Object.getOwnPropertyDescriptors, b0 = Object.getOwnPropertySymbols, bp = Object.prototype.hasOwnProperty, pp = Object.prototype.propertyIsEnumerable, p0 = (e, t, r) => t in e ? lp(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Kt = (e, t) => {
  for (var r in t || (t = {}))
    bp.call(t, r) && p0(e, r, t[r]);
  if (b0)
    for (var r of b0(t))
      pp.call(t, r) && p0(e, r, t[r]);
  return e;
}, rc = (e, t) => up(e, hp(t));
class gp extends p6 {
  constructor(t) {
    super(t), this.name = op, this.events = new Pl(), this.initialized = !1, this.ignoredPayloadTypes = [Cn], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({ methods: Object.keys(Da) }), this.initialized = !0);
    }, this.connect = async (r) => {
      this.isInitialized();
      const n = rc(Kt({}, r), { requiredNamespaces: r.requiredNamespaces || {}, optionalNamespaces: r.optionalNamespaces || {} });
      await this.isValidConnect(n);
      const { pairingTopic: a, requiredNamespaces: i, optionalNamespaces: c, sessionProperties: s, relays: d } = n;
      let f = a, l, p = !1;
      if (f && (p = this.client.core.pairing.pairings.get(f).active), !f || !p) {
        const { topic: C, uri: _ } = await this.client.core.pairing.create();
        f = C, l = _;
      }
      const w = await this.client.core.crypto.generateKeyPair(), g = Kt({ requiredNamespaces: i, optionalNamespaces: c, relays: d ?? [{ protocol: Ku }], proposer: { publicKey: w, metadata: this.client.metadata } }, s && { sessionProperties: s }), { reject: m, resolve: S, done: I } = Fn(re.FIVE_MINUTES, sp);
      if (this.events.once(Ze("session_connect"), async ({ error: C, session: _ }) => {
        if (C)
          m(C);
        else if (_) {
          _.self.publicKey = w;
          const D = rc(Kt({}, _), { requiredNamespaces: _.requiredNamespaces, optionalNamespaces: _.optionalNamespaces });
          await this.client.session.set(_.topic, D), await this.setExpiry(_.topic, _.expiry), f && await this.client.core.pairing.updateMetadata({ topic: f, metadata: _.peer.metadata }), S(D);
        }
      }), !f) {
        const { message: C } = X("NO_MATCHING_KEY", `connect() pairing topic: ${f}`);
        throw new Error(C);
      }
      const N = await this.sendRequest(f, "wc_sessionPropose", g), x = fr(re.FIVE_MINUTES);
      return await this.setProposal(N, Kt({ id: N, expiry: x }, g)), { uri: l, approval: I };
    }, this.pair = async (r) => (this.isInitialized(), await this.client.core.pairing.pair(r)), this.approve = async (r) => {
      this.isInitialized(), await this.isValidApprove(r);
      const { id: n, relayProtocol: a, namespaces: i, sessionProperties: c } = r, s = this.client.proposal.get(n);
      let { pairingTopic: d, proposer: f, requiredNamespaces: l, optionalNamespaces: p } = s;
      d = d || "", La(l) || (l = U8(i, "approve()"));
      const w = await this.client.core.crypto.generateKeyPair(), g = f.publicKey, m = await this.client.core.crypto.generateSharedKey(w, g);
      d && n && (await this.client.core.pairing.updateMetadata({ topic: d, metadata: f.metadata }), await this.sendResult(n, d, { relay: { protocol: a ?? "irn" }, responderPublicKey: w }), await this.client.proposal.delete(n, Qe("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: d }));
      const S = Kt({ relay: { protocol: a ?? "irn" }, namespaces: i, requiredNamespaces: l, optionalNamespaces: p, pairingTopic: d, controller: { publicKey: w, metadata: this.client.metadata }, expiry: fr(Ii) }, c && { sessionProperties: c });
      await this.client.core.relayer.subscribe(m), await this.sendRequest(m, "wc_sessionSettle", S);
      const I = rc(Kt({}, S), { topic: m, pairingTopic: d, acknowledged: !1, self: S.controller, peer: { publicKey: f.publicKey, metadata: f.metadata }, controller: w });
      return await this.client.session.set(m, I), await this.setExpiry(m, fr(Ii)), { topic: m, acknowledged: () => new Promise((N) => setTimeout(() => N(this.client.session.get(m)), 500)) };
    }, this.reject = async (r) => {
      this.isInitialized(), await this.isValidReject(r);
      const { id: n, reason: a } = r, { pairingTopic: i } = this.client.proposal.get(n);
      i && (await this.sendError(n, i, a), await this.client.proposal.delete(n, Qe("USER_DISCONNECTED")));
    }, this.update = async (r) => {
      this.isInitialized(), await this.isValidUpdate(r);
      const { topic: n, namespaces: a } = r, i = await this.sendRequest(n, "wc_sessionUpdate", { namespaces: a }), { done: c, resolve: s, reject: d } = Fn();
      return this.events.once(Ze("session_update", i), ({ error: f }) => {
        f ? d(f) : s();
      }), await this.client.session.update(n, { namespaces: a }), { acknowledged: c };
    }, this.extend = async (r) => {
      this.isInitialized(), await this.isValidExtend(r);
      const { topic: n } = r, a = await this.sendRequest(n, "wc_sessionExtend", {}), { done: i, resolve: c, reject: s } = Fn();
      return this.events.once(Ze("session_extend", a), ({ error: d }) => {
        d ? s(d) : c();
      }), await this.setExpiry(n, fr(Ii)), { acknowledged: i };
    }, this.request = async (r) => {
      this.isInitialized(), await this.isValidRequest(r);
      const { chainId: n, request: a, topic: i, expiry: c } = r, s = await this.sendRequest(i, "wc_sessionRequest", { request: a, chainId: n }, c), { done: d, resolve: f, reject: l } = Fn(c);
      this.events.once(Ze("session_request", s), ({ error: w, result: g }) => {
        w ? l(w) : f(g);
      }), this.client.events.emit("session_request_sent", { topic: i, request: a, chainId: n, id: s });
      const p = await this.client.core.storage.getItem(ap);
      return v8({ id: s, topic: i, wcDeepLink: p }), await d();
    }, this.respond = async (r) => {
      this.isInitialized(), await this.isValidRespond(r);
      const { topic: n, response: a } = r, { id: i } = a;
      Dr(a) ? await this.sendResult(i, n, a.result) : er(a) && await this.sendError(i, n, a.error), this.deletePendingSessionRequest(r.response.id, { message: "fulfilled", code: 0 });
    }, this.ping = async (r) => {
      this.isInitialized(), await this.isValidPing(r);
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) {
        const a = await this.sendRequest(n, "wc_sessionPing", {}), { done: i, resolve: c, reject: s } = Fn();
        this.events.once(Ze("session_ping", a), ({ error: d }) => {
          d ? s(d) : c();
        }), await i();
      } else
        this.client.core.pairing.pairings.keys.includes(n) && await this.client.core.pairing.ping({ topic: n });
    }, this.emit = async (r) => {
      this.isInitialized(), await this.isValidEmit(r);
      const { topic: n, event: a, chainId: i } = r;
      await this.sendRequest(n, "wc_sessionEvent", { event: a, chainId: i });
    }, this.disconnect = async (r) => {
      this.isInitialized(), await this.isValidDisconnect(r);
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) {
        const a = Uo().toString();
        let i;
        const c = (s) => {
          s?.id.toString() === a && (this.client.core.relayer.events.removeListener(He.message_ack, c), i());
        };
        await Promise.all([new Promise((s) => {
          i = s, this.client.core.relayer.on(He.message_ack, c);
        }), this.sendRequest(n, "wc_sessionDelete", Qe("USER_DISCONNECTED"), void 0, a)]), await this.deleteSession(n);
      } else
        await this.client.core.pairing.disconnect({ topic: n });
    }, this.find = (r) => (this.isInitialized(), this.client.session.getAll().filter((n) => B8(n, r))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (r) => {
      try {
        const n = this.client.core.pairing.pairings.get(r.pairingTopic), a = this.client.core.pairing.pairings.getAll().filter((i) => {
          var c, s;
          return ((c = i.peerMetadata) == null ? void 0 : c.url) && ((s = i.peerMetadata) == null ? void 0 : s.url) === r.peer.metadata.url && i.topic && i.topic !== n.topic;
        });
        if (a.length === 0)
          return;
        this.client.logger.info(`Cleaning up ${a.length} duplicate pairing(s)`), await Promise.all(a.map((i) => this.client.core.pairing.disconnect({ topic: i.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.deleteSession = async (r, n) => {
      const { self: a } = this.client.session.get(r);
      await this.client.core.relayer.unsubscribe(r), this.client.session.delete(r, Qe("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(a.publicKey) && await this.client.core.crypto.deleteKeyPair(a.publicKey), this.client.core.crypto.keychain.has(r) && await this.client.core.crypto.deleteSymKey(r), n || this.client.core.expirer.del(r);
    }, this.deleteProposal = async (r, n) => {
      await Promise.all([this.client.proposal.delete(r, Qe("USER_DISCONNECTED")), n ? Promise.resolve() : this.client.core.expirer.del(r)]);
    }, this.deletePendingSessionRequest = async (r, n, a = !1) => {
      await Promise.all([this.client.pendingRequest.delete(r, n), a ? Promise.resolve() : this.client.core.expirer.del(r)]);
    }, this.setExpiry = async (r, n) => {
      this.client.session.keys.includes(r) && await this.client.session.update(r, { expiry: n }), this.client.core.expirer.set(r, n);
    }, this.setProposal = async (r, n) => {
      await this.client.proposal.set(r, n), this.client.core.expirer.set(r, n.expiry);
    }, this.setPendingSessionRequest = async (r) => {
      const n = Da.wc_sessionRequest.req.ttl, { id: a, topic: i, params: c } = r;
      await this.client.pendingRequest.set(a, { id: a, topic: i, params: c }), n && this.client.core.expirer.set(a, fr(n));
    }, this.sendRequest = async (r, n, a, i, c) => {
      const s = _s(n, a);
      if (Ro() && dp.includes(n)) {
        const l = Vn(JSON.stringify(s));
        await this.client.core.verify.register({ attestationId: l });
      }
      const d = await this.client.core.crypto.encode(r, s), f = Da[n].req;
      return i && (f.ttl = i), c && (f.id = c), this.client.core.history.set(r, s), this.client.core.relayer.publish(r, d, f), s.id;
    }, this.sendResult = async (r, n, a) => {
      const i = ys(r, a), c = await this.client.core.crypto.encode(n, i), s = await this.client.core.history.get(n, r), d = Da[s.request.method].res;
      this.client.core.relayer.publish(n, c, d), await this.client.core.history.resolve(i);
    }, this.sendError = async (r, n, a) => {
      const i = ws(r, a), c = await this.client.core.crypto.encode(n, i), s = await this.client.core.history.get(n, r), d = Da[s.request.method].res;
      this.client.core.relayer.publish(n, c, d), await this.client.core.history.resolve(i);
    }, this.cleanup = async () => {
      const r = [], n = [];
      this.client.session.getAll().forEach((a) => {
        $r(a.expiry) && r.push(a.topic);
      }), this.client.proposal.getAll().forEach((a) => {
        $r(a.expiry) && n.push(a.id);
      }), await Promise.all([...r.map((a) => this.deleteSession(a)), ...n.map((a) => this.deleteProposal(a))]);
    }, this.onRelayEventRequest = (r) => {
      const { topic: n, payload: a } = r, i = a.method;
      switch (i) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(n, a);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(n, a);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(n, a);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(n, a);
        case "wc_sessionPing":
          return this.onSessionPingRequest(n, a);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(n, a);
        case "wc_sessionRequest":
          return this.onSessionRequest(n, a);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(n, a);
        default:
          return this.client.logger.info(`Unsupported request method ${i}`);
      }
    }, this.onRelayEventResponse = async (r) => {
      const { topic: n, payload: a } = r, i = (await this.client.core.history.get(n, a.id)).request.method;
      switch (i) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(n, a);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(n, a);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(n, a);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(n, a);
        case "wc_sessionPing":
          return this.onSessionPingResponse(n, a);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(n, a);
        default:
          return this.client.logger.info(`Unsupported response method ${i}`);
      }
    }, this.onRelayEventUnknownPayload = (r) => {
      const { topic: n } = r, { message: a } = X("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(a);
    }, this.onSessionProposeRequest = async (r, n) => {
      const { params: a, id: i } = n;
      try {
        this.isValidConnect(Kt({}, n.params));
        const c = fr(re.FIVE_MINUTES), s = Kt({ id: i, pairingTopic: r, expiry: c }, a);
        await this.setProposal(i, s);
        const d = Vn(JSON.stringify(n)), f = await this.getVerifyContext(d, s.proposer.metadata);
        this.client.events.emit("session_proposal", { id: i, params: s, verifyContext: f });
      } catch (c) {
        await this.sendError(i, r, c), this.client.logger.error(c);
      }
    }, this.onSessionProposeResponse = async (r, n) => {
      const { id: a } = n;
      if (Dr(n)) {
        const { result: i } = n;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i });
        const c = this.client.proposal.get(a);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: c });
        const s = c.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: s });
        const d = i.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: d });
        const f = await this.client.core.crypto.generateSharedKey(s, d);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: f });
        const l = await this.client.core.relayer.subscribe(f);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: l }), await this.client.core.pairing.activate({ topic: r });
      } else
        er(n) && (await this.client.proposal.delete(a, Qe("USER_DISCONNECTED")), this.events.emit(Ze("session_connect"), { error: n.error }));
    }, this.onSessionSettleRequest = async (r, n) => {
      const { id: a, params: i } = n;
      try {
        this.isValidSessionSettleRequest(i);
        const { relay: c, controller: s, expiry: d, namespaces: f, requiredNamespaces: l, optionalNamespaces: p, sessionProperties: w, pairingTopic: g } = n.params, m = Kt({ topic: r, relay: c, expiry: d, namespaces: f, acknowledged: !0, pairingTopic: g, requiredNamespaces: l, optionalNamespaces: p, controller: s.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: s.publicKey, metadata: s.metadata } }, w && { sessionProperties: w });
        await this.sendResult(n.id, r, !0), this.events.emit(Ze("session_connect"), { session: m }), this.cleanupDuplicatePairings(m);
      } catch (c) {
        await this.sendError(a, r, c), this.client.logger.error(c);
      }
    }, this.onSessionSettleResponse = async (r, n) => {
      const { id: a } = n;
      Dr(n) ? (await this.client.session.update(r, { acknowledged: !0 }), this.events.emit(Ze("session_approve", a), {})) : er(n) && (await this.client.session.delete(r, Qe("USER_DISCONNECTED")), this.events.emit(Ze("session_approve", a), { error: n.error }));
    }, this.onSessionUpdateRequest = async (r, n) => {
      const { params: a, id: i } = n;
      try {
        this.isValidUpdate(Kt({ topic: r }, a)), await this.client.session.update(r, { namespaces: a.namespaces }), await this.sendResult(i, r, !0), this.client.events.emit("session_update", { id: i, topic: r, params: a });
      } catch (c) {
        await this.sendError(i, r, c), this.client.logger.error(c);
      }
    }, this.onSessionUpdateResponse = (r, n) => {
      const { id: a } = n;
      Dr(n) ? this.events.emit(Ze("session_update", a), {}) : er(n) && this.events.emit(Ze("session_update", a), { error: n.error });
    }, this.onSessionExtendRequest = async (r, n) => {
      const { id: a } = n;
      try {
        this.isValidExtend({ topic: r }), await this.setExpiry(r, fr(Ii)), await this.sendResult(a, r, !0), this.client.events.emit("session_extend", { id: a, topic: r });
      } catch (i) {
        await this.sendError(a, r, i), this.client.logger.error(i);
      }
    }, this.onSessionExtendResponse = (r, n) => {
      const { id: a } = n;
      Dr(n) ? this.events.emit(Ze("session_extend", a), {}) : er(n) && this.events.emit(Ze("session_extend", a), { error: n.error });
    }, this.onSessionPingRequest = async (r, n) => {
      const { id: a } = n;
      try {
        this.isValidPing({ topic: r }), await this.sendResult(a, r, !0), this.client.events.emit("session_ping", { id: a, topic: r });
      } catch (i) {
        await this.sendError(a, r, i), this.client.logger.error(i);
      }
    }, this.onSessionPingResponse = (r, n) => {
      const { id: a } = n;
      setTimeout(() => {
        Dr(n) ? this.events.emit(Ze("session_ping", a), {}) : er(n) && this.events.emit(Ze("session_ping", a), { error: n.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (r, n) => {
      const { id: a } = n;
      try {
        this.isValidDisconnect({ topic: r, reason: n.params }), await Promise.all([new Promise((i) => {
          this.client.core.relayer.once(He.publish, async () => {
            i(await this.deleteSession(r));
          });
        }), this.sendResult(a, r, !0)]), this.client.events.emit("session_delete", { id: a, topic: r });
      } catch (i) {
        this.client.logger.error(i);
      }
    }, this.onSessionRequest = async (r, n) => {
      const { id: a, params: i } = n;
      try {
        this.isValidRequest(Kt({ topic: r }, i)), await this.setPendingSessionRequest({ id: a, topic: r, params: i });
        const c = Vn(JSON.stringify(n)), s = this.client.session.get(r), d = await this.getVerifyContext(c, s.peer.metadata);
        this.client.events.emit("session_request", { id: a, topic: r, params: i, verifyContext: d });
      } catch (c) {
        await this.sendError(a, r, c), this.client.logger.error(c);
      }
    }, this.onSessionRequestResponse = (r, n) => {
      const { id: a } = n;
      Dr(n) ? this.events.emit(Ze("session_request", a), { result: n.result }) : er(n) && this.events.emit(Ze("session_request", a), { error: n.error });
    }, this.onSessionEventRequest = async (r, n) => {
      const { id: a, params: i } = n;
      try {
        this.isValidEmit(Kt({ topic: r }, i)), this.client.events.emit("session_event", { id: a, topic: r, params: i });
      } catch (c) {
        await this.sendError(a, r, c), this.client.logger.error(c);
      }
    }, this.isValidConnect = async (r) => {
      if (!Ot(r)) {
        const { message: d } = X("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
        throw new Error(d);
      }
      const { pairingTopic: n, requiredNamespaces: a, optionalNamespaces: i, sessionProperties: c, relays: s } = r;
      if (At(n) || await this.isValidPairingTopic(n), !X8(s, !0)) {
        const { message: d } = X("MISSING_OR_INVALID", `connect() relays: ${s}`);
        throw new Error(d);
      }
      !At(a) && La(a) !== 0 && this.validateNamespaces(a, "requiredNamespaces"), !At(i) && La(i) !== 0 && this.validateNamespaces(i, "optionalNamespaces"), At(c) || this.validateSessionProps(c, "sessionProperties");
    }, this.validateNamespaces = (r, n) => {
      const a = Y8(r, "connect()", n);
      if (a)
        throw new Error(a.message);
    }, this.isValidApprove = async (r) => {
      if (!Ot(r))
        throw new Error(X("MISSING_OR_INVALID", `approve() params: ${r}`).message);
      const { id: n, namespaces: a, relayProtocol: i, sessionProperties: c } = r;
      await this.isValidProposalId(n);
      const s = this.client.proposal.get(n), d = Hi(a, "approve()");
      if (d)
        throw new Error(d.message);
      const f = jd(s.requiredNamespaces, a, "approve()");
      if (f)
        throw new Error(f.message);
      if (!lt(i, !0)) {
        const { message: l } = X("MISSING_OR_INVALID", `approve() relayProtocol: ${i}`);
        throw new Error(l);
      }
      At(c) || this.validateSessionProps(c, "sessionProperties");
    }, this.isValidReject = async (r) => {
      if (!Ot(r)) {
        const { message: i } = X("MISSING_OR_INVALID", `reject() params: ${r}`);
        throw new Error(i);
      }
      const { id: n, reason: a } = r;
      if (await this.isValidProposalId(n), !Q8(a)) {
        const { message: i } = X("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(a)}`);
        throw new Error(i);
      }
    }, this.isValidSessionSettleRequest = (r) => {
      if (!Ot(r)) {
        const { message: f } = X("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
        throw new Error(f);
      }
      const { relay: n, controller: a, namespaces: i, expiry: c } = r;
      if (!Au(n)) {
        const { message: f } = X("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(f);
      }
      const s = V8(a, "onSessionSettleRequest()");
      if (s)
        throw new Error(s.message);
      const d = Hi(i, "onSessionSettleRequest()");
      if (d)
        throw new Error(d.message);
      if ($r(c)) {
        const { message: f } = X("EXPIRED", "onSessionSettleRequest()");
        throw new Error(f);
      }
    }, this.isValidUpdate = async (r) => {
      if (!Ot(r)) {
        const { message: d } = X("MISSING_OR_INVALID", `update() params: ${r}`);
        throw new Error(d);
      }
      const { topic: n, namespaces: a } = r;
      await this.isValidSessionTopic(n);
      const i = this.client.session.get(n), c = Hi(a, "update()");
      if (c)
        throw new Error(c.message);
      const s = jd(i.requiredNamespaces, a, "update()");
      if (s)
        throw new Error(s.message);
    }, this.isValidExtend = async (r) => {
      if (!Ot(r)) {
        const { message: a } = X("MISSING_OR_INVALID", `extend() params: ${r}`);
        throw new Error(a);
      }
      const { topic: n } = r;
      await this.isValidSessionTopic(n);
    }, this.isValidRequest = async (r) => {
      if (!Ot(r)) {
        const { message: d } = X("MISSING_OR_INVALID", `request() params: ${r}`);
        throw new Error(d);
      }
      const { topic: n, request: a, chainId: i, expiry: c } = r;
      await this.isValidSessionTopic(n);
      const { namespaces: s } = this.client.session.get(n);
      if (!zd(s, i)) {
        const { message: d } = X("MISSING_OR_INVALID", `request() chainId: ${i}`);
        throw new Error(d);
      }
      if (!e4(a)) {
        const { message: d } = X("MISSING_OR_INVALID", `request() ${JSON.stringify(a)}`);
        throw new Error(d);
      }
      if (!n4(s, i, a.method)) {
        const { message: d } = X("MISSING_OR_INVALID", `request() method: ${a.method}`);
        throw new Error(d);
      }
      if (c && !c4(c, tc)) {
        const { message: d } = X("MISSING_OR_INVALID", `request() expiry: ${c}. Expiry must be a number (in seconds) between ${tc.min} and ${tc.max}`);
        throw new Error(d);
      }
    }, this.isValidRespond = async (r) => {
      if (!Ot(r)) {
        const { message: i } = X("MISSING_OR_INVALID", `respond() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n, response: a } = r;
      if (await this.isValidSessionTopic(n), !t4(a)) {
        const { message: i } = X("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(a)}`);
        throw new Error(i);
      }
    }, this.isValidPing = async (r) => {
      if (!Ot(r)) {
        const { message: a } = X("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(a);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidEmit = async (r) => {
      if (!Ot(r)) {
        const { message: s } = X("MISSING_OR_INVALID", `emit() params: ${r}`);
        throw new Error(s);
      }
      const { topic: n, event: a, chainId: i } = r;
      await this.isValidSessionTopic(n);
      const { namespaces: c } = this.client.session.get(n);
      if (!zd(c, i)) {
        const { message: s } = X("MISSING_OR_INVALID", `emit() chainId: ${i}`);
        throw new Error(s);
      }
      if (!r4(a)) {
        const { message: s } = X("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(a)}`);
        throw new Error(s);
      }
      if (!a4(c, i, a.name)) {
        const { message: s } = X("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(a)}`);
        throw new Error(s);
      }
    }, this.isValidDisconnect = async (r) => {
      if (!Ot(r)) {
        const { message: a } = X("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(a);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.getVerifyContext = async (r, n) => {
      const a = { verified: { verifyUrl: n.verifyUrl || "", validation: "UNKNOWN", origin: n.url || "" } };
      try {
        const i = await this.client.core.verify.resolve({ attestationId: r, verifyUrl: n.verifyUrl });
        i && (a.verified.origin = i, a.verified.validation = i === n.url ? "VALID" : "INVALID");
      } catch (i) {
        this.client.logger.error(i);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(a)}`), a;
    }, this.validateSessionProps = (r, n) => {
      Object.values(r).forEach((a) => {
        if (!lt(a, !1)) {
          const { message: i } = X("MISSING_OR_INVALID", `${n} must be in Record<string, string> format. Received: ${JSON.stringify(a)}`);
          throw new Error(i);
        }
      });
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = X("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(He.message, async (t) => {
      const { topic: r, message: n } = t;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(n)))
        return;
      const a = await this.client.core.crypto.decode(r, n);
      Fo(a) ? (this.client.core.history.set(r, a), this.onRelayEventRequest({ topic: r, payload: a })) : ms(a) ? (await this.client.core.history.resolve(a), this.onRelayEventResponse({ topic: r, payload: a })) : this.onRelayEventUnknownPayload({ topic: r, payload: a });
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(Gt.expired, async (t) => {
      const { topic: r, id: n } = Su(t.target);
      if (n && this.client.pendingRequest.keys.includes(n))
        return await this.deletePendingSessionRequest(n, X("EXPIRED"), !0);
      r ? this.client.session.keys.includes(r) && (await this.deleteSession(r, !0), this.client.events.emit("session_expire", { topic: r })) : n && (await this.deleteProposal(n, !0), this.client.events.emit("proposal_expire", { id: n }));
    });
  }
  isValidPairingTopic(t) {
    if (!lt(t, !1)) {
      const { message: r } = X("MISSING_OR_INVALID", `pairing topic should be a string: ${t}`);
      throw new Error(r);
    }
    if (!this.client.core.pairing.pairings.keys.includes(t)) {
      const { message: r } = X("NO_MATCHING_KEY", `pairing topic doesn't exist: ${t}`);
      throw new Error(r);
    }
    if ($r(this.client.core.pairing.pairings.get(t).expiry)) {
      const { message: r } = X("EXPIRED", `pairing topic: ${t}`);
      throw new Error(r);
    }
  }
  async isValidSessionTopic(t) {
    if (!lt(t, !1)) {
      const { message: r } = X("MISSING_OR_INVALID", `session topic should be a string: ${t}`);
      throw new Error(r);
    }
    if (!this.client.session.keys.includes(t)) {
      const { message: r } = X("NO_MATCHING_KEY", `session topic doesn't exist: ${t}`);
      throw new Error(r);
    }
    if ($r(this.client.session.get(t).expiry)) {
      await this.deleteSession(t);
      const { message: r } = X("EXPIRED", `session topic: ${t}`);
      throw new Error(r);
    }
  }
  async isValidSessionOrPairingTopic(t) {
    if (this.client.session.keys.includes(t))
      await this.isValidSessionTopic(t);
    else if (this.client.core.pairing.pairings.keys.includes(t))
      this.isValidPairingTopic(t);
    else if (lt(t, !1)) {
      const { message: r } = X("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${t}`);
      throw new Error(r);
    } else {
      const { message: r } = X("MISSING_OR_INVALID", `session or pairing topic should be a string: ${t}`);
      throw new Error(r);
    }
  }
  async isValidProposalId(t) {
    if (!J8(t)) {
      const { message: r } = X("MISSING_OR_INVALID", `proposal id should be a number: ${t}`);
      throw new Error(r);
    }
    if (!this.client.proposal.keys.includes(t)) {
      const { message: r } = X("NO_MATCHING_KEY", `proposal id doesn't exist: ${t}`);
      throw new Error(r);
    }
    if ($r(this.client.proposal.get(t).expiry)) {
      await this.deleteProposal(t);
      const { message: r } = X("EXPIRED", `proposal id: ${t}`);
      throw new Error(r);
    }
  }
}
class _p extends vs {
  constructor(t, r) {
    super(t, r, ip, Bo), this.core = t, this.logger = r;
  }
}
class yp extends vs {
  constructor(t, r) {
    super(t, r, cp, Bo), this.core = t, this.logger = r;
  }
}
class wp extends vs {
  constructor(t, r) {
    super(t, r, fp, Bo, (n) => n.id), this.core = t, this.logger = r;
  }
}
class xs extends b6 {
  constructor(t) {
    super(t), this.protocol = Zu, this.version = Yu, this.name = ec.name, this.events = new zt.EventEmitter(), this.on = (n, a) => this.events.on(n, a), this.once = (n, a) => this.events.once(n, a), this.off = (n, a) => this.events.off(n, a), this.removeListener = (n, a) => this.events.removeListener(n, a), this.removeAllListeners = (n) => this.events.removeAllListeners(n), this.connect = async (n) => {
      try {
        return await this.engine.connect(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.pair = async (n) => {
      try {
        return await this.engine.pair(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.approve = async (n) => {
      try {
        return await this.engine.approve(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.reject = async (n) => {
      try {
        return await this.engine.reject(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.update = async (n) => {
      try {
        return await this.engine.update(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.extend = async (n) => {
      try {
        return await this.engine.extend(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.request = async (n) => {
      try {
        return await this.engine.request(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.respond = async (n) => {
      try {
        return await this.engine.respond(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.ping = async (n) => {
      try {
        return await this.engine.ping(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.emit = async (n) => {
      try {
        return await this.engine.emit(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.disconnect = async (n) => {
      try {
        return await this.engine.disconnect(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.find = (n) => {
      try {
        return this.engine.find(n);
      } catch (a) {
        throw this.logger.error(a.message), a;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.name = t?.name || ec.name, this.metadata = t?.metadata || p8();
    const r = typeof t?.logger < "u" && typeof t?.logger != "string" ? t.logger : xe.pino(xe.getDefaultLoggerOptions({ level: t?.logger || ec.logger }));
    this.core = t?.core || new np(t), this.logger = xe.generateChildLogger(r, this.name), this.session = new yp(this.core, this.logger), this.proposal = new _p(this.core, this.logger), this.pendingRequest = new wp(this.core, this.logger), this.engine = new gp(this);
  }
  static async init(t) {
    const r = new xs(t);
    return await r.initialize(), r;
  }
  get context() {
    return xe.getLoggerContext(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (t) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
}
const mp = () => {
  const t = ou()?.os?.toLowerCase();
  return t?.includes("android") ? "android" : t?.toLowerCase().includes("ios") || t?.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 ? "ios" : "desktop";
}, Ci = mp(), Ep = {
  position: "fixed",
  top: "0",
  left: "0",
  right: "0",
  bottom: "0",
  backgroundColor: "rgba(0,0,0,0.8)",
  backdropFilter: "blur(10px)",
  zIndex: "9999",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  flexDirection: "column",
  color: "white",
  fontWeight: "500",
  fontFamily: "'Barlow', sans-serif"
}, vp = {
  width: "840px",
  height: "540px",
  zIndex: "99999",
  backgroundColor: "white",
  border: "none",
  outline: "none",
  borderRadius: "40px",
  boxShadow: "0px 4px 40px 0px rgb(0 0 0), 0px 4px 8px 0px rgb(0 0 0 / 25%)",
  position: "fixed",
  top: "50%",
  left: "50%",
  transform: "translate(-50%,-50%)"
}, xp = `
  <div style="position: relative">
    <iframe class="argent-iframe" allow="clipboard-write"></iframe>
    <div class="argent-close-button" style="position: absolute; top: 24px; right: 24px; cursor: pointer;">
      <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="16" cy="16" r="16" fill="#F5F3F0"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M22.2462 9.75382C22.7018 10.2094 22.7018 10.9481 22.2462 11.4037L17.6499 16L22.2462 20.5963C22.7018 21.0519 22.7018 21.7906 22.2462 22.2462C21.7905 22.7018 21.0519 22.7018 20.5962 22.2462L16 17.6499L11.4039 22.246C10.9482 22.7017 10.2096 22.7017 9.75394 22.246C9.29833 21.7904 9.29833 21.0517 9.75394 20.5961L14.3501 16L9.75394 11.4039C9.29833 10.9483 9.29833 10.2096 9.75394 9.75396C10.2096 9.29835 10.9482 9.29835 11.4039 9.75396L16 14.3501L20.5962 9.75382C21.0519 9.29821 21.7905 9.29821 22.2462 9.75382Z" fill="#333332"/>
      </svg>
    </div>
  </div>
`;
class Sp {
  constructor() {
    Ee(this, "bridgeUrl", "https://login.argent.xyz");
    Ee(this, "mobileUrl", "https://www.argent.xyz/app");
    Ee(this, "type", "overlay");
    Ee(this, "wcUri");
    Ee(this, "overlay");
    Ee(this, "popupWindow");
    Ee(this, "closingTimeout");
    Ee(this, "close", () => {
      this.overlay?.remove(), this.popupWindow?.close(), this.overlay = void 0, this.popupWindow = void 0;
    });
  }
  showConnectionModal(t) {
    const r = encodeURIComponent(t), n = encodeURIComponent(window.location.href);
    this.showModal({
      desktop: `${this.bridgeUrl}?wc=${r}`,
      ios: `${this.mobileUrl}/wc?uri=${r}&href=${n}`,
      android: `${this.mobileUrl}/wc?uri=${r}&href=${n}`
    });
  }
  showApprovalModal(t) {
    if (Ci === "desktop") {
      this.showModal({
        desktop: `${this.bridgeUrl}?action=sign`,
        ios: "",
        android: ""
      });
      return;
    }
    const r = encodeURIComponent(window.location.href);
    this.showModal({
      desktop: `${this.bridgeUrl}?action=sign`,
      ios: `${this.mobileUrl}/wc?href=${r}`,
      android: `${this.mobileUrl}/wc?href=${r}`
    });
  }
  closeModal(t) {
    t ? (this.overlay?.querySelector("iframe")?.contentWindow?.postMessage("argent-login.success", "*"), this.popupWindow?.postMessage("argent-login.success", "*"), this.closingTimeout = setTimeout(this.close, 3400)) : this.close();
  }
  showModal(t) {
    if (clearTimeout(this.closingTimeout), (this.overlay || this.popupWindow) && this.close(), Ci === "android" || Ci === "ios") {
      window.open(t[Ci]);
      return;
    }
    if (this.type === "window") {
      const i = "menubar=no,location=no,resizable=no,scrollbars=no,status=no,width=840,height=540";
      this.popupWindow = window.open(t.desktop, "_blank", i) || void 0;
      return;
    }
    const r = document.createElement("div");
    r.innerHTML = xp;
    for (const [i, c] of Object.entries(Ep))
      r.style[i] = c;
    document.body.appendChild(r), r.addEventListener("click", () => this.closeModal()), this.overlay = r;
    const n = r.querySelector("iframe");
    n.setAttribute("src", t.desktop);
    for (const [i, c] of Object.entries(vp))
      n.style[i] = c;
    r.querySelector(
      ".argent-close-button"
    ).addEventListener("click", () => this.closeModal());
  }
}
const Ln = new Sp(), Dp = async ({
  projectId: e,
  chainId: t,
  name: r,
  rpcUrl: n,
  bridgeUrl: a = Ap(t),
  modalType: i = "overlay",
  walletConnect: c
}, s) => {
  Ln.bridgeUrl = a, Ln.type = i;
  const d = {
    projectId: e,
    metadata: {
      name: r ?? "Unknown dapp",
      description: "Unknown dapp description",
      url: "#",
      icons: ["https://walletconnect.com/walletconnect-logo.png"],
      ...c?.metadata
    },
    ...c
  }, f = await xs.init(d), l = new s({ client: f, chainId: t, rpcUrl: n });
  f.on("session_event", (p) => {
  }), f.on("session_update", ({ topic: p, params: w }) => {
    const { namespaces: g } = w, m = f.session.get(p);
    l.updateSession({ ...m, namespaces: g });
  }), f.on("session_delete", () => {
  });
  try {
    const p = f.session.getAll().find(l.isValidSession);
    if (p)
      return l.updateSession(p), l;
    const w = { requiredNamespaces: l.getRequiredNamespaces() }, { uri: g, approval: m } = await f.connect(w);
    if (g) {
      Ln.showConnectionModal(g), Ln.wcUri = g;
      const S = await m();
      l.updateSession(S), Ln.closeModal("animateSuccess");
    }
    return l;
  } catch (p) {
    throw console.error("@argent/login::error"), Ln.closeModal(), p;
  }
}, Ap = (e) => {
  if (e) {
    const t = parseInt(`${e}`);
    if (String(e).startsWith("SN_GOERLI") || String(e).startsWith("SN_GOERLI2") || [5, 280].includes(t))
      return "https://login.hydrogen.argent47.net";
    if (String(e).startsWith("SN_GOERLI") || [1, 324].includes(t))
      return "https://login.argent.xyz";
  }
  throw new Error(
    `Unknown or unsupported chainId (${e}), either specify a supported chain or set bridgeUrl.`
  );
};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ju = BigInt(0), Ss = BigInt(1), Ip = BigInt(2), Ds = (e) => e instanceof Uint8Array, Cp = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Gr(e) {
  if (!Ds(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += Cp[e[r]];
  return t;
}
function Qu(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function As(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
function Wr(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (e.length % 2)
    throw new Error("hex string is invalid: unpadded " + e.length);
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < t.length; r++) {
    const n = r * 2, a = e.slice(n, n + 2), i = Number.parseInt(a, 16);
    if (Number.isNaN(i) || i < 0)
      throw new Error("invalid byte sequence");
    t[r] = i;
  }
  return t;
}
function Pt(e) {
  return As(Gr(e));
}
function Mo(e) {
  if (!Ds(e))
    throw new Error("Uint8Array expected");
  return As(Gr(Uint8Array.from(e).reverse()));
}
const qn = (e, t) => Wr(e.toString(16).padStart(t * 2, "0")), eh = (e, t) => qn(e, t).reverse(), Ho = (e) => Wr(Qu(e));
function Bt(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = Wr(t);
    } catch (i) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${i}`);
    }
  else if (Ds(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const a = n.length;
  if (typeof r == "number" && a !== r)
    throw new Error(`${e} expected ${r} bytes, got ${a}`);
  return n;
}
function Zn(...e) {
  const t = new Uint8Array(e.reduce((n, a) => n + a.length, 0));
  let r = 0;
  return e.forEach((n) => {
    if (!Ds(n))
      throw new Error("Uint8Array expected");
    t.set(n, r), r += n.length;
  }), t;
}
function Tp(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function Op(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Np(e) {
  let t;
  for (t = 0; e > Ju; e >>= Ss, t += 1)
    ;
  return t;
}
const Rp = (e, t) => e >> BigInt(t) & Ss, Lp = (e, t, r) => e | (r ? Ss : Ju) << BigInt(t), Is = (e) => (Ip << BigInt(e - 1)) - Ss, nc = (e) => new Uint8Array(e), g0 = (e) => Uint8Array.from(e);
function th(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = nc(e), a = nc(e), i = 0;
  const c = () => {
    n.fill(1), a.fill(0), i = 0;
  }, s = (...p) => r(a, n, ...p), d = (p = nc()) => {
    a = s(g0([0]), p), n = s(), p.length !== 0 && (a = s(g0([1]), p), n = s());
  }, f = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let p = 0;
    const w = [];
    for (; p < t; ) {
      n = s();
      const g = n.slice();
      w.push(g), p += n.length;
    }
    return Zn(...w);
  };
  return (p, w) => {
    c(), d(p);
    let g;
    for (; !(g = w(f())); )
      d();
    return c(), g;
  };
}
const Pp = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function ci(e, t, r = {}) {
  const n = (a, i, c) => {
    const s = Pp[i];
    if (typeof s != "function")
      throw new Error(`Invalid validator "${i}", expected function`);
    const d = e[a];
    if (!(c && d === void 0) && !s(d, e))
      throw new Error(`Invalid param ${String(a)}=${d} (${typeof d}), expected ${i}`);
  };
  for (const [a, i] of Object.entries(t))
    n(a, i, !1);
  for (const [a, i] of Object.entries(r))
    n(a, i, !0);
  return e;
}
const kp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: Rp,
  bitLen: Np,
  bitMask: Is,
  bitSet: Lp,
  bytesToHex: Gr,
  bytesToNumberBE: Pt,
  bytesToNumberLE: Mo,
  concatBytes: Zn,
  createHmacDrbg: th,
  ensureBytes: Bt,
  equalBytes: Tp,
  hexToBytes: Wr,
  hexToNumber: As,
  numberToBytesBE: qn,
  numberToBytesLE: eh,
  numberToHexUnpadded: Qu,
  numberToVarBytesBE: Ho,
  utf8ToBytes: Op,
  validateObject: ci
}, Symbol.toStringTag, { value: "Module" }));
function jc(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function Up(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function rh(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Fp(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  jc(e.outputLen), jc(e.blockLen);
}
function $p(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Bp(e, t) {
  rh(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Ar = {
  number: jc,
  bool: Up,
  bytes: rh,
  hash: Fp,
  exists: $p,
  output: Bp
}, Ti = BigInt(2 ** 32 - 1), Vc = BigInt(32);
function nh(e, t = !1) {
  return t ? { h: Number(e & Ti), l: Number(e >> Vc & Ti) } : { h: Number(e >> Vc & Ti) | 0, l: Number(e & Ti) | 0 };
}
function Mp(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let a = 0; a < e.length; a++) {
    const { h: i, l: c } = nh(e[a], t);
    [r[a], n[a]] = [i, c];
  }
  return [r, n];
}
const Hp = (e, t) => BigInt(e >>> 0) << Vc | BigInt(t >>> 0), zp = (e, t, r) => e >>> r, jp = (e, t, r) => e << 32 - r | t >>> r, Vp = (e, t, r) => e >>> r | t << 32 - r, qp = (e, t, r) => e << 32 - r | t >>> r, Kp = (e, t, r) => e << 64 - r | t >>> r - 32, Gp = (e, t, r) => e >>> r - 32 | t << 64 - r, Wp = (e, t) => t, Zp = (e, t) => e, Yp = (e, t, r) => e << r | t >>> 32 - r, Xp = (e, t, r) => t << r | e >>> 32 - r, Jp = (e, t, r) => t << r - 32 | e >>> 64 - r, Qp = (e, t, r) => e << r - 32 | t >>> 64 - r;
function eg(e, t, r, n) {
  const a = (t >>> 0) + (n >>> 0);
  return { h: e + r + (a / 2 ** 32 | 0) | 0, l: a | 0 };
}
const tg = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0), rg = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0, ng = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), ag = (e, t, r, n, a) => t + r + n + a + (e / 2 ** 32 | 0) | 0, ig = (e, t, r, n, a) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (a >>> 0), sg = (e, t, r, n, a, i) => t + r + n + a + i + (e / 2 ** 32 | 0) | 0, Ha = {
  fromBig: nh,
  split: Mp,
  toBig: Hp,
  shrSH: zp,
  shrSL: jp,
  rotrSH: Vp,
  rotrSL: qp,
  rotrBH: Kp,
  rotrBL: Gp,
  rotr32H: Wp,
  rotr32L: Zp,
  rotlSH: Yp,
  rotlSL: Xp,
  rotlBH: Jp,
  rotlBL: Qp,
  add: eg,
  add3L: tg,
  add3H: rg,
  add4L: ng,
  add4H: ag,
  add5H: sg,
  add5L: ig
};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const cg = (e) => e instanceof Uint8Array, og = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), ac = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), sr = (e, t) => e << 32 - t | e >>> t, fg = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!fg)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function ah(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function Cs(e) {
  if (typeof e == "string" && (e = ah(e)), !cg(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
let ih = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function zo(e) {
  const t = (n) => e().update(Cs(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function dg(e) {
  const t = (n, a) => e(a).update(Cs(n)).digest(), r = e({});
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = (n) => e(n), t;
}
const [sh, ch, oh] = [[], [], []], lg = BigInt(0), Aa = BigInt(1), ug = BigInt(2), hg = BigInt(7), bg = BigInt(256), pg = BigInt(113);
for (let e = 0, t = Aa, r = 1, n = 0; e < 24; e++) {
  [r, n] = [n, (2 * r + 3 * n) % 5], sh.push(2 * (5 * n + r)), ch.push((e + 1) * (e + 2) / 2 % 64);
  let a = lg;
  for (let i = 0; i < 7; i++)
    t = (t << Aa ^ (t >> hg) * pg) % bg, t & ug && (a ^= Aa << (Aa << BigInt(i)) - Aa);
  oh.push(a);
}
const [gg, _g] = Ha.split(oh, !0), _0 = (e, t, r) => r > 32 ? Ha.rotlBH(e, t, r) : Ha.rotlSH(e, t, r), y0 = (e, t, r) => r > 32 ? Ha.rotlBL(e, t, r) : Ha.rotlSL(e, t, r);
function yg(e, t = 24) {
  const r = new Uint32Array(10);
  for (let n = 24 - t; n < 24; n++) {
    for (let c = 0; c < 10; c++)
      r[c] = e[c] ^ e[c + 10] ^ e[c + 20] ^ e[c + 30] ^ e[c + 40];
    for (let c = 0; c < 10; c += 2) {
      const s = (c + 8) % 10, d = (c + 2) % 10, f = r[d], l = r[d + 1], p = _0(f, l, 1) ^ r[s], w = y0(f, l, 1) ^ r[s + 1];
      for (let g = 0; g < 50; g += 10)
        e[c + g] ^= p, e[c + g + 1] ^= w;
    }
    let a = e[2], i = e[3];
    for (let c = 0; c < 24; c++) {
      const s = ch[c], d = _0(a, i, s), f = y0(a, i, s), l = sh[c];
      a = e[l], i = e[l + 1], e[l] = d, e[l + 1] = f;
    }
    for (let c = 0; c < 50; c += 10) {
      for (let s = 0; s < 10; s++)
        r[s] = e[c + s];
      for (let s = 0; s < 10; s++)
        e[c + s] ^= ~r[(s + 2) % 10] & r[(s + 4) % 10];
    }
    e[0] ^= gg[n], e[1] ^= _g[n];
  }
  r.fill(0);
}
class Ts extends ih {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, r, n, a = !1, i = 24) {
    if (super(), this.blockLen = t, this.suffix = r, this.outputLen = n, this.enableXOF = a, this.rounds = i, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Ar.number(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = og(this.state);
  }
  keccak() {
    yg(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    Ar.exists(this);
    const { blockLen: r, state: n } = this;
    t = Cs(t);
    const a = t.length;
    for (let i = 0; i < a; ) {
      const c = Math.min(r - this.pos, a - i);
      for (let s = 0; s < c; s++)
        n[this.pos++] ^= t[i++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: r, pos: n, blockLen: a } = this;
    t[n] ^= r, r & 128 && n === a - 1 && this.keccak(), t[a - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    Ar.exists(this, !1), Ar.bytes(t), this.finish();
    const r = this.state, { blockLen: n } = this;
    for (let a = 0, i = t.length; a < i; ) {
      this.posOut >= n && this.keccak();
      const c = Math.min(n - this.posOut, i - a);
      t.set(r.subarray(this.posOut, this.posOut + c), a), this.posOut += c, a += c;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return Ar.number(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (Ar.output(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: r, suffix: n, outputLen: a, rounds: i, enableXOF: c } = this;
    return t || (t = new Ts(r, n, a, c, i)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = i, t.suffix = n, t.outputLen = a, t.enableXOF = c, t.destroyed = this.destroyed, t;
  }
}
const Qr = (e, t, r) => zo(() => new Ts(t, e, r));
Qr(6, 144, 224 / 8);
Qr(6, 136, 256 / 8);
Qr(6, 104, 384 / 8);
Qr(6, 72, 512 / 8);
Qr(1, 144, 224 / 8);
const wg = Qr(1, 136, 256 / 8);
Qr(1, 104, 384 / 8);
Qr(1, 72, 512 / 8);
const fh = (e, t, r) => dg((n = {}) => new Ts(t, e, n.dkLen === void 0 ? r : n.dkLen, !0));
fh(31, 168, 128 / 8);
fh(31, 136, 256 / 8);
function mg(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const a = BigInt(32), i = BigInt(4294967295), c = Number(r >> a & i), s = Number(r & i), d = n ? 4 : 0, f = n ? 0 : 4;
  e.setUint32(t + d, c, n), e.setUint32(t + f, s, n);
}
class Eg extends ih {
  constructor(t, r, n, a) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = a, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = ac(this.buffer);
  }
  update(t) {
    Ar.exists(this);
    const { view: r, buffer: n, blockLen: a } = this;
    t = Cs(t);
    const i = t.length;
    for (let c = 0; c < i; ) {
      const s = Math.min(a - this.pos, i - c);
      if (s === a) {
        const d = ac(t);
        for (; a <= i - c; c += a)
          this.process(d, c);
        continue;
      }
      n.set(t.subarray(c, c + s), this.pos), this.pos += s, c += s, this.pos === a && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Ar.exists(this), Ar.output(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: a, isLE: i } = this;
    let { pos: c } = this;
    r[c++] = 128, this.buffer.subarray(c).fill(0), this.padOffset > a - c && (this.process(n, 0), c = 0);
    for (let p = c; p < a; p++)
      r[p] = 0;
    mg(n, a - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const s = ac(t), d = this.outputLen;
    if (d % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const f = d / 4, l = this.get();
    if (f > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let p = 0; p < f; p++)
      s.setUint32(4 * p, l[p], i);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: a, finished: i, destroyed: c, pos: s } = this;
    return t.length = a, t.pos = s, t.finished = i, t.destroyed = c, a % r && t.buffer.set(n), t;
  }
}
const vg = (e, t, r) => e & t ^ ~e & r, xg = (e, t, r) => e & t ^ e & r ^ t & r, Sg = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Ur = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Fr = new Uint32Array(64);
class dh extends Eg {
  constructor() {
    super(64, 32, 8, !1), this.A = Ur[0] | 0, this.B = Ur[1] | 0, this.C = Ur[2] | 0, this.D = Ur[3] | 0, this.E = Ur[4] | 0, this.F = Ur[5] | 0, this.G = Ur[6] | 0, this.H = Ur[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: a, E: i, F: c, G: s, H: d } = this;
    return [t, r, n, a, i, c, s, d];
  }
  // prettier-ignore
  set(t, r, n, a, i, c, s, d) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = a | 0, this.E = i | 0, this.F = c | 0, this.G = s | 0, this.H = d | 0;
  }
  process(t, r) {
    for (let p = 0; p < 16; p++, r += 4)
      Fr[p] = t.getUint32(r, !1);
    for (let p = 16; p < 64; p++) {
      const w = Fr[p - 15], g = Fr[p - 2], m = sr(w, 7) ^ sr(w, 18) ^ w >>> 3, S = sr(g, 17) ^ sr(g, 19) ^ g >>> 10;
      Fr[p] = S + Fr[p - 7] + m + Fr[p - 16] | 0;
    }
    let { A: n, B: a, C: i, D: c, E: s, F: d, G: f, H: l } = this;
    for (let p = 0; p < 64; p++) {
      const w = sr(s, 6) ^ sr(s, 11) ^ sr(s, 25), g = l + w + vg(s, d, f) + Sg[p] + Fr[p] | 0, S = (sr(n, 2) ^ sr(n, 13) ^ sr(n, 22)) + xg(n, a, i) | 0;
      l = f, f = d, d = s, s = c + g | 0, c = i, i = a, a = n, n = g + S | 0;
    }
    n = n + this.A | 0, a = a + this.B | 0, i = i + this.C | 0, c = c + this.D | 0, s = s + this.E | 0, d = d + this.F | 0, f = f + this.G | 0, l = l + this.H | 0, this.set(n, a, i, c, s, d, f, l);
  }
  roundClean() {
    Fr.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class Dg extends dh {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
const jo = zo(() => new dh());
zo(() => new Dg());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const pt = BigInt(0), je = BigInt(1), dn = BigInt(2), Ag = BigInt(3), qc = BigInt(4), w0 = BigInt(5), m0 = BigInt(8);
BigInt(9);
BigInt(16);
function St(e, t) {
  const r = e % t;
  return r >= pt ? r : t + r;
}
function Ig(e, t, r) {
  if (r <= pt || t < pt)
    throw new Error("Expected power/modulo > 0");
  if (r === je)
    return pt;
  let n = je;
  for (; t > pt; )
    t & je && (n = n * e % r), e = e * e % r, t >>= je;
  return n;
}
function Kc(e, t) {
  if (e === pt || t <= pt)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = St(e, t), n = t, a = pt, i = je;
  for (; r !== pt; ) {
    const s = n / r, d = n % r, f = a - i * s;
    n = r, r = d, a = i, i = f;
  }
  if (n !== je)
    throw new Error("invert: does not exist");
  return St(a, t);
}
function Cg(e) {
  const t = (e - je) / dn;
  let r, n, a;
  for (r = e - je, n = 0; r % dn === pt; r /= dn, n++)
    ;
  for (a = dn; a < e && Ig(a, t, e) !== e - je; a++)
    ;
  if (n === 1) {
    const c = (e + je) / qc;
    return function(d, f) {
      const l = d.pow(f, c);
      if (!d.eql(d.sqr(l), f))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  const i = (r + je) / dn;
  return function(s, d) {
    if (s.pow(d, t) === s.neg(s.ONE))
      throw new Error("Cannot find square root");
    let f = n, l = s.pow(s.mul(s.ONE, a), r), p = s.pow(d, i), w = s.pow(d, r);
    for (; !s.eql(w, s.ONE); ) {
      if (s.eql(w, s.ZERO))
        return s.ZERO;
      let g = 1;
      for (let S = s.sqr(w); g < f && !s.eql(S, s.ONE); g++)
        S = s.sqr(S);
      const m = s.pow(l, je << BigInt(f - g - 1));
      l = s.sqr(m), p = s.mul(p, m), w = s.mul(w, l), f = g;
    }
    return p;
  };
}
function Tg(e) {
  if (e % qc === Ag) {
    const t = (e + je) / qc;
    return function(n, a) {
      const i = n.pow(a, t);
      if (!n.eql(n.sqr(i), a))
        throw new Error("Cannot find square root");
      return i;
    };
  }
  if (e % m0 === w0) {
    const t = (e - w0) / m0;
    return function(n, a) {
      const i = n.mul(a, dn), c = n.pow(i, t), s = n.mul(a, c), d = n.mul(n.mul(s, dn), c), f = n.mul(s, n.sub(d, n.ONE));
      if (!n.eql(n.sqr(f), a))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  return Cg(e);
}
const Og = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Os(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = Og.reduce((n, a) => (n[a] = "function", n), t);
  return ci(e, r);
}
function lh(e, t, r) {
  if (r < pt)
    throw new Error("Expected power > 0");
  if (r === pt)
    return e.ONE;
  if (r === je)
    return t;
  let n = e.ONE, a = t;
  for (; r > pt; )
    r & je && (n = e.mul(n, a)), a = e.sqr(a), r >>= je;
  return n;
}
function Ng(e, t) {
  const r = new Array(t.length), n = t.reduce((i, c, s) => e.is0(c) ? i : (r[s] = i, e.mul(i, c)), e.ONE), a = e.inv(n);
  return t.reduceRight((i, c, s) => e.is0(c) ? i : (r[s] = e.mul(i, r[s]), e.mul(i, c)), a), r;
}
function Vo(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function qo(e, t, r = !1, n = {}) {
  if (e <= pt)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: a, nByteLength: i } = Vo(e, t);
  if (i > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const c = Tg(e), s = Object.freeze({
    ORDER: e,
    BITS: a,
    BYTES: i,
    MASK: Is(a),
    ZERO: pt,
    ONE: je,
    create: (d) => St(d, e),
    isValid: (d) => {
      if (typeof d != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof d}`);
      return pt <= d && d < e;
    },
    is0: (d) => d === pt,
    isOdd: (d) => (d & je) === je,
    neg: (d) => St(-d, e),
    eql: (d, f) => d === f,
    sqr: (d) => St(d * d, e),
    add: (d, f) => St(d + f, e),
    sub: (d, f) => St(d - f, e),
    mul: (d, f) => St(d * f, e),
    pow: (d, f) => lh(s, d, f),
    div: (d, f) => St(d * Kc(f, e), e),
    // Same as above, but doesn't normalize
    sqrN: (d) => d * d,
    addN: (d, f) => d + f,
    subN: (d, f) => d - f,
    mulN: (d, f) => d * f,
    inv: (d) => Kc(d, e),
    sqrt: n.sqrt || ((d) => c(s, d)),
    invertBatch: (d) => Ng(s, d),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (d, f, l) => l ? f : d,
    toBytes: (d) => r ? eh(d, i) : qn(d, i),
    fromBytes: (d) => {
      if (d.length !== i)
        throw new Error(`Fp.fromBytes: expected ${i}, got ${d.length}`);
      return r ? Mo(d) : Pt(d);
    }
  });
  return Object.freeze(s);
}
function Rg(e, t, r = !1) {
  e = Bt("privateHash", e);
  const n = e.length, a = Vo(t).nByteLength + 8;
  if (a < 24 || n < a || n > 1024)
    throw new Error(`hashToPrivateScalar: expected ${a}-1024 bytes of input, got ${n}`);
  const i = r ? Mo(e) : Pt(e);
  return St(i, t - je) + je;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function uh(e) {
  const { Fp: t } = e;
  Os(t);
  for (const d of ["t", "roundsFull", "roundsPartial"])
    if (typeof e[d] != "number" || !Number.isSafeInteger(e[d]))
      throw new Error(`Poseidon: invalid param ${d}=${e[d]} (${typeof e[d]})`);
  if (e.reversePartialPowIdx !== void 0 && typeof e.reversePartialPowIdx != "boolean")
    throw new Error(`Poseidon: invalid param reversePartialPowIdx=${e.reversePartialPowIdx}`);
  let r = e.sboxPower;
  if (r === void 0 && (r = 5), typeof r != "number" || !Number.isSafeInteger(r))
    throw new Error(`Poseidon wrong sboxPower=${r}`);
  const n = BigInt(r);
  let a = (d) => lh(t, d, n);
  if (r === 3 ? a = (d) => t.mul(t.sqrN(d), d) : r === 5 && (a = (d) => t.mul(t.sqrN(t.sqrN(d)), d)), e.roundsFull % 2 !== 0)
    throw new Error(`Poseidon roundsFull is not even: ${e.roundsFull}`);
  const i = e.roundsFull + e.roundsPartial;
  if (!Array.isArray(e.roundConstants) || e.roundConstants.length !== i)
    throw new Error("Poseidon: wrong round constants");
  const c = e.roundConstants.map((d) => {
    if (!Array.isArray(d) || d.length !== e.t)
      throw new Error(`Poseidon wrong round constants: ${d}`);
    return d.map((f) => {
      if (typeof f != "bigint" || !t.isValid(f))
        throw new Error(`Poseidon wrong round constant=${f}`);
      return t.create(f);
    });
  });
  if (!Array.isArray(e.mds) || e.mds.length !== e.t)
    throw new Error("Poseidon: wrong MDS matrix");
  const s = e.mds.map((d) => {
    if (!Array.isArray(d) || d.length !== e.t)
      throw new Error(`Poseidon MDS matrix row: ${d}`);
    return d.map((f) => {
      if (typeof f != "bigint")
        throw new Error(`Poseidon MDS matrix value=${f}`);
      return t.create(f);
    });
  });
  return Object.freeze({ ...e, rounds: i, sboxFn: a, roundConstants: c, mds: s });
}
function Lg(e, t) {
  if (typeof t != "number")
    throw new Error("poseidonSplitConstants: wrong t");
  if (!Array.isArray(e) || e.length % t)
    throw new Error("poseidonSplitConstants: wrong rc");
  const r = [];
  let n = [];
  for (let a = 0; a < e.length; a++)
    n.push(e[a]), n.length === t && (r.push(n), n = []);
  return r;
}
function hh(e) {
  const { t, Fp: r, rounds: n, sboxFn: a, reversePartialPowIdx: i } = uh(e), c = Math.floor(e.roundsFull / 2), s = i ? t - 1 : 0, d = (l, p, w) => (l = l.map((g, m) => r.add(g, e.roundConstants[w][m])), p ? l = l.map((g) => a(g)) : l[s] = a(l[s]), l = e.mds.map((g) => g.reduce((m, S, I) => r.add(m, r.mulN(S, l[I])), r.ZERO)), l), f = function(p) {
    if (!Array.isArray(p) || p.length !== t)
      throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);
    p = p.map((g) => {
      if (typeof g != "bigint")
        throw new Error(`Poseidon: wrong value=${g} (${typeof g})`);
      return r.create(g);
    });
    let w = 0;
    for (let g = 0; g < c; g++)
      p = d(p, !0, w++);
    for (let g = 0; g < e.roundsPartial; g++)
      p = d(p, !1, w++);
    for (let g = 0; g < c; g++)
      p = d(p, !0, w++);
    if (w !== n)
      throw new Error(`Poseidon: wrong number of rounds: last round=${w}, total=${n}`);
    return p;
  };
  return f.roundConstants = e.roundConstants, f;
}
const Pg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  poseidon: hh,
  splitConstants: Lg,
  validateOpts: uh
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const kg = BigInt(0), ic = BigInt(1);
function Ug(e, t) {
  const r = (a, i) => {
    const c = i.negate();
    return a ? c : i;
  }, n = (a) => {
    const i = Math.ceil(t / a) + 1, c = 2 ** (a - 1);
    return { windows: i, windowSize: c };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(a, i) {
      let c = e.ZERO, s = a;
      for (; i > kg; )
        i & ic && (c = c.add(s)), s = s.double(), i >>= ic;
      return c;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(a, i) {
      const { windows: c, windowSize: s } = n(i), d = [];
      let f = a, l = f;
      for (let p = 0; p < c; p++) {
        l = f, d.push(l);
        for (let w = 1; w < s; w++)
          l = l.add(f), d.push(l);
        f = l.double();
      }
      return d;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(a, i, c) {
      const { windows: s, windowSize: d } = n(a);
      let f = e.ZERO, l = e.BASE;
      const p = BigInt(2 ** a - 1), w = 2 ** a, g = BigInt(a);
      for (let m = 0; m < s; m++) {
        const S = m * d;
        let I = Number(c & p);
        c >>= g, I > d && (I -= w, c += ic);
        const N = S, x = S + Math.abs(I) - 1, C = m % 2 !== 0, _ = I < 0;
        I === 0 ? l = l.add(r(C, i[N])) : f = f.add(r(_, i[x]));
      }
      return { p: f, f: l };
    },
    wNAFCached(a, i, c, s) {
      const d = a._WINDOW_SIZE || 1;
      let f = i.get(a);
      return f || (f = this.precomputeWindow(a, d), d !== 1 && i.set(a, s(f))), this.wNAF(d, f, c);
    }
  };
}
function bh(e) {
  return Os(e.Fp), ci(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...Vo(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Fg(e) {
  const t = bh(e);
  ci(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a } = t;
  if (r) {
    if (!n.eql(a, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: $g, hexToBytes: Bg } = kp, Mr = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(e) {
    const { Err: t } = Mr;
    if (e.length < 2 || e[0] !== 2)
      throw new t("Invalid signature integer tag");
    const r = e[1], n = e.subarray(2, r + 2);
    if (!r || n.length !== r)
      throw new t("Invalid signature integer: wrong length");
    if (n[0] & 128)
      throw new t("Invalid signature integer: negative");
    if (n[0] === 0 && !(n[1] & 128))
      throw new t("Invalid signature integer: unnecessary leading zero");
    return { d: $g(n), l: e.subarray(r + 2) };
  },
  toSig(e) {
    const { Err: t } = Mr, r = typeof e == "string" ? Bg(e) : e;
    if (!(r instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = r.length;
    if (n < 2 || r[0] != 48)
      throw new t("Invalid signature tag");
    if (r[1] !== n - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: a, l: i } = Mr._parseInt(r.subarray(2)), { d: c, l: s } = Mr._parseInt(i);
    if (s.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: a, s: c };
  },
  hexFromSig(e) {
    const t = (f) => Number.parseInt(f[0], 16) & 8 ? "00" + f : f, r = (f) => {
      const l = f.toString(16);
      return l.length & 1 ? `0${l}` : l;
    }, n = t(r(e.s)), a = t(r(e.r)), i = n.length / 2, c = a.length / 2, s = r(i), d = r(c);
    return `30${r(c + i + 4)}02${d}${a}02${s}${n}`;
  }
}, tr = BigInt(0), Ye = BigInt(1), xr = BigInt(2), Ji = BigInt(3), E0 = BigInt(4);
function ph(e) {
  const t = Fg(e), { Fp: r } = t, n = t.toBytes || ((m, S, I) => {
    const N = S.toAffine();
    return Zn(Uint8Array.from([4]), r.toBytes(N.x), r.toBytes(N.y));
  }), a = t.fromBytes || ((m) => {
    const S = m.subarray(1), I = r.fromBytes(S.subarray(0, r.BYTES)), N = r.fromBytes(S.subarray(r.BYTES, 2 * r.BYTES));
    return { x: I, y: N };
  });
  function i(m) {
    const { a: S, b: I } = t, N = r.sqr(m), x = r.mul(N, m);
    return r.add(r.add(x, r.mul(m, S)), I);
  }
  if (!r.eql(r.sqr(t.Gy), i(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function c(m) {
    return typeof m == "bigint" && tr < m && m < t.n;
  }
  function s(m) {
    if (!c(m))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function d(m) {
    const { allowedPrivateKeyLengths: S, nByteLength: I, wrapPrivateKey: N, n: x } = t;
    if (S && typeof m != "bigint") {
      if (m instanceof Uint8Array && (m = Gr(m)), typeof m != "string" || !S.includes(m.length))
        throw new Error("Invalid key");
      m = m.padStart(I * 2, "0");
    }
    let C;
    try {
      C = typeof m == "bigint" ? m : Pt(Bt("private key", m, I));
    } catch {
      throw new Error(`private key must be ${I} bytes, hex or bigint, not ${typeof m}`);
    }
    return N && (C = St(C, x)), s(C), C;
  }
  const f = /* @__PURE__ */ new Map();
  function l(m) {
    if (!(m instanceof p))
      throw new Error("ProjectivePoint expected");
  }
  class p {
    constructor(S, I, N) {
      if (this.px = S, this.py = I, this.pz = N, S == null || !r.isValid(S))
        throw new Error("x required");
      if (I == null || !r.isValid(I))
        throw new Error("y required");
      if (N == null || !r.isValid(N))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(S) {
      const { x: I, y: N } = S || {};
      if (!S || !r.isValid(I) || !r.isValid(N))
        throw new Error("invalid affine point");
      if (S instanceof p)
        throw new Error("projective point not allowed");
      const x = (C) => r.eql(C, r.ZERO);
      return x(I) && x(N) ? p.ZERO : new p(I, N, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(S) {
      const I = r.invertBatch(S.map((N) => N.pz));
      return S.map((N, x) => N.toAffine(I[x])).map(p.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(S) {
      const I = p.fromAffine(a(Bt("pointHex", S)));
      return I.assertValidity(), I;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(S) {
      return p.BASE.multiply(d(S));
    }
    // "Private method", don't use it directly
    _setWindowSize(S) {
      this._WINDOW_SIZE = S, f.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: S, y: I } = this.toAffine();
      if (!r.isValid(S) || !r.isValid(I))
        throw new Error("bad point: x or y not FE");
      const N = r.sqr(I), x = i(S);
      if (!r.eql(N, x))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: S } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(S);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(S) {
      l(S);
      const { px: I, py: N, pz: x } = this, { px: C, py: _, pz: D } = S, b = r.eql(r.mul(I, D), r.mul(C, x)), o = r.eql(r.mul(N, D), r.mul(_, x));
      return b && o;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new p(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: S, b: I } = t, N = r.mul(I, Ji), { px: x, py: C, pz: _ } = this;
      let D = r.ZERO, b = r.ZERO, o = r.ZERO, h = r.mul(x, x), U = r.mul(C, C), E = r.mul(_, _), T = r.mul(x, C);
      return T = r.add(T, T), o = r.mul(x, _), o = r.add(o, o), D = r.mul(S, o), b = r.mul(N, E), b = r.add(D, b), D = r.sub(U, b), b = r.add(U, b), b = r.mul(D, b), D = r.mul(T, D), o = r.mul(N, o), E = r.mul(S, E), T = r.sub(h, E), T = r.mul(S, T), T = r.add(T, o), o = r.add(h, h), h = r.add(o, h), h = r.add(h, E), h = r.mul(h, T), b = r.add(b, h), E = r.mul(C, _), E = r.add(E, E), h = r.mul(E, T), D = r.sub(D, h), o = r.mul(E, U), o = r.add(o, o), o = r.add(o, o), new p(D, b, o);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(S) {
      l(S);
      const { px: I, py: N, pz: x } = this, { px: C, py: _, pz: D } = S;
      let b = r.ZERO, o = r.ZERO, h = r.ZERO;
      const U = t.a, E = r.mul(t.b, Ji);
      let T = r.mul(I, C), P = r.mul(N, _), z = r.mul(x, D), v = r.add(I, N), y = r.add(C, _);
      v = r.mul(v, y), y = r.add(T, P), v = r.sub(v, y), y = r.add(I, x);
      let L = r.add(C, D);
      return y = r.mul(y, L), L = r.add(T, z), y = r.sub(y, L), L = r.add(N, x), b = r.add(_, D), L = r.mul(L, b), b = r.add(P, z), L = r.sub(L, b), h = r.mul(U, y), b = r.mul(E, z), h = r.add(b, h), b = r.sub(P, h), h = r.add(P, h), o = r.mul(b, h), P = r.add(T, T), P = r.add(P, T), z = r.mul(U, z), y = r.mul(E, y), P = r.add(P, z), z = r.sub(T, z), z = r.mul(U, z), y = r.add(y, z), T = r.mul(P, y), o = r.add(o, T), T = r.mul(L, y), b = r.mul(v, b), b = r.sub(b, T), T = r.mul(v, P), h = r.mul(L, h), h = r.add(h, T), new p(b, o, h);
    }
    subtract(S) {
      return this.add(S.negate());
    }
    is0() {
      return this.equals(p.ZERO);
    }
    wNAF(S) {
      return g.wNAFCached(this, f, S, (I) => {
        const N = r.invertBatch(I.map((x) => x.pz));
        return I.map((x, C) => x.toAffine(N[C])).map(p.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(S) {
      const I = p.ZERO;
      if (S === tr)
        return I;
      if (s(S), S === Ye)
        return this;
      const { endo: N } = t;
      if (!N)
        return g.unsafeLadder(this, S);
      let { k1neg: x, k1: C, k2neg: _, k2: D } = N.splitScalar(S), b = I, o = I, h = this;
      for (; C > tr || D > tr; )
        C & Ye && (b = b.add(h)), D & Ye && (o = o.add(h)), h = h.double(), C >>= Ye, D >>= Ye;
      return x && (b = b.negate()), _ && (o = o.negate()), o = new p(r.mul(o.px, N.beta), o.py, o.pz), b.add(o);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(S) {
      s(S);
      let I = S, N, x;
      const { endo: C } = t;
      if (C) {
        const { k1neg: _, k1: D, k2neg: b, k2: o } = C.splitScalar(I);
        let { p: h, f: U } = this.wNAF(D), { p: E, f: T } = this.wNAF(o);
        h = g.constTimeNegate(_, h), E = g.constTimeNegate(b, E), E = new p(r.mul(E.px, C.beta), E.py, E.pz), N = h.add(E), x = U.add(T);
      } else {
        const { p: _, f: D } = this.wNAF(I);
        N = _, x = D;
      }
      return p.normalizeZ([N, x])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(S, I, N) {
      const x = p.BASE, C = (D, b) => b === tr || b === Ye || !D.equals(x) ? D.multiplyUnsafe(b) : D.multiply(b), _ = C(this, I).add(C(S, N));
      return _.is0() ? void 0 : _;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(S) {
      const { px: I, py: N, pz: x } = this, C = this.is0();
      S == null && (S = C ? r.ONE : r.inv(x));
      const _ = r.mul(I, S), D = r.mul(N, S), b = r.mul(x, S);
      if (C)
        return { x: r.ZERO, y: r.ZERO };
      if (!r.eql(b, r.ONE))
        throw new Error("invZ was invalid");
      return { x: _, y: D };
    }
    isTorsionFree() {
      const { h: S, isTorsionFree: I } = t;
      if (S === Ye)
        return !0;
      if (I)
        return I(p, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: S, clearCofactor: I } = t;
      return S === Ye ? this : I ? I(p, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(S = !0) {
      return this.assertValidity(), n(p, this, S);
    }
    toHex(S = !0) {
      return Gr(this.toRawBytes(S));
    }
  }
  p.BASE = new p(t.Gx, t.Gy, r.ONE), p.ZERO = new p(r.ZERO, r.ONE, r.ZERO);
  const w = t.nBitLength, g = Ug(p, t.endo ? Math.ceil(w / 2) : w);
  return {
    CURVE: t,
    ProjectivePoint: p,
    normPrivateKeyToScalar: d,
    weierstrassEquation: i,
    isWithinCurveOrder: c
  };
}
function Mg(e) {
  const t = bh(e);
  return ci(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function gh(e) {
  const t = Mg(e), { Fp: r, n } = t, a = r.BYTES + 1, i = 2 * r.BYTES + 1;
  function c(y) {
    return tr < y && y < r.ORDER;
  }
  function s(y) {
    return St(y, n);
  }
  function d(y) {
    return Kc(y, n);
  }
  const { ProjectivePoint: f, normPrivateKeyToScalar: l, weierstrassEquation: p, isWithinCurveOrder: w } = ph({
    ...t,
    toBytes(y, L, M) {
      const H = L.toAffine(), F = r.toBytes(H.x), j = Zn;
      return M ? j(Uint8Array.from([L.hasEvenY() ? 2 : 3]), F) : j(Uint8Array.from([4]), F, r.toBytes(H.y));
    },
    fromBytes(y) {
      const L = y.length, M = y[0], H = y.subarray(1);
      if (L === a && (M === 2 || M === 3)) {
        const F = Pt(H);
        if (!c(F))
          throw new Error("Point is not on curve");
        const j = p(F);
        let V = r.sqrt(j);
        const W = (V & Ye) === Ye;
        return (M & 1) === 1 !== W && (V = r.neg(V)), { x: F, y: V };
      } else if (L === i && M === 4) {
        const F = r.fromBytes(H.subarray(0, r.BYTES)), j = r.fromBytes(H.subarray(r.BYTES, 2 * r.BYTES));
        return { x: F, y: j };
      } else
        throw new Error(`Point of length ${L} was invalid. Expected ${a} compressed bytes or ${i} uncompressed bytes`);
    }
  }), g = (y) => Gr(qn(y, t.nByteLength));
  function m(y) {
    const L = n >> Ye;
    return y > L;
  }
  function S(y) {
    return m(y) ? s(-y) : y;
  }
  const I = (y, L, M) => Pt(y.slice(L, M));
  class N {
    constructor(L, M, H) {
      this.r = L, this.s = M, this.recovery = H, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(L) {
      const M = t.nByteLength;
      return L = Bt("compactSignature", L, M * 2), new N(I(L, 0, M), I(L, M, 2 * M));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(L) {
      const { r: M, s: H } = Mr.toSig(Bt("DER", L));
      return new N(M, H);
    }
    assertValidity() {
      if (!w(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!w(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(L) {
      return new N(this.r, this.s, L);
    }
    recoverPublicKey(L) {
      const { r: M, s: H, recovery: F } = this, j = o(Bt("msgHash", L));
      if (F == null || ![0, 1, 2, 3].includes(F))
        throw new Error("recovery id invalid");
      const V = F === 2 || F === 3 ? M + t.n : M;
      if (V >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const W = F & 1 ? "03" : "02", K = f.fromHex(W + g(V)), Q = d(V), Z = s(-j * Q), te = s(H * Q), $ = f.BASE.multiplyAndAddUnsafe(K, Z, te);
      if (!$)
        throw new Error("point at infinify");
      return $.assertValidity(), $;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return m(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new N(this.r, s(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Wr(this.toDERHex());
    }
    toDERHex() {
      return Mr.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Wr(this.toCompactHex());
    }
    toCompactHex() {
      return g(this.r) + g(this.s);
    }
  }
  const x = {
    isValidPrivateKey(y) {
      try {
        return l(y), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: l,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const y = t.randomBytes(r.BYTES + 8), L = Rg(y, n);
      return qn(L, t.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(y = 8, L = f.BASE) {
      return L._setWindowSize(y), L.multiply(BigInt(3)), L;
    }
  };
  function C(y, L = !0) {
    return f.fromPrivateKey(y).toRawBytes(L);
  }
  function _(y) {
    const L = y instanceof Uint8Array, M = typeof y == "string", H = (L || M) && y.length;
    return L ? H === a || H === i : M ? H === 2 * a || H === 2 * i : y instanceof f;
  }
  function D(y, L, M = !0) {
    if (_(y))
      throw new Error("first arg must be private key");
    if (!_(L))
      throw new Error("second arg must be public key");
    return f.fromHex(L).multiply(l(y)).toRawBytes(M);
  }
  const b = t.bits2int || function(y) {
    const L = Pt(y), M = y.length * 8 - t.nBitLength;
    return M > 0 ? L >> BigInt(M) : L;
  }, o = t.bits2int_modN || function(y) {
    return s(b(y));
  }, h = Is(t.nBitLength);
  function U(y) {
    if (typeof y != "bigint")
      throw new Error("bigint expected");
    if (!(tr <= y && y < h))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return qn(y, t.nByteLength);
  }
  function E(y, L, M = T) {
    if (["recovered", "canonical"].some((R) => R in M))
      throw new Error("sign() legacy options not supported");
    const { hash: H, randomBytes: F } = t;
    let { lowS: j, prehash: V, extraEntropy: W } = M;
    j == null && (j = !0), y = Bt("msgHash", y), V && (y = Bt("prehashed msgHash", H(y)));
    const K = o(y), Q = l(L), Z = [U(Q), U(K)];
    if (W != null) {
      const R = W === !0 ? F(r.BYTES) : W;
      Z.push(Bt("extraEntropy", R, r.BYTES));
    }
    const te = Zn(...Z), $ = K;
    function B(R) {
      const u = b(R);
      if (!w(u))
        return;
      const O = d(u), G = f.BASE.multiply(u).toAffine(), Y = s(G.x);
      if (Y === tr)
        return;
      const ce = s(O * s($ + Y * Q));
      if (ce === tr)
        return;
      let pe = (G.x === Y ? 0 : 2) | Number(G.y & Ye), le = ce;
      return j && m(ce) && (le = S(ce), pe ^= 1), new N(Y, le, pe);
    }
    return { seed: te, k2sig: B };
  }
  const T = { lowS: t.lowS, prehash: !1 }, P = { lowS: t.lowS, prehash: !1 };
  function z(y, L, M = T) {
    const { seed: H, k2sig: F } = E(y, L, M);
    return th(t.hash.outputLen, t.nByteLength, t.hmac)(H, F);
  }
  f.BASE._setWindowSize(8);
  function v(y, L, M, H = P) {
    const F = y;
    if (L = Bt("msgHash", L), M = Bt("publicKey", M), "strict" in H)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: j, prehash: V } = H;
    let W, K;
    try {
      if (typeof F == "string" || F instanceof Uint8Array)
        try {
          W = N.fromDER(F);
        } catch (G) {
          if (!(G instanceof Mr.Err))
            throw G;
          W = N.fromCompact(F);
        }
      else if (typeof F == "object" && typeof F.r == "bigint" && typeof F.s == "bigint") {
        const { r: G, s: Y } = F;
        W = new N(G, Y);
      } else
        throw new Error("PARSE");
      K = f.fromHex(M);
    } catch (G) {
      if (G.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (j && W.hasHighS())
      return !1;
    V && (L = t.hash(L));
    const { r: Q, s: Z } = W, te = o(L), $ = d(Z), B = s(te * $), R = s(Q * $), u = f.BASE.multiplyAndAddUnsafe(K, B, R)?.toAffine();
    return u ? s(u.x) === Q : !1;
  }
  return {
    CURVE: t,
    getPublicKey: C,
    getSharedSecret: D,
    sign: z,
    verify: v,
    ProjectivePoint: f,
    Signature: N,
    utils: x
  };
}
function _h(e, t) {
  const r = e.ORDER;
  let n = tr;
  for (let w = r - Ye; w % xr === tr; w /= xr)
    n += Ye;
  const a = n, i = (r - Ye) / xr ** a, c = (i - Ye) / xr, s = xr ** a - Ye, d = xr ** (a - Ye), f = e.pow(t, i), l = e.pow(t, (i + Ye) / xr);
  let p = (w, g) => {
    let m = f, S = e.pow(g, s), I = e.sqr(S);
    I = e.mul(I, g);
    let N = e.mul(w, I);
    N = e.pow(N, c), N = e.mul(N, S), S = e.mul(N, g), I = e.mul(N, w);
    let x = e.mul(I, S);
    N = e.pow(x, d);
    let C = e.eql(N, e.ONE);
    S = e.mul(I, l), N = e.mul(x, m), I = e.cmov(S, I, C), x = e.cmov(N, x, C);
    for (let _ = a; _ > Ye; _--) {
      let D = xr ** (_ - xr), b = e.pow(x, D);
      const o = e.eql(b, e.ONE);
      S = e.mul(I, m), m = e.mul(m, m), b = e.mul(x, m), I = e.cmov(S, I, o), x = e.cmov(b, x, o);
    }
    return { isValid: C, value: I };
  };
  if (e.ORDER % E0 === Ji) {
    const w = (e.ORDER - Ji) / E0, g = e.sqrt(e.neg(t));
    p = (m, S) => {
      let I = e.sqr(S);
      const N = e.mul(m, S);
      I = e.mul(I, N);
      let x = e.pow(I, w);
      x = e.mul(x, N);
      const C = e.mul(x, g), _ = e.mul(e.sqr(x), S), D = e.eql(_, m);
      let b = e.cmov(C, x, D);
      return { isValid: D, value: b };
    };
  }
  return p;
}
function Hg(e, t) {
  if (Os(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const r = _h(e, t.Z);
  if (!e.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (n) => {
    let a, i, c, s, d, f, l, p;
    a = e.sqr(n), a = e.mul(a, t.Z), i = e.sqr(a), i = e.add(i, a), c = e.add(i, e.ONE), c = e.mul(c, t.B), s = e.cmov(t.Z, e.neg(i), !e.eql(i, e.ZERO)), s = e.mul(s, t.A), i = e.sqr(c), f = e.sqr(s), d = e.mul(f, t.A), i = e.add(i, d), i = e.mul(i, c), f = e.mul(f, s), d = e.mul(f, t.B), i = e.add(i, d), l = e.mul(a, c);
    const { isValid: w, value: g } = r(i, f);
    p = e.mul(a, n), p = e.mul(p, g), l = e.cmov(l, c, w), p = e.cmov(p, g, w);
    const m = e.isOdd(n) === e.isOdd(p);
    return p = e.cmov(e.neg(p), p, m), l = e.div(l, s), { x: l, y: p };
  };
}
const zg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DER: Mr,
  SWUFpSqrtRatio: _h,
  mapToCurveSimpleSWU: Hg,
  weierstrass: gh,
  weierstrassPoints: ph
}, Symbol.toStringTag, { value: "Module" }));
function Gc(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function jg(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function yh(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Vg(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Gc(e.outputLen), Gc(e.blockLen);
}
function qg(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Kg(e, t) {
  yh(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Oi = {
  number: Gc,
  bool: jg,
  bytes: yh,
  hash: Vg,
  exists: qg,
  output: Kg
}, sc = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Gg = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Gg)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Wg(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Zg(e) {
  if (typeof e == "string" && (e = Wg(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
function Yg(...e) {
  if (!e.every((n) => n instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (e.length === 1)
    return e[0];
  const t = e.reduce((n, a) => n + a.length, 0), r = new Uint8Array(t);
  for (let n = 0, a = 0; n < e.length; n++) {
    const i = e[n];
    r.set(i, a), a += i.length;
  }
  return r;
}
class Xg {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function Jg(e = 32) {
  if (sc && typeof sc.getRandomValues == "function")
    return sc.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
class wh extends Xg {
  constructor(t, r) {
    super(), this.finished = !1, this.destroyed = !1, Oi.hash(t);
    const n = Zg(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const a = this.blockLen, i = new Uint8Array(a);
    i.set(n.length > a ? t.create().update(n).digest() : n);
    for (let c = 0; c < i.length; c++)
      i[c] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let c = 0; c < i.length; c++)
      i[c] ^= 106;
    this.oHash.update(i), i.fill(0);
  }
  update(t) {
    return Oi.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Oi.exists(this), Oi.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: a, destroyed: i, blockLen: c, outputLen: s } = this;
    return t = t, t.finished = a, t.destroyed = i, t.blockLen = c, t.outputLen = s, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const mh = (e, t, r) => new wh(e, t).update(r).digest();
mh.create = (e, t) => new wh(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Qg(e) {
  return {
    hash: e,
    hmac: (t, ...r) => mh(e, t, Yg(...r)),
    randomBytes: Jg
  };
}
const Qi = BigInt("3618502788666131213697322783095070105526743751716087489154079457884512865583"), Eh = 252;
function v0(e) {
  for (; e[0] === 0; )
    e = e.subarray(1);
  const t = e.length * 8 - Eh, r = Pt(e);
  return t > 0 ? r >> BigInt(t) : r;
}
function vh(e) {
  return typeof e == "string" && (e = Wo(e), e.length & 1 && (e = "0" + e)), Wr(e);
}
const Tn = gh({
  a: BigInt(1),
  b: BigInt("3141592653589793238462643383279502884197169399375105820974944592307816406665"),
  Fp: qo(BigInt("0x800000000000011000000000000000000000000000000000000000000000001")),
  n: Qi,
  nBitLength: Eh,
  Gx: BigInt("874739451078007766457464989774322083649278607533249481151382481072868806602"),
  Gy: BigInt("152666792071518830868575557812948353041420400780739481342941381225525861407"),
  h: BigInt(1),
  lowS: !1,
  ...Qg(jo),
  bits2int: v0,
  bits2int_modN: (e) => {
    const t = Pt(e).toString(16);
    return t.length === 63 && (e = vh(t + "0")), St(v0(e), Qi);
  }
}), e_ = Tn;
function mn(e) {
  return Bt("", typeof e == "string" ? vh(e) : e);
}
function Ko(e) {
  return Gr(mn(e)).padStart(64, "0");
}
function xh(e, t = !1) {
  return Tn.getPublicKey(Ko(e), t);
}
function t_(e, t) {
  return Tn.getSharedSecret(Ko(e), t);
}
function Ta(e, t, r) {
  return Tn.sign(mn(e), Ko(t), r);
}
function r_(e, t, r) {
  const n = e instanceof Sh ? e : mn(e);
  return Tn.verify(n, mn(t), mn(r));
}
const { CURVE: n_, ProjectivePoint: $n, Signature: Sh, utils: Go } = Tn;
function Dh(e) {
  return `0x${Gr(e.subarray(1)).replace(/^0+/gm, "")}`;
}
function Wo(e) {
  return e.replace(/^0x/i, "");
}
function a_(e) {
  return `0x${e.toString(16)}`;
}
function Ah(e) {
  const t = mn(e), r = 2n ** 256n, n = r - St(r, Qi);
  for (let a = 0; ; a++) {
    const i = Wc(Zn(t, Ho(BigInt(a))));
    if (i < n)
      return St(i, Qi).toString(16);
    if (a === 1e5)
      throw new Error("grindKey is broken: tried 100k vals");
  }
}
function Zo(e) {
  return Dh(xh(e, !0));
}
function i_(e) {
  if (e = Wo(e), e.length !== 130)
    throw new Error("Wrong ethereum signature");
  return Ah(e.substring(0, 64));
}
const s_ = 2n ** 31n - 1n, Ni = (e) => Number(e & s_);
function c_(e, t, r, n) {
  const a = Ni(Wc(e)), i = Ni(Wc(t)), c = As(Wo(r));
  return `m/2645'/${a}'/${i}'/${Ni(c)}'/${Ni(c >> 31n)}'/${n}`;
}
const za = [
  new $n(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),
  new $n(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),
  new $n(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),
  new $n(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),
  new $n(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)
];
function Ih(e, t) {
  const r = [];
  let n = e;
  for (let a = 0; a < 248; a++)
    r.push(n), n = n.double();
  n = t;
  for (let a = 0; a < 4; a++)
    r.push(n), n = n.double();
  return r;
}
const o_ = Ih(za[1], za[2]), f_ = Ih(za[3], za[4]);
function Ch(e) {
  let t;
  if (typeof e == "bigint")
    t = e;
  else if (typeof e == "number") {
    if (!Number.isSafeInteger(e))
      throw new Error(`Invalid pedersenArg: ${e}`);
    t = BigInt(e);
  } else
    t = Pt(mn(e));
  if (!(0n <= t && t < Tn.CURVE.Fp.ORDER))
    throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${t}`);
  return t;
}
function x0(e, t, r) {
  let n = Ch(t);
  for (let a = 0; a < 252; a++) {
    const i = r[a];
    if (i.equals(e))
      throw new Error("Same point");
    (n & 1n) !== 0n && (e = e.add(i)), n >>= 1n;
  }
  return e;
}
function ia(e, t) {
  let r = za[0];
  return r = x0(r, e, o_), r = x0(r, t, f_), Dh(r.toRawBytes(!0));
}
function d_(e, t = ia) {
  if (!Array.isArray(e) || e.length < 1)
    throw new Error("data should be array of at least 1 element");
  return e.length === 1 ? a_(Ch(e[0])) : Array.from(e).reverse().reduce((r, n) => t(n, r));
}
const l_ = (e, t = ia) => [0, ...e, e.length].reduce((r, n) => t(r, n)), u_ = Is(250), oi = (e) => Pt(wg(e)) & u_, Wc = (e) => Pt(jo(e)), h_ = qo(BigInt("14474011154664525231415395255581126252639794253786371766033694892385558855681")), Th = qo(BigInt("3618502788666131213697322783095070105623107215331596699973092056135872020481"));
function Zc(e, t, r) {
  const n = e.fromBytes(jo(ah(`${t}${r}`)));
  return e.create(n);
}
function Oh(e, t, r, n = 0) {
  const a = [], i = [];
  for (let c = 0; c < r; c++)
    a.push(Zc(e, `${t}x`, n * r + c)), i.push(Zc(e, `${t}y`, n * r + c));
  if ((/* @__PURE__ */ new Set([...a, ...i])).size !== 2 * r)
    throw new Error("X and Y values are not distinct");
  return a.map((c) => i.map((s) => e.inv(e.sub(c, s))));
}
const b_ = [
  [3, 1, 1],
  [1, -1, 1],
  [1, 1, -2]
].map((e) => e.map(BigInt));
function Yo(e, t) {
  if (Os(e.Fp), !Number.isSafeInteger(e.rate) || !Number.isSafeInteger(e.capacity))
    throw new Error(`Wrong poseidon opts: ${e}`);
  const r = e.rate + e.capacity, n = e.roundsFull + e.roundsPartial, a = [];
  for (let c = 0; c < n; c++) {
    const s = [];
    for (let d = 0; d < r; d++)
      s.push(Zc(e.Fp, "Hades", r * c + d));
    a.push(s);
  }
  const i = hh({
    ...e,
    t: r,
    sboxPower: 3,
    reversePartialPowIdx: !0,
    mds: t,
    roundConstants: a
  });
  return i.m = r, i.rate = e.rate, i.capacity = e.capacity, i;
}
function p_(e, t = 0) {
  const r = e.rate + e.capacity;
  if (!Number.isSafeInteger(t))
    throw new Error(`Wrong mdsAttempt=${t}`);
  return Yo(e, Oh(e.Fp, "HadesMDS", r, t));
}
const fi = Yo({ Fp: Th, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, b_);
function Nh(e, t, r = fi) {
  return r([e, t, 2n])[0];
}
function g_(e, t, r = fi) {
  return Ho(Nh(Pt(e), Pt(t), r));
}
function __(e, t = fi) {
  return t([e, 0n, 1n])[0];
}
function Zr(e, t = fi) {
  const { m: r, rate: n } = t;
  if (!Array.isArray(e))
    throw new Error("bigint array expected in values");
  const a = Array.from(e);
  for (a.push(1n); a.length % n !== 0; )
    a.push(0n);
  let i = new Array(r).fill(0n);
  for (let c = 0; c < a.length; c += n) {
    for (let s = 0; s < n; s++)
      i[s] += a[c + s];
    i = t(i);
  }
  return i[0];
}
const y_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CURVE: n_,
  Fp251: Th,
  Fp253: h_,
  ProjectivePoint: $n,
  Signature: Sh,
  _poseidonMDS: Oh,
  _starkCurve: e_,
  computeHashOnElements: l_,
  ethSigToPrivate: i_,
  getAccountPath: c_,
  getPublicKey: xh,
  getSharedSecret: t_,
  getStarkKey: Zo,
  grindKey: Ah,
  hashChain: d_,
  keccak: oi,
  pedersen: ia,
  poseidonBasic: Yo,
  poseidonCreate: p_,
  poseidonHash: Nh,
  poseidonHashFunc: g_,
  poseidonHashMany: Zr,
  poseidonHashSingle: __,
  poseidonSmall: fi,
  sign: Ta,
  utils: Go,
  verify: r_
}, Symbol.toStringTag, { value: "Module" }));
function di(e) {
  return w_.test(e);
}
var w_ = /^-?[0-9]+$/;
function Rh(e) {
  return m_.test(e);
}
var m_ = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
function E_(e, t) {
  var r = parseFloat(e), n = String(r), a = S0(e), i = S0(n);
  if (a === i)
    return !0;
  if (t?.approx === !0) {
    var c = 14;
    if (!di(e) && i.length >= c && a.startsWith(i.substring(0, c)))
      return !0;
  }
  return !1;
}
var Oa = /* @__PURE__ */ function(e) {
  return e.underflow = "underflow", e.overflow = "overflow", e.truncate_integer = "truncate_integer", e.truncate_float = "truncate_float", e;
}({});
function v_(e) {
  if (!E_(e, {
    approx: !1
  })) {
    if (di(e))
      return Oa.truncate_integer;
    var t = parseFloat(e);
    return isFinite(t) ? t === 0 ? Oa.underflow : Oa.truncate_float : Oa.overflow;
  }
}
function S0(e) {
  return e.replace(x_, "").replace(D_, "").replace(A_, "").replace(S_, "");
}
var x_ = /[eE][+-]?\d+$/, S_ = /^-?(0*)?/, D_ = /\./, A_ = /0+$/;
function Yn(e) {
  "@babel/helpers - typeof";
  return Yn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Yn(e);
}
function I_(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function D0(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, Lh(n.key), n);
  }
}
function C_(e, t, r) {
  return t && D0(e.prototype, t), r && D0(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function T_(e, t, r) {
  return t = Lh(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
function Lh(e) {
  var t = O_(e, "string");
  return Yn(t) === "symbol" ? t : String(t);
}
function O_(e, t) {
  if (Yn(e) !== "object" || e === null)
    return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (Yn(n) !== "object")
      return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var N_ = /* @__PURE__ */ function() {
  function e(t) {
    if (I_(this, e), T_(this, "isLosslessNumber", !0), !Rh(t))
      throw new Error('Invalid number (value: "' + t + '")');
    this.value = t;
  }
  return C_(e, [{
    key: "valueOf",
    value: function() {
      var r = v_(this.value);
      if (r === void 0 || r === Oa.truncate_float)
        return parseFloat(this.value);
      if (di(this.value))
        return BigInt(this.value);
      throw new Error("Cannot safely convert to number: " + "the value '".concat(this.value, "' would ").concat(r, " and become ").concat(parseFloat(this.value)));
    }
    /**
     * Get the value of the LosslessNumber as string.
     */
  }, {
    key: "toString",
    value: function() {
      return this.value;
    }
    // Note: we do NOT implement a .toJSON() method, and you should not implement
    // or use that, it cannot safely turn the numeric value in the string into
    // stringified JSON since it has to be parsed into a number first.
  }]), e;
}();
function R_(e) {
  return e && Yn(e) === "object" && e.isLosslessNumber === !0 || !1;
}
function L_(e) {
  return new N_(e);
}
function P_(e) {
  return di(e) ? BigInt(e) : parseFloat(e);
}
function Yc(e) {
  "@babel/helpers - typeof";
  return Yc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Yc(e);
}
function k_(e, t) {
  return Xo({
    "": e
  }, "", e, t);
}
function Xo(e, t, r, n) {
  return Array.isArray(r) ? n.call(e, t, F_(r, n)) : r && Yc(r) === "object" && !R_(r) ? n.call(e, t, U_(r, n)) : n.call(e, t, r);
}
function U_(e, t) {
  return Object.keys(e).forEach(function(r) {
    var n = Xo(e, r, e[r], t);
    n !== void 0 ? e[r] = n : delete e[r];
  }), e;
}
function F_(e, t) {
  for (var r = 0; r < e.length; r++)
    e[r] = Xo(e, r + "", e[r], t);
  return e;
}
function Xc(e) {
  "@babel/helpers - typeof";
  return Xc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Xc(e);
}
function cc(e) {
  return H_(e) || M_(e) || B_(e) || $_();
}
function $_() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function B_(e, t) {
  if (e) {
    if (typeof e == "string")
      return Jc(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set")
      return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return Jc(e, t);
  }
}
function M_(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function H_(e) {
  if (Array.isArray(e))
    return Jc(e);
}
function Jc(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++)
    n[r] = e[r];
  return n;
}
function Ph(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : L_, n = 0, a = s();
  return m(a), I(), t ? k_(a, t) : a;
  function i() {
    if (e.charCodeAt(n) === G_) {
      n++, f();
      for (var v = {}, y = !0; n < e.length && e.charCodeAt(n) !== I0; ) {
        y ? y = !1 : (w(), f());
        var L = n, M = l();
        M === void 0 && C(), f(), g();
        var H = s();
        H === void 0 && U(), Object.prototype.hasOwnProperty.call(v, M) && !Qc(H, v[M]) && _(M, L + 1), v[M] = H;
      }
      return e.charCodeAt(n) !== I0 && D(), n++, v;
    }
  }
  function c() {
    if (e.charCodeAt(n) === W_) {
      n++, f();
      for (var v = [], y = !0; n < e.length && e.charCodeAt(n) !== C0; ) {
        y ? y = !1 : w();
        var L = s();
        S(L), v.push(L);
      }
      return e.charCodeAt(n) !== C0 && b(), n++, v;
    }
  }
  function s() {
    var v, y, L, M, H, F;
    f();
    var j = (v = (y = (L = (M = (H = (F = l()) !== null && F !== void 0 ? F : p()) !== null && H !== void 0 ? H : i()) !== null && M !== void 0 ? M : c()) !== null && L !== void 0 ? L : d("true", !0)) !== null && y !== void 0 ? y : d("false", !1)) !== null && v !== void 0 ? v : d("null", null);
    return f(), j;
  }
  function d(v, y) {
    if (e.slice(n, n + v.length) === v)
      return n += v.length, y;
  }
  function f() {
    for (; z_(e.charCodeAt(n)); )
      n++;
  }
  function l() {
    if (e.charCodeAt(n) === oc) {
      n++;
      for (var v = ""; n < e.length && e.charCodeAt(n) !== oc; ) {
        if (e.charCodeAt(n) === K_) {
          var y = e[n + 1], L = q_[y];
          L !== void 0 ? (v += L, n++) : y === "u" ? Ri(e.charCodeAt(n + 2)) && Ri(e.charCodeAt(n + 3)) && Ri(e.charCodeAt(n + 4)) && Ri(e.charCodeAt(n + 5)) ? (v += String.fromCharCode(parseInt(e.slice(n + 2, n + 6), 16)), n += 5) : E(n) : h(n);
        } else
          V_(e.charCodeAt(n)) ? v += e[n] : o(e[n]);
        n++;
      }
      return x(), n++, v;
    }
  }
  function p() {
    var v = n;
    if (e.charCodeAt(n) === T0 && (n++, N(v)), e.charCodeAt(n) === Jo)
      n++;
    else if (j_(e.charCodeAt(n)))
      for (n++; Li(e.charCodeAt(n)); )
        n++;
    if (e.charCodeAt(n) === ry)
      for (n++, N(v); Li(e.charCodeAt(n)); )
        n++;
    if (e.charCodeAt(n) === cy || e.charCodeAt(n) === sy)
      for (n++, (e.charCodeAt(n) === T0 || e.charCodeAt(n) === Q_) && n++, N(v); Li(e.charCodeAt(n)); )
        n++;
    if (n > v)
      return r(e.slice(v, n));
  }
  function w() {
    if (e.charCodeAt(n) !== ty)
      throw new SyntaxError("Comma ',' expected after value ".concat(z()));
    n++;
  }
  function g() {
    if (e.charCodeAt(n) !== ny)
      throw new SyntaxError("Colon ':' expected after property name ".concat(z()));
    n++;
  }
  function m(v) {
    if (v === void 0)
      throw new SyntaxError("JSON value expected ".concat(z()));
  }
  function S(v) {
    if (v === void 0)
      throw new SyntaxError("Array item expected ".concat(z()));
  }
  function I() {
    if (n < e.length)
      throw new SyntaxError("Expected end of input ".concat(z()));
  }
  function N(v) {
    if (!Li(e.charCodeAt(n))) {
      var y = e.slice(v, n);
      throw new SyntaxError("Invalid number '".concat(y, "', expecting a digit ").concat(z()));
    }
  }
  function x() {
    if (e.charCodeAt(n) !== oc)
      throw new SyntaxError(`End of string '"' expected `.concat(z()));
  }
  function C() {
    throw new SyntaxError("Quoted object key expected ".concat(z()));
  }
  function _(v, y) {
    throw new SyntaxError("Duplicate key '".concat(v, "' encountered at position ").concat(y));
  }
  function D() {
    throw new SyntaxError("Quoted object key or end of object '}' expected ".concat(z()));
  }
  function b() {
    throw new SyntaxError("Array item or end of array ']' expected ".concat(z()));
  }
  function o(v) {
    throw new SyntaxError("Invalid character '".concat(v, "' ").concat(T()));
  }
  function h(v) {
    var y = e.slice(v, v + 2);
    throw new SyntaxError("Invalid escape character '".concat(y, "' ").concat(T()));
  }
  function U() {
    throw new SyntaxError("Object value expected after ':' ".concat(T()));
  }
  function E(v) {
    for (var y = v + 2; /\w/.test(e[y]); )
      y++;
    var L = e.slice(v, y);
    throw new SyntaxError("Invalid unicode character '".concat(L, "' ").concat(T()));
  }
  function T() {
    return "at position ".concat(n);
  }
  function P() {
    return n < e.length ? "but got '".concat(e[n], "'") : "but reached end of input";
  }
  function z() {
    return P() + " " + T();
  }
}
function z_(e) {
  return e === Z_ || e === Y_ || e === X_ || e === J_;
}
function Ri(e) {
  return e >= Jo && e <= Qo || e >= ay && e <= oy || e >= iy && e <= fy;
}
function Li(e) {
  return e >= Jo && e <= Qo;
}
function j_(e) {
  return e >= ey && e <= Qo;
}
function V_(e) {
  return e >= 32 && e <= 1114111;
}
function Qc(e, t) {
  if (e === t)
    return !0;
  if (Array.isArray(e) && Array.isArray(t))
    return e.length === t.length && e.every(function(n, a) {
      return Qc(n, t[a]);
    });
  if (A0(e) && A0(t)) {
    var r = cc(new Set([].concat(cc(Object.keys(e)), cc(Object.keys(t)))));
    return r.every(function(n) {
      return Qc(e[n], t[n]);
    });
  }
  return !1;
}
function A0(e) {
  return Xc(e) === "object" && e !== null;
}
var q_ = {
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: `
`,
  r: "\r",
  t: "	"
  // note that \u is handled separately in parseString()
}, K_ = 92, G_ = 123, I0 = 125, W_ = 91, C0 = 93, Z_ = 32, Y_ = 10, X_ = 9, J_ = 13, oc = 34, Q_ = 43, T0 = 45, Jo = 48, ey = 49, Qo = 57, ty = 44, ry = 46, ny = 58, ay = 65, iy = 97, sy = 69, cy = 101, oy = 70, fy = 102;
function es(e) {
  "@babel/helpers - typeof";
  return es = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, es(e);
}
function kh(e, t, r, n) {
  var a = dy(r), i = typeof t == "function" ? t.call({
    "": e
  }, "", e) : e;
  return c(i, "");
  function c(l, p) {
    if (Array.isArray(n)) {
      var w = n.find(function(m) {
        return m.test(l);
      });
      if (w) {
        var g = w.stringify(l);
        if (typeof g != "string" || !Rh(g))
          throw new Error("Invalid JSON number: output of a number stringifier must be a string containing a JSON number " + "(output: ".concat(g, ")"));
        return g;
      }
    }
    if (typeof l == "boolean" || typeof l == "number" || typeof l == "string" || l === null || l instanceof Date || l instanceof Boolean || l instanceof Number || l instanceof String)
      return JSON.stringify(l);
    if (l && l.isLosslessNumber || typeof l == "bigint")
      return l.toString();
    if (Array.isArray(l))
      return s(l, p);
    if (l && es(l) === "object")
      return d(l, p);
  }
  function s(l, p) {
    if (l.length === 0)
      return "[]";
    for (var w = a ? p + a : void 0, g = a ? `[
` : "[", m = 0; m < l.length; m++) {
      var S = typeof t == "function" ? t.call(l, String(m), l[m]) : l[m];
      a && (g += w), typeof S < "u" && typeof S != "function" ? g += c(S, w) : g += "null", m < l.length - 1 && (g += a ? `,
` : ",");
    }
    return g += a ? `
` + p + "]" : "]", g;
  }
  function d(l, p) {
    if (typeof l.toJSON == "function")
      return kh(l.toJSON(), t, r, void 0);
    var w = Array.isArray(t) ? t.map(String) : Object.keys(l);
    if (w.length === 0)
      return "{}";
    var g = a ? p + a : void 0, m = !0, S = a ? `{
` : "{";
    return w.forEach(function(I) {
      var N = typeof t == "function" ? t.call(l, I, l[I]) : l[I];
      if (f(I, N)) {
        m ? m = !1 : S += a ? `,
` : ",";
        var x = JSON.stringify(I);
        S += a ? g + x + ": " : x + ":", S += c(N, g);
      }
    }), S += a ? `
` + p + "}" : "}", S;
  }
  function f(l, p) {
    return typeof p < "u" && typeof p != "function" && es(p) !== "symbol";
  }
}
function dy(e) {
  if (typeof e == "number")
    return " ".repeat(e);
  if (typeof e == "string" && e !== "")
    return e;
}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const ly = 4, O0 = 0, N0 = 1, uy = 2;
function sa(e) {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}
const hy = 0, Uh = 1, by = 2, py = 3, gy = 258, ef = 29, li = 256, ja = li + 1 + ef, Kn = 30, tf = 19, Fh = 2 * ja + 1, gn = 15, fc = 16, _y = 7, rf = 256, $h = 16, Bh = 17, Mh = 18, eo = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), zi = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), yy = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), Hh = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), wy = 512, Ir = new Array((ja + 2) * 2);
sa(Ir);
const ka = new Array(Kn * 2);
sa(ka);
const Va = new Array(wy);
sa(Va);
const qa = new Array(gy - py + 1);
sa(qa);
const nf = new Array(ef);
sa(nf);
const ts = new Array(Kn);
sa(ts);
function dc(e, t, r, n, a) {
  this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = n, this.max_length = a, this.has_stree = e && e.length;
}
let zh, jh, Vh;
function lc(e, t) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
}
const qh = (e) => e < 256 ? Va[e] : Va[256 + (e >>> 7)], Ka = (e, t) => {
  e.pending_buf[e.pending++] = t & 255, e.pending_buf[e.pending++] = t >>> 8 & 255;
}, Lt = (e, t, r) => {
  e.bi_valid > fc - r ? (e.bi_buf |= t << e.bi_valid & 65535, Ka(e, e.bi_buf), e.bi_buf = t >> fc - e.bi_valid, e.bi_valid += r - fc) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r);
}, lr = (e, t, r) => {
  Lt(
    e,
    r[t * 2],
    r[t * 2 + 1]
    /*.Len*/
  );
}, Kh = (e, t) => {
  let r = 0;
  do
    r |= e & 1, e >>>= 1, r <<= 1;
  while (--t > 0);
  return r >>> 1;
}, my = (e) => {
  e.bi_valid === 16 ? (Ka(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, Ey = (e, t) => {
  const r = t.dyn_tree, n = t.max_code, a = t.stat_desc.static_tree, i = t.stat_desc.has_stree, c = t.stat_desc.extra_bits, s = t.stat_desc.extra_base, d = t.stat_desc.max_length;
  let f, l, p, w, g, m, S = 0;
  for (w = 0; w <= gn; w++)
    e.bl_count[w] = 0;
  for (r[e.heap[e.heap_max] * 2 + 1] = 0, f = e.heap_max + 1; f < Fh; f++)
    l = e.heap[f], w = r[r[l * 2 + 1] * 2 + 1] + 1, w > d && (w = d, S++), r[l * 2 + 1] = w, !(l > n) && (e.bl_count[w]++, g = 0, l >= s && (g = c[l - s]), m = r[l * 2], e.opt_len += m * (w + g), i && (e.static_len += m * (a[l * 2 + 1] + g)));
  if (S !== 0) {
    do {
      for (w = d - 1; e.bl_count[w] === 0; )
        w--;
      e.bl_count[w]--, e.bl_count[w + 1] += 2, e.bl_count[d]--, S -= 2;
    } while (S > 0);
    for (w = d; w !== 0; w--)
      for (l = e.bl_count[w]; l !== 0; )
        p = e.heap[--f], !(p > n) && (r[p * 2 + 1] !== w && (e.opt_len += (w - r[p * 2 + 1]) * r[p * 2], r[p * 2 + 1] = w), l--);
  }
}, Gh = (e, t, r) => {
  const n = new Array(gn + 1);
  let a = 0, i, c;
  for (i = 1; i <= gn; i++)
    a = a + r[i - 1] << 1, n[i] = a;
  for (c = 0; c <= t; c++) {
    let s = e[c * 2 + 1];
    s !== 0 && (e[c * 2] = Kh(n[s]++, s));
  }
}, vy = () => {
  let e, t, r, n, a;
  const i = new Array(gn + 1);
  for (r = 0, n = 0; n < ef - 1; n++)
    for (nf[n] = r, e = 0; e < 1 << eo[n]; e++)
      qa[r++] = n;
  for (qa[r - 1] = n, a = 0, n = 0; n < 16; n++)
    for (ts[n] = a, e = 0; e < 1 << zi[n]; e++)
      Va[a++] = n;
  for (a >>= 7; n < Kn; n++)
    for (ts[n] = a << 7, e = 0; e < 1 << zi[n] - 7; e++)
      Va[256 + a++] = n;
  for (t = 0; t <= gn; t++)
    i[t] = 0;
  for (e = 0; e <= 143; )
    Ir[e * 2 + 1] = 8, e++, i[8]++;
  for (; e <= 255; )
    Ir[e * 2 + 1] = 9, e++, i[9]++;
  for (; e <= 279; )
    Ir[e * 2 + 1] = 7, e++, i[7]++;
  for (; e <= 287; )
    Ir[e * 2 + 1] = 8, e++, i[8]++;
  for (Gh(Ir, ja + 1, i), e = 0; e < Kn; e++)
    ka[e * 2 + 1] = 5, ka[e * 2] = Kh(e, 5);
  zh = new dc(Ir, eo, li + 1, ja, gn), jh = new dc(ka, zi, 0, Kn, gn), Vh = new dc(new Array(0), yy, 0, tf, _y);
}, Wh = (e) => {
  let t;
  for (t = 0; t < ja; t++)
    e.dyn_ltree[t * 2] = 0;
  for (t = 0; t < Kn; t++)
    e.dyn_dtree[t * 2] = 0;
  for (t = 0; t < tf; t++)
    e.bl_tree[t * 2] = 0;
  e.dyn_ltree[rf * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
}, Zh = (e) => {
  e.bi_valid > 8 ? Ka(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, R0 = (e, t, r, n) => {
  const a = t * 2, i = r * 2;
  return e[a] < e[i] || e[a] === e[i] && n[t] <= n[r];
}, uc = (e, t, r) => {
  const n = e.heap[r];
  let a = r << 1;
  for (; a <= e.heap_len && (a < e.heap_len && R0(t, e.heap[a + 1], e.heap[a], e.depth) && a++, !R0(t, n, e.heap[a], e.depth)); )
    e.heap[r] = e.heap[a], r = a, a <<= 1;
  e.heap[r] = n;
}, L0 = (e, t, r) => {
  let n, a, i = 0, c, s;
  if (e.sym_next !== 0)
    do
      n = e.pending_buf[e.sym_buf + i++] & 255, n += (e.pending_buf[e.sym_buf + i++] & 255) << 8, a = e.pending_buf[e.sym_buf + i++], n === 0 ? lr(e, a, t) : (c = qa[a], lr(e, c + li + 1, t), s = eo[c], s !== 0 && (a -= nf[c], Lt(e, a, s)), n--, c = qh(n), lr(e, c, r), s = zi[c], s !== 0 && (n -= ts[c], Lt(e, n, s)));
    while (i < e.sym_next);
  lr(e, rf, t);
}, to = (e, t) => {
  const r = t.dyn_tree, n = t.stat_desc.static_tree, a = t.stat_desc.has_stree, i = t.stat_desc.elems;
  let c, s, d = -1, f;
  for (e.heap_len = 0, e.heap_max = Fh, c = 0; c < i; c++)
    r[c * 2] !== 0 ? (e.heap[++e.heap_len] = d = c, e.depth[c] = 0) : r[c * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    f = e.heap[++e.heap_len] = d < 2 ? ++d : 0, r[f * 2] = 1, e.depth[f] = 0, e.opt_len--, a && (e.static_len -= n[f * 2 + 1]);
  for (t.max_code = d, c = e.heap_len >> 1; c >= 1; c--)
    uc(e, r, c);
  f = i;
  do
    c = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], uc(
      e,
      r,
      1
      /*SMALLEST*/
    ), s = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = c, e.heap[--e.heap_max] = s, r[f * 2] = r[c * 2] + r[s * 2], e.depth[f] = (e.depth[c] >= e.depth[s] ? e.depth[c] : e.depth[s]) + 1, r[c * 2 + 1] = r[s * 2 + 1] = f, e.heap[
      1
      /*SMALLEST*/
    ] = f++, uc(
      e,
      r,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], Ey(e, t), Gh(r, d, e.bl_count);
}, P0 = (e, t, r) => {
  let n, a = -1, i, c = t[0 * 2 + 1], s = 0, d = 7, f = 4;
  for (c === 0 && (d = 138, f = 3), t[(r + 1) * 2 + 1] = 65535, n = 0; n <= r; n++)
    i = c, c = t[(n + 1) * 2 + 1], !(++s < d && i === c) && (s < f ? e.bl_tree[i * 2] += s : i !== 0 ? (i !== a && e.bl_tree[i * 2]++, e.bl_tree[$h * 2]++) : s <= 10 ? e.bl_tree[Bh * 2]++ : e.bl_tree[Mh * 2]++, s = 0, a = i, c === 0 ? (d = 138, f = 3) : i === c ? (d = 6, f = 3) : (d = 7, f = 4));
}, k0 = (e, t, r) => {
  let n, a = -1, i, c = t[0 * 2 + 1], s = 0, d = 7, f = 4;
  for (c === 0 && (d = 138, f = 3), n = 0; n <= r; n++)
    if (i = c, c = t[(n + 1) * 2 + 1], !(++s < d && i === c)) {
      if (s < f)
        do
          lr(e, i, e.bl_tree);
        while (--s !== 0);
      else
        i !== 0 ? (i !== a && (lr(e, i, e.bl_tree), s--), lr(e, $h, e.bl_tree), Lt(e, s - 3, 2)) : s <= 10 ? (lr(e, Bh, e.bl_tree), Lt(e, s - 3, 3)) : (lr(e, Mh, e.bl_tree), Lt(e, s - 11, 7));
      s = 0, a = i, c === 0 ? (d = 138, f = 3) : i === c ? (d = 6, f = 3) : (d = 7, f = 4);
    }
}, xy = (e) => {
  let t;
  for (P0(e, e.dyn_ltree, e.l_desc.max_code), P0(e, e.dyn_dtree, e.d_desc.max_code), to(e, e.bl_desc), t = tf - 1; t >= 3 && e.bl_tree[Hh[t] * 2 + 1] === 0; t--)
    ;
  return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}, Sy = (e, t, r, n) => {
  let a;
  for (Lt(e, t - 257, 5), Lt(e, r - 1, 5), Lt(e, n - 4, 4), a = 0; a < n; a++)
    Lt(e, e.bl_tree[Hh[a] * 2 + 1], 3);
  k0(e, e.dyn_ltree, t - 1), k0(e, e.dyn_dtree, r - 1);
}, Dy = (e) => {
  let t = 4093624447, r;
  for (r = 0; r <= 31; r++, t >>>= 1)
    if (t & 1 && e.dyn_ltree[r * 2] !== 0)
      return O0;
  if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0)
    return N0;
  for (r = 32; r < li; r++)
    if (e.dyn_ltree[r * 2] !== 0)
      return N0;
  return O0;
};
let U0 = !1;
const Ay = (e) => {
  U0 || (vy(), U0 = !0), e.l_desc = new lc(e.dyn_ltree, zh), e.d_desc = new lc(e.dyn_dtree, jh), e.bl_desc = new lc(e.bl_tree, Vh), e.bi_buf = 0, e.bi_valid = 0, Wh(e);
}, Yh = (e, t, r, n) => {
  Lt(e, (hy << 1) + (n ? 1 : 0), 3), Zh(e), Ka(e, r), Ka(e, ~r), r && e.pending_buf.set(e.window.subarray(t, t + r), e.pending), e.pending += r;
}, Iy = (e) => {
  Lt(e, Uh << 1, 3), lr(e, rf, Ir), my(e);
}, Cy = (e, t, r, n) => {
  let a, i, c = 0;
  e.level > 0 ? (e.strm.data_type === uy && (e.strm.data_type = Dy(e)), to(e, e.l_desc), to(e, e.d_desc), c = xy(e), a = e.opt_len + 3 + 7 >>> 3, i = e.static_len + 3 + 7 >>> 3, i <= a && (a = i)) : a = i = r + 5, r + 4 <= a && t !== -1 ? Yh(e, t, r, n) : e.strategy === ly || i === a ? (Lt(e, (Uh << 1) + (n ? 1 : 0), 3), L0(e, Ir, ka)) : (Lt(e, (by << 1) + (n ? 1 : 0), 3), Sy(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, c + 1), L0(e, e.dyn_ltree, e.dyn_dtree)), Wh(e), n && Zh(e);
}, Ty = (e, t, r) => (e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = r, t === 0 ? e.dyn_ltree[r * 2]++ : (e.matches++, t--, e.dyn_ltree[(qa[r] + li + 1) * 2]++, e.dyn_dtree[qh(t) * 2]++), e.sym_next === e.sym_end);
var Oy = Ay, Ny = Yh, Ry = Cy, Ly = Ty, Py = Iy, ky = {
  _tr_init: Oy,
  _tr_stored_block: Ny,
  _tr_flush_block: Ry,
  _tr_tally: Ly,
  _tr_align: Py
};
const Uy = (e, t, r, n) => {
  let a = e & 65535 | 0, i = e >>> 16 & 65535 | 0, c = 0;
  for (; r !== 0; ) {
    c = r > 2e3 ? 2e3 : r, r -= c;
    do
      a = a + t[n++] | 0, i = i + a | 0;
    while (--c);
    a %= 65521, i %= 65521;
  }
  return a | i << 16 | 0;
};
var Ga = Uy;
const Fy = () => {
  let e, t = [];
  for (var r = 0; r < 256; r++) {
    e = r;
    for (var n = 0; n < 8; n++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[r] = e;
  }
  return t;
}, $y = new Uint32Array(Fy()), By = (e, t, r, n) => {
  const a = $y, i = n + r;
  e ^= -1;
  for (let c = n; c < i; c++)
    e = e >>> 8 ^ a[(e ^ t[c]) & 255];
  return e ^ -1;
};
var ft = By, En = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, ca = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: My, _tr_stored_block: ro, _tr_flush_block: Hy, _tr_tally: jr, _tr_align: zy } = ky, {
  Z_NO_FLUSH: Vr,
  Z_PARTIAL_FLUSH: jy,
  Z_FULL_FLUSH: Vy,
  Z_FINISH: Wt,
  Z_BLOCK: F0,
  Z_OK: bt,
  Z_STREAM_END: $0,
  Z_STREAM_ERROR: hr,
  Z_DATA_ERROR: qy,
  Z_BUF_ERROR: hc,
  Z_DEFAULT_COMPRESSION: Ky,
  Z_FILTERED: Gy,
  Z_HUFFMAN_ONLY: Pi,
  Z_RLE: Wy,
  Z_FIXED: Zy,
  Z_DEFAULT_STRATEGY: Yy,
  Z_UNKNOWN: Xy,
  Z_DEFLATED: Ns
} = ca, Jy = 9, Qy = 15, ew = 8, tw = 29, rw = 256, no = rw + 1 + tw, nw = 30, aw = 19, iw = 2 * no + 1, sw = 15, we = 3, Hr = 258, br = Hr + we + 1, cw = 32, Xn = 42, af = 57, ao = 69, io = 73, so = 91, co = 103, _n = 113, Na = 666, It = 1, oa = 2, vn = 3, fa = 4, ow = 3, yn = (e, t) => (e.msg = En[t], t), B0 = (e) => e * 2 - (e > 4 ? 9 : 0), Br = (e) => {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}, fw = (e) => {
  let t, r, n, a = e.w_size;
  t = e.hash_size, n = t;
  do
    r = e.head[--n], e.head[n] = r >= a ? r - a : 0;
  while (--t);
  t = a, n = t;
  do
    r = e.prev[--n], e.prev[n] = r >= a ? r - a : 0;
  while (--t);
};
let dw = (e, t, r) => (t << e.hash_shift ^ r) & e.hash_mask, qr = dw;
const $t = (e) => {
  const t = e.state;
  let r = t.pending;
  r > e.avail_out && (r = e.avail_out), r !== 0 && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + r), e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, t.pending === 0 && (t.pending_out = 0));
}, Ht = (e, t) => {
  Hy(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, $t(e.strm);
}, Ie = (e, t) => {
  e.pending_buf[e.pending++] = t;
}, Ia = (e, t) => {
  e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = t & 255;
}, oo = (e, t, r, n) => {
  let a = e.avail_in;
  return a > n && (a = n), a === 0 ? 0 : (e.avail_in -= a, t.set(e.input.subarray(e.next_in, e.next_in + a), r), e.state.wrap === 1 ? e.adler = Ga(e.adler, t, a, r) : e.state.wrap === 2 && (e.adler = ft(e.adler, t, a, r)), e.next_in += a, e.total_in += a, a);
}, Xh = (e, t) => {
  let r = e.max_chain_length, n = e.strstart, a, i, c = e.prev_length, s = e.nice_match;
  const d = e.strstart > e.w_size - br ? e.strstart - (e.w_size - br) : 0, f = e.window, l = e.w_mask, p = e.prev, w = e.strstart + Hr;
  let g = f[n + c - 1], m = f[n + c];
  e.prev_length >= e.good_match && (r >>= 2), s > e.lookahead && (s = e.lookahead);
  do
    if (a = t, !(f[a + c] !== m || f[a + c - 1] !== g || f[a] !== f[n] || f[++a] !== f[n + 1])) {
      n += 2, a++;
      do
        ;
      while (f[++n] === f[++a] && f[++n] === f[++a] && f[++n] === f[++a] && f[++n] === f[++a] && f[++n] === f[++a] && f[++n] === f[++a] && f[++n] === f[++a] && f[++n] === f[++a] && n < w);
      if (i = Hr - (w - n), n = w - Hr, i > c) {
        if (e.match_start = t, c = i, i >= s)
          break;
        g = f[n + c - 1], m = f[n + c];
      }
    }
  while ((t = p[t & l]) > d && --r !== 0);
  return c <= e.lookahead ? c : e.lookahead;
}, Jn = (e) => {
  const t = e.w_size;
  let r, n, a;
  do {
    if (n = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - br) && (e.window.set(e.window.subarray(t, t + t - n), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, e.insert > e.strstart && (e.insert = e.strstart), fw(e), n += t), e.strm.avail_in === 0)
      break;
    if (r = oo(e.strm, e.window, e.strstart + e.lookahead, n), e.lookahead += r, e.lookahead + e.insert >= we)
      for (a = e.strstart - e.insert, e.ins_h = e.window[a], e.ins_h = qr(e, e.ins_h, e.window[a + 1]); e.insert && (e.ins_h = qr(e, e.ins_h, e.window[a + we - 1]), e.prev[a & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = a, a++, e.insert--, !(e.lookahead + e.insert < we)); )
        ;
  } while (e.lookahead < br && e.strm.avail_in !== 0);
}, Jh = (e, t) => {
  let r = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, n, a, i, c = 0, s = e.strm.avail_in;
  do {
    if (n = 65535, i = e.bi_valid + 42 >> 3, e.strm.avail_out < i || (i = e.strm.avail_out - i, a = e.strstart - e.block_start, n > a + e.strm.avail_in && (n = a + e.strm.avail_in), n > i && (n = i), n < r && (n === 0 && t !== Wt || t === Vr || n !== a + e.strm.avail_in)))
      break;
    c = t === Wt && n === a + e.strm.avail_in ? 1 : 0, ro(e, 0, 0, c), e.pending_buf[e.pending - 4] = n, e.pending_buf[e.pending - 3] = n >> 8, e.pending_buf[e.pending - 2] = ~n, e.pending_buf[e.pending - 1] = ~n >> 8, $t(e.strm), a && (a > n && (a = n), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + a), e.strm.next_out), e.strm.next_out += a, e.strm.avail_out -= a, e.strm.total_out += a, e.block_start += a, n -= a), n && (oo(e.strm, e.strm.output, e.strm.next_out, n), e.strm.next_out += n, e.strm.avail_out -= n, e.strm.total_out += n);
  } while (c === 0);
  return s -= e.strm.avail_in, s && (s >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= s && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - s, e.strm.next_in), e.strstart), e.strstart += s, e.insert += s > e.w_size - e.insert ? e.w_size - e.insert : s), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), c ? fa : t !== Vr && t !== Wt && e.strm.avail_in === 0 && e.strstart === e.block_start ? oa : (i = e.window_size - e.strstart, e.strm.avail_in > i && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, i += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), i > e.strm.avail_in && (i = e.strm.avail_in), i && (oo(e.strm, e.window, e.strstart, i), e.strstart += i, e.insert += i > e.w_size - e.insert ? e.w_size - e.insert : i), e.high_water < e.strstart && (e.high_water = e.strstart), i = e.bi_valid + 42 >> 3, i = e.pending_buf_size - i > 65535 ? 65535 : e.pending_buf_size - i, r = i > e.w_size ? e.w_size : i, a = e.strstart - e.block_start, (a >= r || (a || t === Wt) && t !== Vr && e.strm.avail_in === 0 && a <= i) && (n = a > i ? i : a, c = t === Wt && e.strm.avail_in === 0 && n === a ? 1 : 0, ro(e, e.block_start, n, c), e.block_start += n, $t(e.strm)), c ? vn : It);
}, bc = (e, t) => {
  let r, n;
  for (; ; ) {
    if (e.lookahead < br) {
      if (Jn(e), e.lookahead < br && t === Vr)
        return It;
      if (e.lookahead === 0)
        break;
    }
    if (r = 0, e.lookahead >= we && (e.ins_h = qr(e, e.ins_h, e.window[e.strstart + we - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), r !== 0 && e.strstart - r <= e.w_size - br && (e.match_length = Xh(e, r)), e.match_length >= we)
      if (n = jr(e, e.strstart - e.match_start, e.match_length - we), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= we) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = qr(e, e.ins_h, e.window[e.strstart + we - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = qr(e, e.ins_h, e.window[e.strstart + 1]);
    else
      n = jr(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (n && (Ht(e, !1), e.strm.avail_out === 0))
      return It;
  }
  return e.insert = e.strstart < we - 1 ? e.strstart : we - 1, t === Wt ? (Ht(e, !0), e.strm.avail_out === 0 ? vn : fa) : e.sym_next && (Ht(e, !1), e.strm.avail_out === 0) ? It : oa;
}, Pn = (e, t) => {
  let r, n, a;
  for (; ; ) {
    if (e.lookahead < br) {
      if (Jn(e), e.lookahead < br && t === Vr)
        return It;
      if (e.lookahead === 0)
        break;
    }
    if (r = 0, e.lookahead >= we && (e.ins_h = qr(e, e.ins_h, e.window[e.strstart + we - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = we - 1, r !== 0 && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - br && (e.match_length = Xh(e, r), e.match_length <= 5 && (e.strategy === Gy || e.match_length === we && e.strstart - e.match_start > 4096) && (e.match_length = we - 1)), e.prev_length >= we && e.match_length <= e.prev_length) {
      a = e.strstart + e.lookahead - we, n = jr(e, e.strstart - 1 - e.prev_match, e.prev_length - we), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= a && (e.ins_h = qr(e, e.ins_h, e.window[e.strstart + we - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = we - 1, e.strstart++, n && (Ht(e, !1), e.strm.avail_out === 0))
        return It;
    } else if (e.match_available) {
      if (n = jr(e, 0, e.window[e.strstart - 1]), n && Ht(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return It;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (n = jr(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < we - 1 ? e.strstart : we - 1, t === Wt ? (Ht(e, !0), e.strm.avail_out === 0 ? vn : fa) : e.sym_next && (Ht(e, !1), e.strm.avail_out === 0) ? It : oa;
}, lw = (e, t) => {
  let r, n, a, i;
  const c = e.window;
  for (; ; ) {
    if (e.lookahead <= Hr) {
      if (Jn(e), e.lookahead <= Hr && t === Vr)
        return It;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= we && e.strstart > 0 && (a = e.strstart - 1, n = c[a], n === c[++a] && n === c[++a] && n === c[++a])) {
      i = e.strstart + Hr;
      do
        ;
      while (n === c[++a] && n === c[++a] && n === c[++a] && n === c[++a] && n === c[++a] && n === c[++a] && n === c[++a] && n === c[++a] && a < i);
      e.match_length = Hr - (i - a), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= we ? (r = jr(e, 1, e.match_length - we), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = jr(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (Ht(e, !1), e.strm.avail_out === 0))
      return It;
  }
  return e.insert = 0, t === Wt ? (Ht(e, !0), e.strm.avail_out === 0 ? vn : fa) : e.sym_next && (Ht(e, !1), e.strm.avail_out === 0) ? It : oa;
}, uw = (e, t) => {
  let r;
  for (; ; ) {
    if (e.lookahead === 0 && (Jn(e), e.lookahead === 0)) {
      if (t === Vr)
        return It;
      break;
    }
    if (e.match_length = 0, r = jr(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (Ht(e, !1), e.strm.avail_out === 0))
      return It;
  }
  return e.insert = 0, t === Wt ? (Ht(e, !0), e.strm.avail_out === 0 ? vn : fa) : e.sym_next && (Ht(e, !1), e.strm.avail_out === 0) ? It : oa;
};
function cr(e, t, r, n, a) {
  this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = n, this.func = a;
}
const Ra = [
  /*      good lazy nice chain */
  new cr(0, 0, 0, 0, Jh),
  /* 0 store only */
  new cr(4, 4, 8, 4, bc),
  /* 1 max speed, no lazy matches */
  new cr(4, 5, 16, 8, bc),
  /* 2 */
  new cr(4, 6, 32, 32, bc),
  /* 3 */
  new cr(4, 4, 16, 16, Pn),
  /* 4 lazy matches */
  new cr(8, 16, 32, 32, Pn),
  /* 5 */
  new cr(8, 16, 128, 128, Pn),
  /* 6 */
  new cr(8, 32, 128, 256, Pn),
  /* 7 */
  new cr(32, 128, 258, 1024, Pn),
  /* 8 */
  new cr(32, 258, 258, 4096, Pn)
  /* 9 max compression */
], hw = (e) => {
  e.window_size = 2 * e.w_size, Br(e.head), e.max_lazy_match = Ra[e.level].max_lazy, e.good_match = Ra[e.level].good_length, e.nice_match = Ra[e.level].nice_length, e.max_chain_length = Ra[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = we - 1, e.match_available = 0, e.ins_h = 0;
};
function bw() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Ns, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(iw * 2), this.dyn_dtree = new Uint16Array((2 * nw + 1) * 2), this.bl_tree = new Uint16Array((2 * aw + 1) * 2), Br(this.dyn_ltree), Br(this.dyn_dtree), Br(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(sw + 1), this.heap = new Uint16Array(2 * no + 1), Br(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * no + 1), Br(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const ui = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.status !== Xn && //#ifdef GZIP
  t.status !== af && //#endif
  t.status !== ao && t.status !== io && t.status !== so && t.status !== co && t.status !== _n && t.status !== Na ? 1 : 0;
}, Qh = (e) => {
  if (ui(e))
    return yn(e, hr);
  e.total_in = e.total_out = 0, e.data_type = Xy;
  const t = e.state;
  return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = //#ifdef GZIP
  t.wrap === 2 ? af : (
    //#endif
    t.wrap ? Xn : _n
  ), e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, My(t), bt;
}, e1 = (e) => {
  const t = Qh(e);
  return t === bt && hw(e.state), t;
}, pw = (e, t) => ui(e) || e.state.wrap !== 2 ? hr : (e.state.gzhead = t, bt), t1 = (e, t, r, n, a, i) => {
  if (!e)
    return hr;
  let c = 1;
  if (t === Ky && (t = 6), n < 0 ? (c = 0, n = -n) : n > 15 && (c = 2, n -= 16), a < 1 || a > Jy || r !== Ns || n < 8 || n > 15 || t < 0 || t > 9 || i < 0 || i > Zy || n === 8 && c !== 1)
    return yn(e, hr);
  n === 8 && (n = 9);
  const s = new bw();
  return e.state = s, s.strm = e, s.status = Xn, s.wrap = c, s.gzhead = null, s.w_bits = n, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = a + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + we - 1) / we), s.window = new Uint8Array(s.w_size * 2), s.head = new Uint16Array(s.hash_size), s.prev = new Uint16Array(s.w_size), s.lit_bufsize = 1 << a + 6, s.pending_buf_size = s.lit_bufsize * 4, s.pending_buf = new Uint8Array(s.pending_buf_size), s.sym_buf = s.lit_bufsize, s.sym_end = (s.lit_bufsize - 1) * 3, s.level = t, s.strategy = i, s.method = r, e1(e);
}, gw = (e, t) => t1(e, t, Ns, Qy, ew, Yy), _w = (e, t) => {
  if (ui(e) || t > F0 || t < 0)
    return e ? yn(e, hr) : hr;
  const r = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || r.status === Na && t !== Wt)
    return yn(e, e.avail_out === 0 ? hc : hr);
  const n = r.last_flush;
  if (r.last_flush = t, r.pending !== 0) {
    if ($t(e), e.avail_out === 0)
      return r.last_flush = -1, bt;
  } else if (e.avail_in === 0 && B0(t) <= B0(n) && t !== Wt)
    return yn(e, hc);
  if (r.status === Na && e.avail_in !== 0)
    return yn(e, hc);
  if (r.status === Xn && r.wrap === 0 && (r.status = _n), r.status === Xn) {
    let a = Ns + (r.w_bits - 8 << 4) << 8, i = -1;
    if (r.strategy >= Pi || r.level < 2 ? i = 0 : r.level < 6 ? i = 1 : r.level === 6 ? i = 2 : i = 3, a |= i << 6, r.strstart !== 0 && (a |= cw), a += 31 - a % 31, Ia(r, a), r.strstart !== 0 && (Ia(r, e.adler >>> 16), Ia(r, e.adler & 65535)), e.adler = 1, r.status = _n, $t(e), r.pending !== 0)
      return r.last_flush = -1, bt;
  }
  if (r.status === af) {
    if (e.adler = 0, Ie(r, 31), Ie(r, 139), Ie(r, 8), r.gzhead)
      Ie(
        r,
        (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)
      ), Ie(r, r.gzhead.time & 255), Ie(r, r.gzhead.time >> 8 & 255), Ie(r, r.gzhead.time >> 16 & 255), Ie(r, r.gzhead.time >> 24 & 255), Ie(r, r.level === 9 ? 2 : r.strategy >= Pi || r.level < 2 ? 4 : 0), Ie(r, r.gzhead.os & 255), r.gzhead.extra && r.gzhead.extra.length && (Ie(r, r.gzhead.extra.length & 255), Ie(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (e.adler = ft(e.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = ao;
    else if (Ie(r, 0), Ie(r, 0), Ie(r, 0), Ie(r, 0), Ie(r, 0), Ie(r, r.level === 9 ? 2 : r.strategy >= Pi || r.level < 2 ? 4 : 0), Ie(r, ow), r.status = _n, $t(e), r.pending !== 0)
      return r.last_flush = -1, bt;
  }
  if (r.status === ao) {
    if (r.gzhead.extra) {
      let a = r.pending, i = (r.gzhead.extra.length & 65535) - r.gzindex;
      for (; r.pending + i > r.pending_buf_size; ) {
        let s = r.pending_buf_size - r.pending;
        if (r.pending_buf.set(r.gzhead.extra.subarray(r.gzindex, r.gzindex + s), r.pending), r.pending = r.pending_buf_size, r.gzhead.hcrc && r.pending > a && (e.adler = ft(e.adler, r.pending_buf, r.pending - a, a)), r.gzindex += s, $t(e), r.pending !== 0)
          return r.last_flush = -1, bt;
        a = 0, i -= s;
      }
      let c = new Uint8Array(r.gzhead.extra);
      r.pending_buf.set(c.subarray(r.gzindex, r.gzindex + i), r.pending), r.pending += i, r.gzhead.hcrc && r.pending > a && (e.adler = ft(e.adler, r.pending_buf, r.pending - a, a)), r.gzindex = 0;
    }
    r.status = io;
  }
  if (r.status === io) {
    if (r.gzhead.name) {
      let a = r.pending, i;
      do {
        if (r.pending === r.pending_buf_size) {
          if (r.gzhead.hcrc && r.pending > a && (e.adler = ft(e.adler, r.pending_buf, r.pending - a, a)), $t(e), r.pending !== 0)
            return r.last_flush = -1, bt;
          a = 0;
        }
        r.gzindex < r.gzhead.name.length ? i = r.gzhead.name.charCodeAt(r.gzindex++) & 255 : i = 0, Ie(r, i);
      } while (i !== 0);
      r.gzhead.hcrc && r.pending > a && (e.adler = ft(e.adler, r.pending_buf, r.pending - a, a)), r.gzindex = 0;
    }
    r.status = so;
  }
  if (r.status === so) {
    if (r.gzhead.comment) {
      let a = r.pending, i;
      do {
        if (r.pending === r.pending_buf_size) {
          if (r.gzhead.hcrc && r.pending > a && (e.adler = ft(e.adler, r.pending_buf, r.pending - a, a)), $t(e), r.pending !== 0)
            return r.last_flush = -1, bt;
          a = 0;
        }
        r.gzindex < r.gzhead.comment.length ? i = r.gzhead.comment.charCodeAt(r.gzindex++) & 255 : i = 0, Ie(r, i);
      } while (i !== 0);
      r.gzhead.hcrc && r.pending > a && (e.adler = ft(e.adler, r.pending_buf, r.pending - a, a));
    }
    r.status = co;
  }
  if (r.status === co) {
    if (r.gzhead.hcrc) {
      if (r.pending + 2 > r.pending_buf_size && ($t(e), r.pending !== 0))
        return r.last_flush = -1, bt;
      Ie(r, e.adler & 255), Ie(r, e.adler >> 8 & 255), e.adler = 0;
    }
    if (r.status = _n, $t(e), r.pending !== 0)
      return r.last_flush = -1, bt;
  }
  if (e.avail_in !== 0 || r.lookahead !== 0 || t !== Vr && r.status !== Na) {
    let a = r.level === 0 ? Jh(r, t) : r.strategy === Pi ? uw(r, t) : r.strategy === Wy ? lw(r, t) : Ra[r.level].func(r, t);
    if ((a === vn || a === fa) && (r.status = Na), a === It || a === vn)
      return e.avail_out === 0 && (r.last_flush = -1), bt;
    if (a === oa && (t === jy ? zy(r) : t !== F0 && (ro(r, 0, 0, !1), t === Vy && (Br(r.head), r.lookahead === 0 && (r.strstart = 0, r.block_start = 0, r.insert = 0))), $t(e), e.avail_out === 0))
      return r.last_flush = -1, bt;
  }
  return t !== Wt ? bt : r.wrap <= 0 ? $0 : (r.wrap === 2 ? (Ie(r, e.adler & 255), Ie(r, e.adler >> 8 & 255), Ie(r, e.adler >> 16 & 255), Ie(r, e.adler >> 24 & 255), Ie(r, e.total_in & 255), Ie(r, e.total_in >> 8 & 255), Ie(r, e.total_in >> 16 & 255), Ie(r, e.total_in >> 24 & 255)) : (Ia(r, e.adler >>> 16), Ia(r, e.adler & 65535)), $t(e), r.wrap > 0 && (r.wrap = -r.wrap), r.pending !== 0 ? bt : $0);
}, yw = (e) => {
  if (ui(e))
    return hr;
  const t = e.state.status;
  return e.state = null, t === _n ? yn(e, qy) : bt;
}, ww = (e, t) => {
  let r = t.length;
  if (ui(e))
    return hr;
  const n = e.state, a = n.wrap;
  if (a === 2 || a === 1 && n.status !== Xn || n.lookahead)
    return hr;
  if (a === 1 && (e.adler = Ga(e.adler, t, r, 0)), n.wrap = 0, r >= n.w_size) {
    a === 0 && (Br(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
    let d = new Uint8Array(n.w_size);
    d.set(t.subarray(r - n.w_size, r), 0), t = d, r = n.w_size;
  }
  const i = e.avail_in, c = e.next_in, s = e.input;
  for (e.avail_in = r, e.next_in = 0, e.input = t, Jn(n); n.lookahead >= we; ) {
    let d = n.strstart, f = n.lookahead - (we - 1);
    do
      n.ins_h = qr(n, n.ins_h, n.window[d + we - 1]), n.prev[d & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = d, d++;
    while (--f);
    n.strstart = d, n.lookahead = we - 1, Jn(n);
  }
  return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = we - 1, n.match_available = 0, e.next_in = c, e.input = s, e.avail_in = i, n.wrap = a, bt;
};
var mw = gw, Ew = t1, vw = e1, xw = Qh, Sw = pw, Dw = _w, Aw = yw, Iw = ww, Cw = "pako deflate (from Nodeca project)", Ua = {
  deflateInit: mw,
  deflateInit2: Ew,
  deflateReset: vw,
  deflateResetKeep: xw,
  deflateSetHeader: Sw,
  deflate: Dw,
  deflateEnd: Aw,
  deflateSetDictionary: Iw,
  deflateInfo: Cw
};
const Tw = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var Ow = function(e) {
  const t = Array.prototype.slice.call(arguments, 1);
  for (; t.length; ) {
    const r = t.shift();
    if (r) {
      if (typeof r != "object")
        throw new TypeError(r + "must be non-object");
      for (const n in r)
        Tw(r, n) && (e[n] = r[n]);
    }
  }
  return e;
}, Nw = (e) => {
  let t = 0;
  for (let n = 0, a = e.length; n < a; n++)
    t += e[n].length;
  const r = new Uint8Array(t);
  for (let n = 0, a = 0, i = e.length; n < i; n++) {
    let c = e[n];
    r.set(c, a), a += c.length;
  }
  return r;
}, Rs = {
  assign: Ow,
  flattenChunks: Nw
};
let r1 = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  r1 = !1;
}
const Wa = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  Wa[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
Wa[254] = Wa[254] = 1;
var Rw = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let t, r, n, a, i, c = e.length, s = 0;
  for (a = 0; a < c; a++)
    r = e.charCodeAt(a), (r & 64512) === 55296 && a + 1 < c && (n = e.charCodeAt(a + 1), (n & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (n - 56320), a++)), s += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
  for (t = new Uint8Array(s), i = 0, a = 0; i < s; a++)
    r = e.charCodeAt(a), (r & 64512) === 55296 && a + 1 < c && (n = e.charCodeAt(a + 1), (n & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (n - 56320), a++)), r < 128 ? t[i++] = r : r < 2048 ? (t[i++] = 192 | r >>> 6, t[i++] = 128 | r & 63) : r < 65536 ? (t[i++] = 224 | r >>> 12, t[i++] = 128 | r >>> 6 & 63, t[i++] = 128 | r & 63) : (t[i++] = 240 | r >>> 18, t[i++] = 128 | r >>> 12 & 63, t[i++] = 128 | r >>> 6 & 63, t[i++] = 128 | r & 63);
  return t;
};
const Lw = (e, t) => {
  if (t < 65534 && e.subarray && r1)
    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
  let r = "";
  for (let n = 0; n < t; n++)
    r += String.fromCharCode(e[n]);
  return r;
};
var Pw = (e, t) => {
  const r = t || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, t));
  let n, a;
  const i = new Array(r * 2);
  for (a = 0, n = 0; n < r; ) {
    let c = e[n++];
    if (c < 128) {
      i[a++] = c;
      continue;
    }
    let s = Wa[c];
    if (s > 4) {
      i[a++] = 65533, n += s - 1;
      continue;
    }
    for (c &= s === 2 ? 31 : s === 3 ? 15 : 7; s > 1 && n < r; )
      c = c << 6 | e[n++] & 63, s--;
    if (s > 1) {
      i[a++] = 65533;
      continue;
    }
    c < 65536 ? i[a++] = c : (c -= 65536, i[a++] = 55296 | c >> 10 & 1023, i[a++] = 56320 | c & 1023);
  }
  return Lw(i, a);
}, kw = (e, t) => {
  t = t || e.length, t > e.length && (t = e.length);
  let r = t - 1;
  for (; r >= 0 && (e[r] & 192) === 128; )
    r--;
  return r < 0 || r === 0 ? t : r + Wa[e[r]] > t ? r : t;
}, Za = {
  string2buf: Rw,
  buf2string: Pw,
  utf8border: kw
};
function Uw() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var n1 = Uw;
const a1 = Object.prototype.toString, {
  Z_NO_FLUSH: Fw,
  Z_SYNC_FLUSH: $w,
  Z_FULL_FLUSH: Bw,
  Z_FINISH: Mw,
  Z_OK: rs,
  Z_STREAM_END: Hw,
  Z_DEFAULT_COMPRESSION: zw,
  Z_DEFAULT_STRATEGY: jw,
  Z_DEFLATED: Vw
} = ca;
function hi(e) {
  this.options = Rs.assign({
    level: zw,
    method: Vw,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: jw
  }, e || {});
  let t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new n1(), this.strm.avail_out = 0;
  let r = Ua.deflateInit2(
    this.strm,
    t.level,
    t.method,
    t.windowBits,
    t.memLevel,
    t.strategy
  );
  if (r !== rs)
    throw new Error(En[r]);
  if (t.header && Ua.deflateSetHeader(this.strm, t.header), t.dictionary) {
    let n;
    if (typeof t.dictionary == "string" ? n = Za.string2buf(t.dictionary) : a1.call(t.dictionary) === "[object ArrayBuffer]" ? n = new Uint8Array(t.dictionary) : n = t.dictionary, r = Ua.deflateSetDictionary(this.strm, n), r !== rs)
      throw new Error(En[r]);
    this._dict_set = !0;
  }
}
hi.prototype.push = function(e, t) {
  const r = this.strm, n = this.options.chunkSize;
  let a, i;
  if (this.ended)
    return !1;
  for (t === ~~t ? i = t : i = t === !0 ? Mw : Fw, typeof e == "string" ? r.input = Za.string2buf(e) : a1.call(e) === "[object ArrayBuffer]" ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length; ; ) {
    if (r.avail_out === 0 && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), (i === $w || i === Bw) && r.avail_out <= 6) {
      this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
      continue;
    }
    if (a = Ua.deflate(r, i), a === Hw)
      return r.next_out > 0 && this.onData(r.output.subarray(0, r.next_out)), a = Ua.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === rs;
    if (r.avail_out === 0) {
      this.onData(r.output);
      continue;
    }
    if (i > 0 && r.next_out > 0) {
      this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
      continue;
    }
    if (r.avail_in === 0)
      break;
  }
  return !0;
};
hi.prototype.onData = function(e) {
  this.chunks.push(e);
};
hi.prototype.onEnd = function(e) {
  e === rs && (this.result = Rs.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function sf(e, t) {
  const r = new hi(t);
  if (r.push(e, !0), r.err)
    throw r.msg || En[r.err];
  return r.result;
}
function qw(e, t) {
  return t = t || {}, t.raw = !0, sf(e, t);
}
function Kw(e, t) {
  return t = t || {}, t.gzip = !0, sf(e, t);
}
var Gw = hi, Ww = sf, Zw = qw, Yw = Kw, Xw = ca, Jw = {
  Deflate: Gw,
  deflate: Ww,
  deflateRaw: Zw,
  gzip: Yw,
  constants: Xw
};
const ki = 16209, Qw = 16191;
var em = function(t, r) {
  let n, a, i, c, s, d, f, l, p, w, g, m, S, I, N, x, C, _, D, b, o, h, U, E;
  const T = t.state;
  n = t.next_in, U = t.input, a = n + (t.avail_in - 5), i = t.next_out, E = t.output, c = i - (r - t.avail_out), s = i + (t.avail_out - 257), d = T.dmax, f = T.wsize, l = T.whave, p = T.wnext, w = T.window, g = T.hold, m = T.bits, S = T.lencode, I = T.distcode, N = (1 << T.lenbits) - 1, x = (1 << T.distbits) - 1;
  e:
    do {
      m < 15 && (g += U[n++] << m, m += 8, g += U[n++] << m, m += 8), C = S[g & N];
      t:
        for (; ; ) {
          if (_ = C >>> 24, g >>>= _, m -= _, _ = C >>> 16 & 255, _ === 0)
            E[i++] = C & 65535;
          else if (_ & 16) {
            D = C & 65535, _ &= 15, _ && (m < _ && (g += U[n++] << m, m += 8), D += g & (1 << _) - 1, g >>>= _, m -= _), m < 15 && (g += U[n++] << m, m += 8, g += U[n++] << m, m += 8), C = I[g & x];
            r:
              for (; ; ) {
                if (_ = C >>> 24, g >>>= _, m -= _, _ = C >>> 16 & 255, _ & 16) {
                  if (b = C & 65535, _ &= 15, m < _ && (g += U[n++] << m, m += 8, m < _ && (g += U[n++] << m, m += 8)), b += g & (1 << _) - 1, b > d) {
                    t.msg = "invalid distance too far back", T.mode = ki;
                    break e;
                  }
                  if (g >>>= _, m -= _, _ = i - c, b > _) {
                    if (_ = b - _, _ > l && T.sane) {
                      t.msg = "invalid distance too far back", T.mode = ki;
                      break e;
                    }
                    if (o = 0, h = w, p === 0) {
                      if (o += f - _, _ < D) {
                        D -= _;
                        do
                          E[i++] = w[o++];
                        while (--_);
                        o = i - b, h = E;
                      }
                    } else if (p < _) {
                      if (o += f + p - _, _ -= p, _ < D) {
                        D -= _;
                        do
                          E[i++] = w[o++];
                        while (--_);
                        if (o = 0, p < D) {
                          _ = p, D -= _;
                          do
                            E[i++] = w[o++];
                          while (--_);
                          o = i - b, h = E;
                        }
                      }
                    } else if (o += p - _, _ < D) {
                      D -= _;
                      do
                        E[i++] = w[o++];
                      while (--_);
                      o = i - b, h = E;
                    }
                    for (; D > 2; )
                      E[i++] = h[o++], E[i++] = h[o++], E[i++] = h[o++], D -= 3;
                    D && (E[i++] = h[o++], D > 1 && (E[i++] = h[o++]));
                  } else {
                    o = i - b;
                    do
                      E[i++] = E[o++], E[i++] = E[o++], E[i++] = E[o++], D -= 3;
                    while (D > 2);
                    D && (E[i++] = E[o++], D > 1 && (E[i++] = E[o++]));
                  }
                } else if (_ & 64) {
                  t.msg = "invalid distance code", T.mode = ki;
                  break e;
                } else {
                  C = I[(C & 65535) + (g & (1 << _) - 1)];
                  continue r;
                }
                break;
              }
          } else if (_ & 64)
            if (_ & 32) {
              T.mode = Qw;
              break e;
            } else {
              t.msg = "invalid literal/length code", T.mode = ki;
              break e;
            }
          else {
            C = S[(C & 65535) + (g & (1 << _) - 1)];
            continue t;
          }
          break;
        }
    } while (n < a && i < s);
  D = m >> 3, n -= D, m -= D << 3, g &= (1 << m) - 1, t.next_in = n, t.next_out = i, t.avail_in = n < a ? 5 + (a - n) : 5 - (n - a), t.avail_out = i < s ? 257 + (s - i) : 257 - (i - s), T.hold = g, T.bits = m;
};
const kn = 15, M0 = 852, H0 = 592, z0 = 0, pc = 1, j0 = 2, tm = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), rm = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), nm = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), am = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), im = (e, t, r, n, a, i, c, s) => {
  const d = s.bits;
  let f = 0, l = 0, p = 0, w = 0, g = 0, m = 0, S = 0, I = 0, N = 0, x = 0, C, _, D, b, o, h = null, U;
  const E = new Uint16Array(kn + 1), T = new Uint16Array(kn + 1);
  let P = null, z, v, y;
  for (f = 0; f <= kn; f++)
    E[f] = 0;
  for (l = 0; l < n; l++)
    E[t[r + l]]++;
  for (g = d, w = kn; w >= 1 && E[w] === 0; w--)
    ;
  if (g > w && (g = w), w === 0)
    return a[i++] = 1 << 24 | 64 << 16 | 0, a[i++] = 1 << 24 | 64 << 16 | 0, s.bits = 1, 0;
  for (p = 1; p < w && E[p] === 0; p++)
    ;
  for (g < p && (g = p), I = 1, f = 1; f <= kn; f++)
    if (I <<= 1, I -= E[f], I < 0)
      return -1;
  if (I > 0 && (e === z0 || w !== 1))
    return -1;
  for (T[1] = 0, f = 1; f < kn; f++)
    T[f + 1] = T[f] + E[f];
  for (l = 0; l < n; l++)
    t[r + l] !== 0 && (c[T[t[r + l]]++] = l);
  if (e === z0 ? (h = P = c, U = 20) : e === pc ? (h = tm, P = rm, U = 257) : (h = nm, P = am, U = 0), x = 0, l = 0, f = p, o = i, m = g, S = 0, D = -1, N = 1 << g, b = N - 1, e === pc && N > M0 || e === j0 && N > H0)
    return 1;
  for (; ; ) {
    z = f - S, c[l] + 1 < U ? (v = 0, y = c[l]) : c[l] >= U ? (v = P[c[l] - U], y = h[c[l] - U]) : (v = 32 + 64, y = 0), C = 1 << f - S, _ = 1 << m, p = _;
    do
      _ -= C, a[o + (x >> S) + _] = z << 24 | v << 16 | y | 0;
    while (_ !== 0);
    for (C = 1 << f - 1; x & C; )
      C >>= 1;
    if (C !== 0 ? (x &= C - 1, x += C) : x = 0, l++, --E[f] === 0) {
      if (f === w)
        break;
      f = t[r + c[l]];
    }
    if (f > g && (x & b) !== D) {
      for (S === 0 && (S = g), o += p, m = f - S, I = 1 << m; m + S < w && (I -= E[m + S], !(I <= 0)); )
        m++, I <<= 1;
      if (N += 1 << m, e === pc && N > M0 || e === j0 && N > H0)
        return 1;
      D = x & b, a[D] = g << 24 | m << 16 | o - i | 0;
    }
  }
  return x !== 0 && (a[o + x] = f - S << 24 | 64 << 16 | 0), s.bits = g, 0;
};
var Fa = im;
const sm = 0, i1 = 1, s1 = 2, {
  Z_FINISH: V0,
  Z_BLOCK: cm,
  Z_TREES: Ui,
  Z_OK: xn,
  Z_STREAM_END: om,
  Z_NEED_DICT: fm,
  Z_STREAM_ERROR: Yt,
  Z_DATA_ERROR: c1,
  Z_MEM_ERROR: o1,
  Z_BUF_ERROR: dm,
  Z_DEFLATED: q0
} = ca, Ls = 16180, K0 = 16181, G0 = 16182, W0 = 16183, Z0 = 16184, Y0 = 16185, X0 = 16186, J0 = 16187, Q0 = 16188, el = 16189, ns = 16190, Sr = 16191, gc = 16192, tl = 16193, _c = 16194, rl = 16195, nl = 16196, al = 16197, il = 16198, Fi = 16199, $i = 16200, sl = 16201, cl = 16202, ol = 16203, fl = 16204, dl = 16205, yc = 16206, ll = 16207, ul = 16208, ke = 16209, f1 = 16210, d1 = 16211, lm = 852, um = 592, hm = 15, bm = hm, hl = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function pm() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const On = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.mode < Ls || t.mode > d1 ? 1 : 0;
}, l1 = (e) => {
  if (On(e))
    return Yt;
  const t = e.state;
  return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = t.wrap & 1), t.mode = Ls, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(lm), t.distcode = t.distdyn = new Int32Array(um), t.sane = 1, t.back = -1, xn;
}, u1 = (e) => {
  if (On(e))
    return Yt;
  const t = e.state;
  return t.wsize = 0, t.whave = 0, t.wnext = 0, l1(e);
}, h1 = (e, t) => {
  let r;
  if (On(e))
    return Yt;
  const n = e.state;
  return t < 0 ? (r = 0, t = -t) : (r = (t >> 4) + 5, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Yt : (n.window !== null && n.wbits !== t && (n.window = null), n.wrap = r, n.wbits = t, u1(e));
}, b1 = (e, t) => {
  if (!e)
    return Yt;
  const r = new pm();
  e.state = r, r.strm = e, r.window = null, r.mode = Ls;
  const n = h1(e, t);
  return n !== xn && (e.state = null), n;
}, gm = (e) => b1(e, bm);
let bl = !0, wc, mc;
const _m = (e) => {
  if (bl) {
    wc = new Int32Array(512), mc = new Int32Array(32);
    let t = 0;
    for (; t < 144; )
      e.lens[t++] = 8;
    for (; t < 256; )
      e.lens[t++] = 9;
    for (; t < 280; )
      e.lens[t++] = 7;
    for (; t < 288; )
      e.lens[t++] = 8;
    for (Fa(i1, e.lens, 0, 288, wc, 0, e.work, { bits: 9 }), t = 0; t < 32; )
      e.lens[t++] = 5;
    Fa(s1, e.lens, 0, 32, mc, 0, e.work, { bits: 5 }), bl = !1;
  }
  e.lencode = wc, e.lenbits = 9, e.distcode = mc, e.distbits = 5;
}, p1 = (e, t, r, n) => {
  let a;
  const i = e.state;
  return i.window === null && (i.wsize = 1 << i.wbits, i.wnext = 0, i.whave = 0, i.window = new Uint8Array(i.wsize)), n >= i.wsize ? (i.window.set(t.subarray(r - i.wsize, r), 0), i.wnext = 0, i.whave = i.wsize) : (a = i.wsize - i.wnext, a > n && (a = n), i.window.set(t.subarray(r - n, r - n + a), i.wnext), n -= a, n ? (i.window.set(t.subarray(r - n, r), 0), i.wnext = n, i.whave = i.wsize) : (i.wnext += a, i.wnext === i.wsize && (i.wnext = 0), i.whave < i.wsize && (i.whave += a))), 0;
}, ym = (e, t) => {
  let r, n, a, i, c, s, d, f, l, p, w, g, m, S, I = 0, N, x, C, _, D, b, o, h;
  const U = new Uint8Array(4);
  let E, T;
  const P = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (On(e) || !e.output || !e.input && e.avail_in !== 0)
    return Yt;
  r = e.state, r.mode === Sr && (r.mode = gc), c = e.next_out, a = e.output, d = e.avail_out, i = e.next_in, n = e.input, s = e.avail_in, f = r.hold, l = r.bits, p = s, w = d, h = xn;
  e:
    for (; ; )
      switch (r.mode) {
        case Ls:
          if (r.wrap === 0) {
            r.mode = gc;
            break;
          }
          for (; l < 16; ) {
            if (s === 0)
              break e;
            s--, f += n[i++] << l, l += 8;
          }
          if (r.wrap & 2 && f === 35615) {
            r.wbits === 0 && (r.wbits = 15), r.check = 0, U[0] = f & 255, U[1] = f >>> 8 & 255, r.check = ft(r.check, U, 2, 0), f = 0, l = 0, r.mode = K0;
            break;
          }
          if (r.head && (r.head.done = !1), !(r.wrap & 1) || /* check if zlib header allowed */
          (((f & 255) << 8) + (f >> 8)) % 31) {
            e.msg = "incorrect header check", r.mode = ke;
            break;
          }
          if ((f & 15) !== q0) {
            e.msg = "unknown compression method", r.mode = ke;
            break;
          }
          if (f >>>= 4, l -= 4, o = (f & 15) + 8, r.wbits === 0 && (r.wbits = o), o > 15 || o > r.wbits) {
            e.msg = "invalid window size", r.mode = ke;
            break;
          }
          r.dmax = 1 << r.wbits, r.flags = 0, e.adler = r.check = 1, r.mode = f & 512 ? el : Sr, f = 0, l = 0;
          break;
        case K0:
          for (; l < 16; ) {
            if (s === 0)
              break e;
            s--, f += n[i++] << l, l += 8;
          }
          if (r.flags = f, (r.flags & 255) !== q0) {
            e.msg = "unknown compression method", r.mode = ke;
            break;
          }
          if (r.flags & 57344) {
            e.msg = "unknown header flags set", r.mode = ke;
            break;
          }
          r.head && (r.head.text = f >> 8 & 1), r.flags & 512 && r.wrap & 4 && (U[0] = f & 255, U[1] = f >>> 8 & 255, r.check = ft(r.check, U, 2, 0)), f = 0, l = 0, r.mode = G0;
        case G0:
          for (; l < 32; ) {
            if (s === 0)
              break e;
            s--, f += n[i++] << l, l += 8;
          }
          r.head && (r.head.time = f), r.flags & 512 && r.wrap & 4 && (U[0] = f & 255, U[1] = f >>> 8 & 255, U[2] = f >>> 16 & 255, U[3] = f >>> 24 & 255, r.check = ft(r.check, U, 4, 0)), f = 0, l = 0, r.mode = W0;
        case W0:
          for (; l < 16; ) {
            if (s === 0)
              break e;
            s--, f += n[i++] << l, l += 8;
          }
          r.head && (r.head.xflags = f & 255, r.head.os = f >> 8), r.flags & 512 && r.wrap & 4 && (U[0] = f & 255, U[1] = f >>> 8 & 255, r.check = ft(r.check, U, 2, 0)), f = 0, l = 0, r.mode = Z0;
        case Z0:
          if (r.flags & 1024) {
            for (; l < 16; ) {
              if (s === 0)
                break e;
              s--, f += n[i++] << l, l += 8;
            }
            r.length = f, r.head && (r.head.extra_len = f), r.flags & 512 && r.wrap & 4 && (U[0] = f & 255, U[1] = f >>> 8 & 255, r.check = ft(r.check, U, 2, 0)), f = 0, l = 0;
          } else
            r.head && (r.head.extra = null);
          r.mode = Y0;
        case Y0:
          if (r.flags & 1024 && (g = r.length, g > s && (g = s), g && (r.head && (o = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(
            n.subarray(
              i,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              i + g
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            o
          )), r.flags & 512 && r.wrap & 4 && (r.check = ft(r.check, n, g, i)), s -= g, i += g, r.length -= g), r.length))
            break e;
          r.length = 0, r.mode = X0;
        case X0:
          if (r.flags & 2048) {
            if (s === 0)
              break e;
            g = 0;
            do
              o = n[i + g++], r.head && o && r.length < 65536 && (r.head.name += String.fromCharCode(o));
            while (o && g < s);
            if (r.flags & 512 && r.wrap & 4 && (r.check = ft(r.check, n, g, i)), s -= g, i += g, o)
              break e;
          } else
            r.head && (r.head.name = null);
          r.length = 0, r.mode = J0;
        case J0:
          if (r.flags & 4096) {
            if (s === 0)
              break e;
            g = 0;
            do
              o = n[i + g++], r.head && o && r.length < 65536 && (r.head.comment += String.fromCharCode(o));
            while (o && g < s);
            if (r.flags & 512 && r.wrap & 4 && (r.check = ft(r.check, n, g, i)), s -= g, i += g, o)
              break e;
          } else
            r.head && (r.head.comment = null);
          r.mode = Q0;
        case Q0:
          if (r.flags & 512) {
            for (; l < 16; ) {
              if (s === 0)
                break e;
              s--, f += n[i++] << l, l += 8;
            }
            if (r.wrap & 4 && f !== (r.check & 65535)) {
              e.msg = "header crc mismatch", r.mode = ke;
              break;
            }
            f = 0, l = 0;
          }
          r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = Sr;
          break;
        case el:
          for (; l < 32; ) {
            if (s === 0)
              break e;
            s--, f += n[i++] << l, l += 8;
          }
          e.adler = r.check = hl(f), f = 0, l = 0, r.mode = ns;
        case ns:
          if (r.havedict === 0)
            return e.next_out = c, e.avail_out = d, e.next_in = i, e.avail_in = s, r.hold = f, r.bits = l, fm;
          e.adler = r.check = 1, r.mode = Sr;
        case Sr:
          if (t === cm || t === Ui)
            break e;
        case gc:
          if (r.last) {
            f >>>= l & 7, l -= l & 7, r.mode = yc;
            break;
          }
          for (; l < 3; ) {
            if (s === 0)
              break e;
            s--, f += n[i++] << l, l += 8;
          }
          switch (r.last = f & 1, f >>>= 1, l -= 1, f & 3) {
            case 0:
              r.mode = tl;
              break;
            case 1:
              if (_m(r), r.mode = Fi, t === Ui) {
                f >>>= 2, l -= 2;
                break e;
              }
              break;
            case 2:
              r.mode = nl;
              break;
            case 3:
              e.msg = "invalid block type", r.mode = ke;
          }
          f >>>= 2, l -= 2;
          break;
        case tl:
          for (f >>>= l & 7, l -= l & 7; l < 32; ) {
            if (s === 0)
              break e;
            s--, f += n[i++] << l, l += 8;
          }
          if ((f & 65535) !== (f >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", r.mode = ke;
            break;
          }
          if (r.length = f & 65535, f = 0, l = 0, r.mode = _c, t === Ui)
            break e;
        case _c:
          r.mode = rl;
        case rl:
          if (g = r.length, g) {
            if (g > s && (g = s), g > d && (g = d), g === 0)
              break e;
            a.set(n.subarray(i, i + g), c), s -= g, i += g, d -= g, c += g, r.length -= g;
            break;
          }
          r.mode = Sr;
          break;
        case nl:
          for (; l < 14; ) {
            if (s === 0)
              break e;
            s--, f += n[i++] << l, l += 8;
          }
          if (r.nlen = (f & 31) + 257, f >>>= 5, l -= 5, r.ndist = (f & 31) + 1, f >>>= 5, l -= 5, r.ncode = (f & 15) + 4, f >>>= 4, l -= 4, r.nlen > 286 || r.ndist > 30) {
            e.msg = "too many length or distance symbols", r.mode = ke;
            break;
          }
          r.have = 0, r.mode = al;
        case al:
          for (; r.have < r.ncode; ) {
            for (; l < 3; ) {
              if (s === 0)
                break e;
              s--, f += n[i++] << l, l += 8;
            }
            r.lens[P[r.have++]] = f & 7, f >>>= 3, l -= 3;
          }
          for (; r.have < 19; )
            r.lens[P[r.have++]] = 0;
          if (r.lencode = r.lendyn, r.lenbits = 7, E = { bits: r.lenbits }, h = Fa(sm, r.lens, 0, 19, r.lencode, 0, r.work, E), r.lenbits = E.bits, h) {
            e.msg = "invalid code lengths set", r.mode = ke;
            break;
          }
          r.have = 0, r.mode = il;
        case il:
          for (; r.have < r.nlen + r.ndist; ) {
            for (; I = r.lencode[f & (1 << r.lenbits) - 1], N = I >>> 24, x = I >>> 16 & 255, C = I & 65535, !(N <= l); ) {
              if (s === 0)
                break e;
              s--, f += n[i++] << l, l += 8;
            }
            if (C < 16)
              f >>>= N, l -= N, r.lens[r.have++] = C;
            else {
              if (C === 16) {
                for (T = N + 2; l < T; ) {
                  if (s === 0)
                    break e;
                  s--, f += n[i++] << l, l += 8;
                }
                if (f >>>= N, l -= N, r.have === 0) {
                  e.msg = "invalid bit length repeat", r.mode = ke;
                  break;
                }
                o = r.lens[r.have - 1], g = 3 + (f & 3), f >>>= 2, l -= 2;
              } else if (C === 17) {
                for (T = N + 3; l < T; ) {
                  if (s === 0)
                    break e;
                  s--, f += n[i++] << l, l += 8;
                }
                f >>>= N, l -= N, o = 0, g = 3 + (f & 7), f >>>= 3, l -= 3;
              } else {
                for (T = N + 7; l < T; ) {
                  if (s === 0)
                    break e;
                  s--, f += n[i++] << l, l += 8;
                }
                f >>>= N, l -= N, o = 0, g = 11 + (f & 127), f >>>= 7, l -= 7;
              }
              if (r.have + g > r.nlen + r.ndist) {
                e.msg = "invalid bit length repeat", r.mode = ke;
                break;
              }
              for (; g--; )
                r.lens[r.have++] = o;
            }
          }
          if (r.mode === ke)
            break;
          if (r.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", r.mode = ke;
            break;
          }
          if (r.lenbits = 9, E = { bits: r.lenbits }, h = Fa(i1, r.lens, 0, r.nlen, r.lencode, 0, r.work, E), r.lenbits = E.bits, h) {
            e.msg = "invalid literal/lengths set", r.mode = ke;
            break;
          }
          if (r.distbits = 6, r.distcode = r.distdyn, E = { bits: r.distbits }, h = Fa(s1, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, E), r.distbits = E.bits, h) {
            e.msg = "invalid distances set", r.mode = ke;
            break;
          }
          if (r.mode = Fi, t === Ui)
            break e;
        case Fi:
          r.mode = $i;
        case $i:
          if (s >= 6 && d >= 258) {
            e.next_out = c, e.avail_out = d, e.next_in = i, e.avail_in = s, r.hold = f, r.bits = l, em(e, w), c = e.next_out, a = e.output, d = e.avail_out, i = e.next_in, n = e.input, s = e.avail_in, f = r.hold, l = r.bits, r.mode === Sr && (r.back = -1);
            break;
          }
          for (r.back = 0; I = r.lencode[f & (1 << r.lenbits) - 1], N = I >>> 24, x = I >>> 16 & 255, C = I & 65535, !(N <= l); ) {
            if (s === 0)
              break e;
            s--, f += n[i++] << l, l += 8;
          }
          if (x && !(x & 240)) {
            for (_ = N, D = x, b = C; I = r.lencode[b + ((f & (1 << _ + D) - 1) >> _)], N = I >>> 24, x = I >>> 16 & 255, C = I & 65535, !(_ + N <= l); ) {
              if (s === 0)
                break e;
              s--, f += n[i++] << l, l += 8;
            }
            f >>>= _, l -= _, r.back += _;
          }
          if (f >>>= N, l -= N, r.back += N, r.length = C, x === 0) {
            r.mode = dl;
            break;
          }
          if (x & 32) {
            r.back = -1, r.mode = Sr;
            break;
          }
          if (x & 64) {
            e.msg = "invalid literal/length code", r.mode = ke;
            break;
          }
          r.extra = x & 15, r.mode = sl;
        case sl:
          if (r.extra) {
            for (T = r.extra; l < T; ) {
              if (s === 0)
                break e;
              s--, f += n[i++] << l, l += 8;
            }
            r.length += f & (1 << r.extra) - 1, f >>>= r.extra, l -= r.extra, r.back += r.extra;
          }
          r.was = r.length, r.mode = cl;
        case cl:
          for (; I = r.distcode[f & (1 << r.distbits) - 1], N = I >>> 24, x = I >>> 16 & 255, C = I & 65535, !(N <= l); ) {
            if (s === 0)
              break e;
            s--, f += n[i++] << l, l += 8;
          }
          if (!(x & 240)) {
            for (_ = N, D = x, b = C; I = r.distcode[b + ((f & (1 << _ + D) - 1) >> _)], N = I >>> 24, x = I >>> 16 & 255, C = I & 65535, !(_ + N <= l); ) {
              if (s === 0)
                break e;
              s--, f += n[i++] << l, l += 8;
            }
            f >>>= _, l -= _, r.back += _;
          }
          if (f >>>= N, l -= N, r.back += N, x & 64) {
            e.msg = "invalid distance code", r.mode = ke;
            break;
          }
          r.offset = C, r.extra = x & 15, r.mode = ol;
        case ol:
          if (r.extra) {
            for (T = r.extra; l < T; ) {
              if (s === 0)
                break e;
              s--, f += n[i++] << l, l += 8;
            }
            r.offset += f & (1 << r.extra) - 1, f >>>= r.extra, l -= r.extra, r.back += r.extra;
          }
          if (r.offset > r.dmax) {
            e.msg = "invalid distance too far back", r.mode = ke;
            break;
          }
          r.mode = fl;
        case fl:
          if (d === 0)
            break e;
          if (g = w - d, r.offset > g) {
            if (g = r.offset - g, g > r.whave && r.sane) {
              e.msg = "invalid distance too far back", r.mode = ke;
              break;
            }
            g > r.wnext ? (g -= r.wnext, m = r.wsize - g) : m = r.wnext - g, g > r.length && (g = r.length), S = r.window;
          } else
            S = a, m = c - r.offset, g = r.length;
          g > d && (g = d), d -= g, r.length -= g;
          do
            a[c++] = S[m++];
          while (--g);
          r.length === 0 && (r.mode = $i);
          break;
        case dl:
          if (d === 0)
            break e;
          a[c++] = r.length, d--, r.mode = $i;
          break;
        case yc:
          if (r.wrap) {
            for (; l < 32; ) {
              if (s === 0)
                break e;
              s--, f |= n[i++] << l, l += 8;
            }
            if (w -= d, e.total_out += w, r.total += w, r.wrap & 4 && w && (e.adler = r.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            r.flags ? ft(r.check, a, w, c - w) : Ga(r.check, a, w, c - w)), w = d, r.wrap & 4 && (r.flags ? f : hl(f)) !== r.check) {
              e.msg = "incorrect data check", r.mode = ke;
              break;
            }
            f = 0, l = 0;
          }
          r.mode = ll;
        case ll:
          if (r.wrap && r.flags) {
            for (; l < 32; ) {
              if (s === 0)
                break e;
              s--, f += n[i++] << l, l += 8;
            }
            if (r.wrap & 4 && f !== (r.total & 4294967295)) {
              e.msg = "incorrect length check", r.mode = ke;
              break;
            }
            f = 0, l = 0;
          }
          r.mode = ul;
        case ul:
          h = om;
          break e;
        case ke:
          h = c1;
          break e;
        case f1:
          return o1;
        case d1:
        default:
          return Yt;
      }
  return e.next_out = c, e.avail_out = d, e.next_in = i, e.avail_in = s, r.hold = f, r.bits = l, (r.wsize || w !== e.avail_out && r.mode < ke && (r.mode < yc || t !== V0)) && p1(e, e.output, e.next_out, w - e.avail_out), p -= e.avail_in, w -= e.avail_out, e.total_in += p, e.total_out += w, r.total += w, r.wrap & 4 && w && (e.adler = r.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  r.flags ? ft(r.check, a, w, e.next_out - w) : Ga(r.check, a, w, e.next_out - w)), e.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === Sr ? 128 : 0) + (r.mode === Fi || r.mode === _c ? 256 : 0), (p === 0 && w === 0 || t === V0) && h === xn && (h = dm), h;
}, wm = (e) => {
  if (On(e))
    return Yt;
  let t = e.state;
  return t.window && (t.window = null), e.state = null, xn;
}, mm = (e, t) => {
  if (On(e))
    return Yt;
  const r = e.state;
  return r.wrap & 2 ? (r.head = t, t.done = !1, xn) : Yt;
}, Em = (e, t) => {
  const r = t.length;
  let n, a, i;
  return On(e) || (n = e.state, n.wrap !== 0 && n.mode !== ns) ? Yt : n.mode === ns && (a = 1, a = Ga(a, t, r, 0), a !== n.check) ? c1 : (i = p1(e, t, r, r), i ? (n.mode = f1, o1) : (n.havedict = 1, xn));
};
var vm = u1, xm = h1, Sm = l1, Dm = gm, Am = b1, Im = ym, Cm = wm, Tm = mm, Om = Em, Nm = "pako inflate (from Nodeca project)", Cr = {
  inflateReset: vm,
  inflateReset2: xm,
  inflateResetKeep: Sm,
  inflateInit: Dm,
  inflateInit2: Am,
  inflate: Im,
  inflateEnd: Cm,
  inflateGetHeader: Tm,
  inflateSetDictionary: Om,
  inflateInfo: Nm
};
function Rm() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var Lm = Rm;
const g1 = Object.prototype.toString, {
  Z_NO_FLUSH: Pm,
  Z_FINISH: km,
  Z_OK: Ya,
  Z_STREAM_END: Ec,
  Z_NEED_DICT: vc,
  Z_STREAM_ERROR: Um,
  Z_DATA_ERROR: pl,
  Z_MEM_ERROR: Fm
} = ca;
function bi(e) {
  this.options = Rs.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(e && e.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15 || (t.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new n1(), this.strm.avail_out = 0;
  let r = Cr.inflateInit2(
    this.strm,
    t.windowBits
  );
  if (r !== Ya)
    throw new Error(En[r]);
  if (this.header = new Lm(), Cr.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = Za.string2buf(t.dictionary) : g1.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (r = Cr.inflateSetDictionary(this.strm, t.dictionary), r !== Ya)))
    throw new Error(En[r]);
}
bi.prototype.push = function(e, t) {
  const r = this.strm, n = this.options.chunkSize, a = this.options.dictionary;
  let i, c, s;
  if (this.ended)
    return !1;
  for (t === ~~t ? c = t : c = t === !0 ? km : Pm, g1.call(e) === "[object ArrayBuffer]" ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length; ; ) {
    for (r.avail_out === 0 && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), i = Cr.inflate(r, c), i === vc && a && (i = Cr.inflateSetDictionary(r, a), i === Ya ? i = Cr.inflate(r, c) : i === pl && (i = vc)); r.avail_in > 0 && i === Ec && r.state.wrap > 0 && e[r.next_in] !== 0; )
      Cr.inflateReset(r), i = Cr.inflate(r, c);
    switch (i) {
      case Um:
      case pl:
      case vc:
      case Fm:
        return this.onEnd(i), this.ended = !0, !1;
    }
    if (s = r.avail_out, r.next_out && (r.avail_out === 0 || i === Ec))
      if (this.options.to === "string") {
        let d = Za.utf8border(r.output, r.next_out), f = r.next_out - d, l = Za.buf2string(r.output, d);
        r.next_out = f, r.avail_out = n - f, f && r.output.set(r.output.subarray(d, d + f), 0), this.onData(l);
      } else
        this.onData(r.output.length === r.next_out ? r.output : r.output.subarray(0, r.next_out));
    if (!(i === Ya && s === 0)) {
      if (i === Ec)
        return i = Cr.inflateEnd(this.strm), this.onEnd(i), this.ended = !0, !0;
      if (r.avail_in === 0)
        break;
    }
  }
  return !0;
};
bi.prototype.onData = function(e) {
  this.chunks.push(e);
};
bi.prototype.onEnd = function(e) {
  e === Ya && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = Rs.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function cf(e, t) {
  const r = new bi(t);
  if (r.push(e), r.err)
    throw r.msg || En[r.err];
  return r.result;
}
function $m(e, t) {
  return t = t || {}, t.raw = !0, cf(e, t);
}
var Bm = bi, Mm = cf, Hm = $m, zm = cf, jm = ca, Vm = {
  Inflate: Bm,
  inflate: Mm,
  inflateRaw: Hm,
  ungzip: zm,
  constants: jm
};
const { Deflate: Vv, deflate: qv, deflateRaw: Kv, gzip: qm } = Jw, { Inflate: Gv, inflate: Wv, inflateRaw: Zv, ungzip: Km } = Vm;
var Gm = qm, Wm = Km, vt = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof vt < "u" && vt, Nt = {
  searchParams: "URLSearchParams" in vt,
  iterable: "Symbol" in vt && "iterator" in Symbol,
  blob: "FileReader" in vt && "Blob" in vt && function() {
    try {
      return new Blob(), !0;
    } catch {
      return !1;
    }
  }(),
  formData: "FormData" in vt,
  arrayBuffer: "ArrayBuffer" in vt
};
function Zm(e) {
  return e && DataView.prototype.isPrototypeOf(e);
}
if (Nt.arrayBuffer)
  var Ym = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ], Xm = ArrayBuffer.isView || function(e) {
    return e && Ym.indexOf(Object.prototype.toString.call(e)) > -1;
  };
function pi(e) {
  if (typeof e != "string" && (e = String(e)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || e === "")
    throw new TypeError('Invalid character in header field name: "' + e + '"');
  return e.toLowerCase();
}
function of(e) {
  return typeof e != "string" && (e = String(e)), e;
}
function ff(e) {
  var t = {
    next: function() {
      var r = e.shift();
      return { done: r === void 0, value: r };
    }
  };
  return Nt.iterable && (t[Symbol.iterator] = function() {
    return t;
  }), t;
}
function et(e) {
  this.map = {}, e instanceof et ? e.forEach(function(t, r) {
    this.append(r, t);
  }, this) : Array.isArray(e) ? e.forEach(function(t) {
    this.append(t[0], t[1]);
  }, this) : e && Object.getOwnPropertyNames(e).forEach(function(t) {
    this.append(t, e[t]);
  }, this);
}
et.prototype.append = function(e, t) {
  e = pi(e), t = of(t);
  var r = this.map[e];
  this.map[e] = r ? r + ", " + t : t;
};
et.prototype.delete = function(e) {
  delete this.map[pi(e)];
};
et.prototype.get = function(e) {
  return e = pi(e), this.has(e) ? this.map[e] : null;
};
et.prototype.has = function(e) {
  return this.map.hasOwnProperty(pi(e));
};
et.prototype.set = function(e, t) {
  this.map[pi(e)] = of(t);
};
et.prototype.forEach = function(e, t) {
  for (var r in this.map)
    this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this);
};
et.prototype.keys = function() {
  var e = [];
  return this.forEach(function(t, r) {
    e.push(r);
  }), ff(e);
};
et.prototype.values = function() {
  var e = [];
  return this.forEach(function(t) {
    e.push(t);
  }), ff(e);
};
et.prototype.entries = function() {
  var e = [];
  return this.forEach(function(t, r) {
    e.push([r, t]);
  }), ff(e);
};
Nt.iterable && (et.prototype[Symbol.iterator] = et.prototype.entries);
function xc(e) {
  if (e.bodyUsed)
    return Promise.reject(new TypeError("Already read"));
  e.bodyUsed = !0;
}
function _1(e) {
  return new Promise(function(t, r) {
    e.onload = function() {
      t(e.result);
    }, e.onerror = function() {
      r(e.error);
    };
  });
}
function Jm(e) {
  var t = new FileReader(), r = _1(t);
  return t.readAsArrayBuffer(e), r;
}
function Qm(e) {
  var t = new FileReader(), r = _1(t);
  return t.readAsText(e), r;
}
function eE(e) {
  for (var t = new Uint8Array(e), r = new Array(t.length), n = 0; n < t.length; n++)
    r[n] = String.fromCharCode(t[n]);
  return r.join("");
}
function gl(e) {
  if (e.slice)
    return e.slice(0);
  var t = new Uint8Array(e.byteLength);
  return t.set(new Uint8Array(e)), t.buffer;
}
function y1() {
  return this.bodyUsed = !1, this._initBody = function(e) {
    this.bodyUsed = this.bodyUsed, this._bodyInit = e, e ? typeof e == "string" ? this._bodyText = e : Nt.blob && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : Nt.formData && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : Nt.searchParams && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : Nt.arrayBuffer && Nt.blob && Zm(e) ? (this._bodyArrayBuffer = gl(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : Nt.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(e) || Xm(e)) ? this._bodyArrayBuffer = gl(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = "", this.headers.get("content-type") || (typeof e == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : Nt.searchParams && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
  }, Nt.blob && (this.blob = function() {
    var e = xc(this);
    if (e)
      return e;
    if (this._bodyBlob)
      return Promise.resolve(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as blob");
    return Promise.resolve(new Blob([this._bodyText]));
  }, this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var e = xc(this);
      return e || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
        this._bodyArrayBuffer.buffer.slice(
          this._bodyArrayBuffer.byteOffset,
          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
        )
      ) : Promise.resolve(this._bodyArrayBuffer));
    } else
      return this.blob().then(Jm);
  }), this.text = function() {
    var e = xc(this);
    if (e)
      return e;
    if (this._bodyBlob)
      return Qm(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(eE(this._bodyArrayBuffer));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as text");
    return Promise.resolve(this._bodyText);
  }, Nt.formData && (this.formData = function() {
    return this.text().then(nE);
  }), this.json = function() {
    return this.text().then(JSON.parse);
  }, this;
}
var tE = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
function rE(e) {
  var t = e.toUpperCase();
  return tE.indexOf(t) > -1 ? t : e;
}
function Sn(e, t) {
  if (!(this instanceof Sn))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  t = t || {};
  var r = t.body;
  if (e instanceof Sn) {
    if (e.bodyUsed)
      throw new TypeError("Already read");
    this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new et(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, !r && e._bodyInit != null && (r = e._bodyInit, e.bodyUsed = !0);
  } else
    this.url = String(e);
  if (this.credentials = t.credentials || this.credentials || "same-origin", (t.headers || !this.headers) && (this.headers = new et(t.headers)), this.method = rE(t.method || this.method || "GET"), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && r)
    throw new TypeError("Body not allowed for GET or HEAD requests");
  if (this._initBody(r), (this.method === "GET" || this.method === "HEAD") && (t.cache === "no-store" || t.cache === "no-cache")) {
    var n = /([?&])_=[^&]*/;
    if (n.test(this.url))
      this.url = this.url.replace(n, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
    else {
      var a = /\?/;
      this.url += (a.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
    }
  }
}
Sn.prototype.clone = function() {
  return new Sn(this, { body: this._bodyInit });
};
function nE(e) {
  var t = new FormData();
  return e.trim().split("&").forEach(function(r) {
    if (r) {
      var n = r.split("="), a = n.shift().replace(/\+/g, " "), i = n.join("=").replace(/\+/g, " ");
      t.append(decodeURIComponent(a), decodeURIComponent(i));
    }
  }), t;
}
function aE(e) {
  var t = new et(), r = e.replace(/\r?\n[\t ]+/g, " ");
  return r.split("\r").map(function(n) {
    return n.indexOf(`
`) === 0 ? n.substr(1, n.length) : n;
  }).forEach(function(n) {
    var a = n.split(":"), i = a.shift().trim();
    if (i) {
      var c = a.join(":").trim();
      t.append(i, c);
    }
  }), t;
}
y1.call(Sn.prototype);
function _r(e, t) {
  if (!(this instanceof _r))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  t || (t = {}), this.type = "default", this.status = t.status === void 0 ? 200 : t.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = t.statusText === void 0 ? "" : "" + t.statusText, this.headers = new et(t.headers), this.url = t.url || "", this._initBody(e);
}
y1.call(_r.prototype);
_r.prototype.clone = function() {
  return new _r(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new et(this.headers),
    url: this.url
  });
};
_r.error = function() {
  var e = new _r(null, { status: 0, statusText: "" });
  return e.type = "error", e;
};
var iE = [301, 302, 303, 307, 308];
_r.redirect = function(e, t) {
  if (iE.indexOf(t) === -1)
    throw new RangeError("Invalid status code");
  return new _r(null, { status: t, headers: { location: e } });
};
var ln = vt.DOMException;
try {
  new ln();
} catch {
  ln = function(t, r) {
    this.message = t, this.name = r;
    var n = Error(t);
    this.stack = n.stack;
  }, ln.prototype = Object.create(Error.prototype), ln.prototype.constructor = ln;
}
function w1(e, t) {
  return new Promise(function(r, n) {
    var a = new Sn(e, t);
    if (a.signal && a.signal.aborted)
      return n(new ln("Aborted", "AbortError"));
    var i = new XMLHttpRequest();
    function c() {
      i.abort();
    }
    i.onload = function() {
      var d = {
        status: i.status,
        statusText: i.statusText,
        headers: aE(i.getAllResponseHeaders() || "")
      };
      d.url = "responseURL" in i ? i.responseURL : d.headers.get("X-Request-URL");
      var f = "response" in i ? i.response : i.responseText;
      setTimeout(function() {
        r(new _r(f, d));
      }, 0);
    }, i.onerror = function() {
      setTimeout(function() {
        n(new TypeError("Network request failed"));
      }, 0);
    }, i.ontimeout = function() {
      setTimeout(function() {
        n(new TypeError("Network request failed"));
      }, 0);
    }, i.onabort = function() {
      setTimeout(function() {
        n(new ln("Aborted", "AbortError"));
      }, 0);
    };
    function s(d) {
      try {
        return d === "" && vt.location.href ? vt.location.href : d;
      } catch {
        return d;
      }
    }
    i.open(a.method, s(a.url), !0), a.credentials === "include" ? i.withCredentials = !0 : a.credentials === "omit" && (i.withCredentials = !1), "responseType" in i && (Nt.blob ? i.responseType = "blob" : Nt.arrayBuffer && a.headers.get("Content-Type") && a.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (i.responseType = "arraybuffer")), t && typeof t.headers == "object" && !(t.headers instanceof et) ? Object.getOwnPropertyNames(t.headers).forEach(function(d) {
      i.setRequestHeader(d, of(t.headers[d]));
    }) : a.headers.forEach(function(d, f) {
      i.setRequestHeader(f, d);
    }), a.signal && (a.signal.addEventListener("abort", c), i.onreadystatechange = function() {
      i.readyState === 4 && a.signal.removeEventListener("abort", c);
    }), i.send(typeof a._bodyInit > "u" ? null : a._bodyInit);
  });
}
w1.polyfill = !0;
vt.fetch || (vt.fetch = w1, vt.Headers = et, vt.Request = Sn, vt.Response = _r);
var sE = self.fetch.bind(self);
const cE = /* @__PURE__ */ os(sE);
var m1 = { exports: {} };
(function(e) {
  (function(t, r, n) {
    e.exports ? e.exports = n() : r[t] = n();
  })("urljoin", Et, function() {
    function t(r) {
      var n = [];
      if (r.length === 0)
        return "";
      if (typeof r[0] != "string")
        throw new TypeError("Url must be a string. Received " + r[0]);
      if (r[0].match(/^[^/:]+:\/*$/) && r.length > 1) {
        var a = r.shift();
        r[0] = a + r[0];
      }
      r[0].match(/^file:\/\/\//) ? r[0] = r[0].replace(/^([^/:]+):\/*/, "$1:///") : r[0] = r[0].replace(/^([^/:]+):\/*/, "$1://");
      for (var i = 0; i < r.length; i++) {
        var c = r[i];
        if (typeof c != "string")
          throw new TypeError("Url must be a string. Received " + c);
        c !== "" && (i > 0 && (c = c.replace(/^[\/]+/, "")), i < r.length - 1 ? c = c.replace(/[\/]+$/, "") : c = c.replace(/[\/]+$/, "/"), n.push(c));
      }
      var s = n.join("/");
      s = s.replace(/\/(\?|&|#[^!])/g, "$1");
      var d = s.split("?");
      return s = d.shift() + (d.length > 0 ? "?" : "") + d.join("&"), s;
    }
    return function() {
      var r;
      return typeof arguments[0] == "object" ? r = arguments[0] : r = [].slice.call(arguments), t(r);
    };
  });
})(m1);
var oE = m1.exports;
const E1 = /* @__PURE__ */ os(oE);
var fE = Object.defineProperty, ut = (e, t) => {
  for (var r in t)
    fE(e, r, { get: t[r], enumerable: !0 });
}, ji = {};
ut(ji, {
  ALPHA: () => yE,
  API_VERSION: () => R1,
  BETA: () => wE,
  BaseUrl: () => L1,
  CONSTANT_POINTS: () => EE,
  EC_ORDER: () => _E,
  FIELD_GEN: () => pE,
  FIELD_PRIME: () => bE,
  FIELD_SIZE: () => gE,
  HEX_STR_TRANSACTION_VERSION_1: () => T1,
  HEX_STR_TRANSACTION_VERSION_2: () => O1,
  IS_BROWSER: () => Ps,
  MASK_250: () => N1,
  MASK_251: () => hE,
  MAX_ECDSA_VAL: () => mE,
  NetworkName: () => P1,
  StarknetChainId: () => k1,
  TransactionHashPrefix: () => U1,
  UDC: () => un,
  ZERO: () => Mt
});
var dE = {};
ut(dE, {
  IS_BROWSER: () => Ps,
  addHexPrefix: () => kt,
  arrayBufferToString: () => lf,
  atobUniversal: () => x1,
  btoaUniversal: () => S1,
  buf2hex: () => D1,
  calcByteLength: () => I1,
  padLeft: () => A1,
  pascalToSnake: () => fo,
  removeHexPrefix: () => da,
  sanitizeBytes: () => C1,
  sanitizeHex: () => uE,
  stringToArrayBuffer: () => v1,
  utf8ToArray: () => ks
});
var Ps = typeof window < "u", df = "0";
function lf(e) {
  return new Uint8Array(e).reduce((t, r) => t + String.fromCharCode(r), "");
}
function v1(e) {
  return Uint8Array.from(e, (t) => t.charCodeAt(0));
}
function x1(e) {
  return Ps ? v1(atob(e)) : Buffer.from(e, "base64");
}
function S1(e) {
  return Ps ? btoa(lf(e)) : Buffer.from(e).toString("base64");
}
function D1(e) {
  return [...e].map((t) => t.toString(16).padStart(2, "0")).join("");
}
function da(e) {
  return e.replace(/^0x/i, "");
}
function kt(e) {
  return `0x${da(e)}`;
}
function lE(e, t, r, n = df) {
  const a = t - e.length;
  let i = e;
  if (a > 0) {
    const c = n.repeat(a);
    i = r ? c + e : e + c;
  }
  return i;
}
function A1(e, t, r = df) {
  return lE(e, t, !0, r);
}
function I1(e, t = 8) {
  const r = e % t;
  return r ? (e - r) / t * t + t : e;
}
function C1(e, t = 8, r = df) {
  return A1(e, I1(e.length, t), r);
}
function uE(e) {
  return e = da(e), e = C1(e, 2), e && (e = kt(e)), e;
}
function ks(e) {
  return new TextEncoder().encode(e);
}
var fo = (e) => e.split(/(?=[A-Z])/).join("_").toUpperCase(), T1 = "0x1", O1 = "0x2", Mt = 0n, N1 = 2n ** 250n - 1n, hE = 2n ** 251n, R1 = Mt, L1 = /* @__PURE__ */ ((e) => (e.SN_MAIN = "https://alpha-mainnet.starknet.io", e.SN_GOERLI = "https://alpha4.starknet.io", e.SN_GOERLI2 = "https://alpha4-2.starknet.io", e))(L1 || {}), P1 = /* @__PURE__ */ ((e) => (e.SN_MAIN = "SN_MAIN", e.SN_GOERLI = "SN_GOERLI", e.SN_GOERLI2 = "SN_GOERLI2", e))(P1 || {}), k1 = /* @__PURE__ */ ((e) => (e.SN_MAIN = "0x534e5f4d41494e", e.SN_GOERLI = "0x534e5f474f45524c49", e.SN_GOERLI2 = "0x534e5f474f45524c4932", e))(k1 || {}), U1 = /* @__PURE__ */ ((e) => (e.DECLARE = "0x6465636c617265", e.DEPLOY = "0x6465706c6f79", e.DEPLOY_ACCOUNT = "0x6465706c6f795f6163636f756e74", e.INVOKE = "0x696e766f6b65", e.L1_HANDLER = "0x6c315f68616e646c6572", e))(U1 || {}), un = {
  ADDRESS: "0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf",
  ENTRYPOINT: "deployContract"
}, bE = "800000000000011000000000000000000000000000000000000000000000001", pE = "3", gE = 251, _E = "800000000000010FFFFFFFFFFFFFFFFB781126DCAE7B2321E66A241ADC64D2F", yE = "1", wE = "6F21413EFBE40DE150E596D72F7A8C5609AD26C15C915C1F4CDFCB99CEE9E89", mE = "800000000000000000000000000000000000000000000000000000000000000", EE = [
  [
    "49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804",
    "3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a"
  ],
  [
    "1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca",
    "5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f"
  ],
  [
    "234287dcbaffe7f969c748655fca9e58fa8120b6d56eb0c1080d17957ebe47b",
    "3b056f100f96fb21e889527d41f4e39940135dd7a6c94cc6ed0268ee89e5615"
  ],
  [
    "3909690e1123c80678a7ba0fde0e8447f6f02b3f6b960034d1e93524f8b476",
    "7122e9063d239d89d4e336753845b76f2b33ca0d7f0c1acd4b9fe974994cc19"
  ],
  [
    "40fd002e38ea01a01b2702eb7c643e9decc2894cbf31765922e281939ab542c",
    "109f720a79e2a41471f054ca885efd90c8cfbbec37991d1b6343991e0a3e740"
  ],
  [
    "2f52066635c139fc2f64eb0bd5e3fd7a705f576854ec4f00aa60361fddb981b",
    "6d78a24d8a5f97fc600318ce16b3c840315979c3273078ec1a285f217ee6a26"
  ],
  [
    "6a0767a1fd60d5b9027a35af1b68e57a1c366ebcde2006cdd07af27043ef674",
    "606b72c0ca0498b8c1817ed7922d550894c324f5efdfc85a19a1ae382411ca2"
  ],
  [
    "7fa463ee2a2d6a585d5c3358918270f6c28c66df1f86803374d1edf3819cc62",
    "a996edf01598832e644e1cae9a37288865ad80e2787f9bf958aceccc99afae"
  ],
  [
    "3d4da70d1540da597dbae1651d28487604a4e66a4a1823b97e8e9639393dbec",
    "45cdef70c35d3b6f0a2273a9886ccb6306d813e8204bdfd30b4efee63c8a3f9"
  ],
  [
    "1e448fdbcd9896c6fbf5f36cb7e7fcb77a751ff2d942593cae023363cc7750e",
    "30c81da0f3a8cb64468eaa491c7ae7b4842b62cb4148820da211afc4caffb3a"
  ],
  [
    "6531acf1a7cb90a4eb27de0b7f915e387a3b0fd063ba6e1289b91f48411be26",
    "31330f5daa091889981a3ea782ae997f5f171336ed0487a03f051551a2cafa2"
  ],
  [
    "54be016394d5662d67d7e82f5e889ed2f97ccf95d911f57dd2362c4040ed4f4",
    "c6cb184053f054d6a59c1bf0986d17090d25089b3fdcdaf185edc87ef113e5"
  ],
  [
    "35b9ecd0499ca1d5d42dcbb0c6b4042b3733c64b607ca711e706e786ef2afc6",
    "5624b476a5b21c3a544f0712d4817b06ad380a5a6529d323bf64da8ef862d8d"
  ],
  [
    "4ce0378e3ee8f77ed58f2ddbd8bb7676c8a38bfb1d3694c275254bd8ca38e23",
    "5a16fcbff0769c9cf2b02c31621878ec819fff4b8231bff82c6183db2746820"
  ],
  [
    "648d5c6f98680a1b926bfeb01c00224c56fdcf751b251c4449c8a94f425cfcf",
    "72c05ac793cd1620a833fbe2214d36900ebe446e095c62fcb740937f98cca8c"
  ],
  [
    "bd09be3e4e1af8a14189977e334f097c18e4a8bf42577ef5aafa0f807bd89b",
    "6e0e72ed7eb65c86cee29c411fb4761122558ee81013344ba8509c49de9f9b6"
  ],
  [
    "35ea4e339b44ae7724419bdfbe07022253137a4afb7cbaffad341ea61249357",
    "3665d676a026a174f367bb4417780e53a7803cb02d0db32eb4545c267c42f14"
  ],
  [
    "36457bc744f42e697b825c2d1afd8f4029d696a4514710f81da52d88e178643",
    "7c93715896735492a68c7969a024b3a8fd538bffc1521538107de1a5f13ce9c"
  ],
  [
    "5b3a08ebcf9c109cc9082f70d9df2b9c11b5428ee23917b4e790c4c10f6e661",
    "9d7b42ab0c20f5510df7ea5e196eec99342739077e9a168198c89da859753"
  ],
  [
    "21883ef8580fc06e59481955d52ece3aca6e82c8c9fc58e216dcf46f96990c6",
    "51a6423543e6e8a43e71da34cd90f5b520b8d33b67c4bf857573ab9e301aa4c"
  ],
  [
    "19e86b77f9b581e81092b305c852faf53940a8f15f0a6990c414f04c0fa7ef9",
    "515630e35d4398c9c79fc4ee08e1023fa47d8e03c6e7819c6d2ccef45398fa"
  ],
  [
    "888ab8eb4c31bb2ac5b54aa320dbe1a69c96b864e8a5f54d89c1d1a6b86c24",
    "730e148467f6a55ce22c5296f5380df88f38de76ef0b2de844cd3094aaaf3ea"
  ],
  [
    "75e79ff13a894e7120dac17b7429c0c32ce7828f726c9973728c0977a5f5977",
    "4960526e59c1c736561a201bc56f7d762641b39f609d273cc996f5d9197cfb8"
  ],
  [
    "640fe009249115d7254f72ecafb3006139e4bed7e9041af51458c737282d1d5",
    "3cc6c978a575246e2ce4f7ef1fcc7f63085db9ff98a1b1f3fe374087c0332c"
  ],
  [
    "6d6fd09ccab7c26de9b3906191235deb5c34685580c488275356a05e209ca96",
    "7157f81a34213dd8f91dea4f6df1bcfabc4ee091a3049eeeb3b7923d39b8645"
  ],
  [
    "5531ca1d00f151d71da820918f74caf2985b24dca20e124721fff507b5a5876",
    "518529643d3f25e47f72c322223ba60a63d6bfe78cf3f612215d9c19bf29200"
  ],
  [
    "6192d454e4f8fe212bdfccd5b15dd5056d7622ffe456c6c67e5a7265aea49c4",
    "2377a45dc630017ae863cb968ddb38333a70c7946d8684e6d7a6213f634b7bc"
  ],
  [
    "542fb44b4ef3640a64fdb22a2560fb26668065c069cf31d1df424819a39ff18",
    "5dbae9b0948e0361aea443503840341c322aa1a1366ce5390e71bf161f78f8c"
  ],
  [
    "299ff3e3412a7eb4cb4a3051b07b1be2e7b1c4b789f39ffb52cba3d048b71de",
    "1951d3175c02761b291d86b6c0a08387ad5e2a2130ccc33c852530572cb3958"
  ],
  [
    "628ce3f5367dadc1411133e55eb25e2e3c2880d6e28754a5cb1c5d109627e73",
    "ae3e9b7d50964e28bd15380400b7659b87affdef5d2586cbefcd9be7d67c0d"
  ],
  [
    "6ea54aff064895eccf9db2283225d62044ae67621192b3346338948382f5933",
    "6431507e51aadacfaf39f102a8ff387756e9b5e1bc8323d44acae55130d93db"
  ],
  [
    "28097d50d175a6235320fe8cfe138dd9e46895d189582e472c38ad7a67d923a",
    "7f9eab4133d7d09a7ff63368d6135c26262b62336eca1b5ca33f2096ce388ba"
  ],
  [
    "619fd09cdd6ff4323973f256c2cbdcb224f7f25b8aef623af2d4a0105e62e02",
    "2c95f0ae11d47eeae1bc7f1350f75f9185c5bc840382ceb38a797cae9c40308"
  ],
  [
    "641c18982ced304512a3f2395942a38add0d6a7156229c2a7c8b8dfbe9beb96",
    "6f6288c9c659b6af5ac975f4180deffe53d516399b2cc62f31732e9d4ba9837"
  ],
  [
    "58ab546e51fe49fc5a382e4064a2bd6cfc268904412f86c26de14f28a71d0f2",
    "124b7217943e7e328408e8afdfa7da00dcbc94a2bb85fd8e01fb162d2c2c0a9"
  ],
  [
    "a82c2fdedbb26c3c762a12f7e86b0e01e65320e0a25a8399d665f6e266bf74",
    "1a1de28e253f3e10f44d0111e8074f882d7f42e5900780ccbdc31da372d3fd8"
  ],
  [
    "744c725a7455a992e3cf5bd007bc234dd4668dba285f553f38350ad94c1615b",
    "7f721a87f48798bdc4a9c0eb88559e2ad7a74112fd901e70ea159e67a9c33f"
  ],
  [
    "434df142ddaa60f7881b6348d91687de40457de7ccfb07f0304b9e820705d0c",
    "7fae425e3b53f97dd1f5b20e49ed9fe24ff1efc341ba5e017ac89cf8df0cc39"
  ],
  [
    "7a1e2b809dff46277021cbc376f79c37e1b683bbd6bca5317014f0dc0e1ae73",
    "56790278a231912c334eff05281e08af1558e85516b4411ef64647c13bea431"
  ],
  [
    "4931b7990348d41cf8907be79f45bb7991fd18f8a57868351c92fa7a34cbcd7",
    "ca35091815cdf0837d396e25aad6052ad32d497a33b123256cffdc008bc50e"
  ],
  [
    "250b815d352fd89f8210b624b147ea7d0a4f47bcac49f3ac9b777840da93ebe",
    "1173f10e9691948b7da7632f328520455aadcba46e017f891e0a1d7da2bef04"
  ],
  [
    "2223b85032fa67292f6e1f822628e6756e5c3cc08fc252ab88d63d624e4dfb2",
    "55619ba96a7dcec77832fcb22cd5c21c7dcebc0280d730cba0002b67e0a8c63"
  ],
  [
    "249b131e04de73af9820d3e22492d9ec51bdc0c4c4f34d95352fa44dd61f245",
    "7576d3b5d136368ff01170a77d8286d0d1c7c40688862fb40813b4af3c6065e"
  ],
  [
    "6777915d9b4769027eb7e04733f8a2d669c84fe06080f55e8a55674dfbf9efb",
    "640d0ff384c9635e1af364760f104e058e3c86209fa9d2320aeac887b2e02d8"
  ],
  [
    "2abe3f237681052f002414399111cf07f8421535af41251edc427a36b5b19c9",
    "636ce4deaf468a503ab20ccb2f7e5bdc98551656ebf53e9c7786b11dd9090be"
  ],
  [
    "4d5cc5414758ea1be55be779bd7da296c7e11f1564d9e8797ceea347c16f8ea",
    "1a680c4c410cf5ddc74e95ff2897c193edaaecce5b2cde4e96bbae5c0054eff"
  ],
  [
    "46c375c684b30adf4d51de81e92afee52b1a3847e177403372c82109373edca",
    "1eaadc5783c90a0261306423d52009e991126b3f620e9cb6cffca41ca096f4f"
  ],
  [
    "2ddfb71f51205888118cbabba8fd07d460a810289bfdeeb7118707e310cb152",
    "1fd905d07b3933be886f2518246bdafa6f33259a174668808223cd7c28183c7"
  ],
  [
    "386f3879960713d41fdb3b1e41bbebf26b1c0e27a9a75bb1adcc1a0d3e8547b",
    "2b21498c0f34ec6f17c720334dc0f36021c2f87afbbbc8847d0bd536eb265e5"
  ],
  [
    "407eae62c6c4de3b942195afec3f45efec71ddb5e6edee3d427631bcdbf9b90",
    "436e7f2d78268ef62c4172d2ff1469028bad1f1d0f97ab007064418e61caa8f"
  ],
  [
    "1b881175e21201d17e095e9b3966b354f47de8c1acee5177f5909e0fd72328f",
    "69954b1a9b8bfccf8ec384d32924518a935758f3d3662ef754bcc88f1f6f3ec"
  ],
  [
    "7d545a82bff003b8115be32a0c437f7c0a98f776bcf7fddb0392822844f3c5e",
    "34b6e53a9565a7daa010711f5bf72254a4e61da3e6a562210a9abc9e8b66d69"
  ],
  [
    "299b9fcd4fadfc4b6141457a3036aaa68501c23df579de26df69d4def89b913",
    "b95bf2c2bb303c38bb396382edc798ca6a4847e573ce19b7b08533d1912675"
  ],
  [
    "551f5a4dae4a341a3e20336a7d2f365ddd45849351ec6dd4fcbedfe4806d5d5",
    "5865c977a0ecf13ce85ae14c5c316872080bd36f0f614f56b6dfc7ece83792e"
  ],
  [
    "7a1d69c08e68c80ad8b310736e6247a53bcba0183b9b8798833bc696a0fb6e2",
    "3ce803a20ebb3b120d5eaf0ad64bed0522fad1a0f2ce39a5c5cbae98c4438f6"
  ],
  [
    "28acacc0bc41d84e83663f02b36981a2c8272ecd72d3901164be2affb09c504",
    "7a5aee0b160eaff5b5968ab1a0304ce58c3d5ae0148d9191c39e87668229e5b"
  ],
  [
    "1f78cfdbcc767b68e69a224a077468cdfcb0afd6952b85bccbdb96d1fb8500b",
    "4772ba173c6b583284eb001cfc2a124104833f464ff9df096443e10ef3e9dd4"
  ],
  [
    "2774108962ca9897e7f22c064d2ccedac4fef5fc9569331c27cdc336c95774b",
    "9e13d79b68e8dc8091c019618f5b07283a710ddf1733dc674a99fc32c12911"
  ],
  [
    "770d116415cd2c4ace0d8b721dd77e4a2ef766591f9ec9fa0b61304548994ed",
    "42165d93c82f687635aa2b68492b3adffd516beb4baa94520efa11467a209fd"
  ],
  [
    "5e6e4ece6621e2275415e1fda1e7c4f496de498b77c0b913073c6a6099394b9",
    "3d92ce044fc77fa227adc31f6fc17ef8b4ec1c5aafc44630c0d9195075bf56d"
  ],
  [
    "6e69c717b5d98807ff1e404a5187a9ceaf0110b83aa15a84f930928b1171825",
    "1ee7cfc3a9744d7fa380ba28604af9df33ac077724374c04588bd71fa16b177"
  ],
  [
    "404318f2d2ceb44f549c80f9d7de9879d8f7da4b81e7350c00e974ebf2daef1",
    "3934831b5af70d17a3f1da9d2931bd757e6acf2893236264fc7e0d92ff1a1cb"
  ],
  [
    "20dcb6f394fea6d549b2e75748f61b7ec03b6e52319cb14163373a9c22bb9dc",
    "106a8c96cfb95a331618b7416d1498554730499e194a58fbf63019890480fc7"
  ],
  [
    "119000f277ccee013e6bb121194ec1ab5460fb6a96eb702a14079865f4170aa",
    "1737a32f5415e8720a5606ec1dd4756f02e7c6817e3723b453d091f2d192773"
  ],
  [
    "45d0fb5cd95db76d05dec3faa12e467a308eabaad363a062353db3cd2d9b749",
    "ae08691b5b0cdd19ec499132421638f470f493320e4003d123ab1da761b965"
  ],
  [
    "1257b3e65cdfb6367c6d0942327e799bc66eb221e70c6573a9862889eb51c38",
    "593309fd45755dd2cc4afd2b9316bc4638b0c5ddb3009694fcb7b250d0c8a2f"
  ],
  [
    "186dcf9950f72e868014a8accf14aa36e82a7a2a29f86ba37f6632da4189db3",
    "55684c9f7a043fc523ed78f756f834b4db823d5e4161bd79602c17d55a5cd8c"
  ],
  [
    "58791d5569f282f5c3b01ecdc9388df7ba3ca223a2dc1eed5edaf2a1d302fb9",
    "6298d7dd51561a045bb4089deda9f40b2865589ed433e56d54554f8b45e79f0"
  ],
  [
    "13fd87144aa5aa4b24d5a7bf907d8280d15937fed262d41084898cb688fc28b",
    "3fa54367770cc4479a857411ddcabe86627b405ce1cd14ad3b2863bde13abe4"
  ],
  [
    "48118139445415f0c1879224e2dee744ed35280ff00537260402a1741ec3676",
    "4dfa39dadaabecfc54ecb7a25319444f8e952782d863790e42a9887064fc0c1"
  ],
  [
    "4ad031bb9eda84f2fe5d354c7948d41558ca657a04508654721810ee72ef158",
    "620ebd5d0086b92c6009a42777b946a351c2c7ba852b57d3c9905fc337459ef"
  ],
  [
    "4a34abb016ad8cb4575ea5bd28385d2348e5bcc0cbba90059f90f9c71f86e8b",
    "4f781829ad83f9ed1e1b6de0e5f4ac60dfdfe7f23cb4411e815817e705e52c8"
  ],
  [
    "7fc632d7512aab5356b7915dca854c8b12b369ab54f524fbce352f00eb9b9f9",
    "2ce80b944fc9158005f630b34385d50c3ad84450a9e1e529925b3211dd2a1de"
  ],
  [
    "65ed10347503cbc0216ca03f7536cca16b6abd18d332a9258685907f2e5c23f",
    "3be1a18c6bfa6f2f4898ebefad5a8e844c74626d5baa04a820d407fe28bbca6"
  ],
  [
    "1a8abba1be2e276cdd1f28c912280833a5ede1ec121738fcca47dc070dcc71d",
    "21b724378bc029a5199799df005922590d4e59cae52976f8e437bf6693eec4a"
  ],
  [
    "3a99c22dafcfe9004ebb674805736a26aeed7ed5d465ae37226dcbe270a972b",
    "5bf67552af08e1e6e2a24bf562c23225e89869cab9bef8becb3669175a3c94f"
  ],
  [
    "4a6a5e4b3501f2b7bbdd8da73ea81ffca347170bdfb6776a037cdd74c560fb4",
    "5af167ebb259c2da88740ec559ee04052bb66480b836cadd0e2590c32d7111b"
  ],
  [
    "6890d95308525f0bac9dc25cc1189eb92d29d4b3fe61bc8aee1c716ac17b1e8",
    "e6f23f78e882026b53ea4fac6950e56e3da461e52339eb43d2fdb2dade7ca9"
  ],
  [
    "748f4cf4f027efdeaed7c7f91ef3730ff2f2bb0bfc2db8f27aadde947f7d4d5",
    "3a1cbc550699411052c76293b8c41a3a8a1ecf12cbbc029a1b2b6ea986fca93"
  ],
  [
    "7321f3f581690922cd0dec40c9c352aae412ec2ccdf718f137f7786ab452cd3",
    "5be5130c9277cdb76d7409452438ec15d246b211dd1e276ee58e82a81c98fd4"
  ],
  [
    "6c4d6cb7e7ae70955224b8a912ff57ca218635a2436b36cee25dce8a5cdf51f",
    "32f8c03c6db3246946e432e4148e69f5628b200c6d7d72449df6eeac0998039"
  ],
  [
    "1dad5f2e795ea6fa5177f110989516eacf8fb37bd6a091c7c93f1d73a2fe309",
    "56b2298c538180e99dea3e171dbb5c6fba0bd0a9ed40537277c0c2373a8e2c4"
  ],
  [
    "1610605baacc9bc62c4cc923dc943347cfece7ae241e746fbe6c2c878221dbd",
    "431a82d657e0d109d00dea88cf3fa9b999845221b7b5590a20c40fc71368c1c"
  ],
  [
    "6a4f5c787fb09a5be2b04d2eafa1e6f3d3c863ee22960eb0b64f6eaf6659162",
    "14dbc3eaea6146ee7eaace5a91ed9430dad3a47e9ca2f68b455171f8fe6a7b3"
  ],
  [
    "738415b73e55412b0e582e45ff0d7bf4b1bf2922db581783fdcc75559f40e",
    "33825aeb3fd8459999eb418d15102ba5864b069c6ea517f0c6e9eab8d9aca47"
  ],
  [
    "2603e72ce53985c70782774057a17944f7b4ce224a809be4e2b5af3606aa1d8",
    "92822921809c42318f42dac4d773325f41c43069e990adac7818a45e2554dc"
  ],
  [
    "181cd967ab4615357cc96c82eae9152ce7598c1a1dfdd91a458bddb016ae9fe",
    "5d562fdaeb0e12647e230e50eaf216bed52fa73c6b7378821a3bfc4cd66d4ff"
  ],
  [
    "1121726069b9ef5954ba6490100b226e0be53fef3e071b7c58a1286174b789a",
    "4b25594cf4e9eb2d14b3f52f2661a9992234fc222c0a0d44517cb77deb9c16f"
  ],
  [
    "e543663969b915337f105f80995a77b356f1a51d8b4a4fb12d44364130e873",
    "34b2e3c009fdab4cb7349a580df2e64c0098a123280078e5da6623a9ec6b44f"
  ],
  [
    "4e2f8909bb62de5ef65600e61bbf969293815296b6e23702875e049b3ce5c45",
    "3cb81f2c21f22a7add26fa38a9ce5d9cce1bb251bd2698f90c34ff0a84f7af"
  ],
  [
    "37b546e403a1ba970c17b67c2f1361ab9c803f8d2b5cd93803014faa08861ed",
    "37079184ea46272f5809b523d060686633f7995167897a153be1772fd6566f6"
  ],
  [
    "27bddca77f7bd7f66b3693567a4238f2e6751d95b0bcb409f6b24d08f84798c",
    "6417a85cbfd6fc02df560d3963a241a986baacdfa423f65d7227ce49a96c57d"
  ],
  [
    "2de71a39aa043057d1bc66e45f804542acddf18f7a6d88c0d7fb0ca240debdf",
    "306c1ce39ab46300f7cca0f3a2fbfa77296a27e24bc66b0b8044968ec0ee413"
  ],
  [
    "307c877154364c0c03534e7327d5a88e1380ceef6481567ade37a14ee7c1a72",
    "3404bc7dbfb33b95d922d0693aaf9358f77888d7d95e773c38d83dbe2e5f995"
  ],
  [
    "79f09ff7c60850e5f5ea020722659a1ed27db4c95dca131f99552f785c8afbc",
    "40429528c099349b426ddbf129497176951a64a53db5f9d8bd2be0252cb22b2"
  ],
  [
    "4027dc6b56d446e5972f35464eeac85c5254ef377c902d9fe37aea841bb5292",
    "7c3ea37689ef679fa2f5c7e031a78e23d484a8317990fd34d44d95cc1db3717"
  ],
  [
    "645dbf78a3c228c4b7151450b5e65edb58e71f37e1e4bc5f471e0f1abd6d9c2",
    "15cfe7850f327b256e23b00627451560c5c6ab60db78d45b7ab286afb6f13ab"
  ],
  [
    "1503ca373757677ad1d911a2b599d01c46eb879d1ce21ae171c7e439846a85f",
    "583eb269b7030da6a0c324026919de3f9489d2ff6ae0e6320c36f05469ad66c"
  ],
  [
    "66e1819ba3ec4ad4ae9f7d7588d23baa004e29d3aad2393d52af204a81626ca",
    "505249980cbe6273b82ad5038fe04a981896f4117345ac1abcc67e2525c0ee4"
  ],
  [
    "5ec20dbb290254545f9292c0a8e4fbbfb80ad9aab0a0e0e9e9923f784d70ed1",
    "bdb1ca3a859227cf5d00eaae1f22584e826ed83b7ccdb65483ed5213dc4323"
  ],
  [
    "a5c1a5011f4b81c5c01ef0b07c0fbf0a166de77280f0ae241f2db6cba15194",
    "4444521fb9b33d7dfeb1247d0ee1a2b854ad166cb663d9dd2e686909362a689"
  ],
  [
    "1f35335de40e00c62642dac2fda8b30f071986ce4f11db849df11bc45ad4e0c",
    "7801a2c761b90fd4477ba0be9a775003d5dfcd959b1ed198b4681f15e7acbf"
  ],
  [
    "48db4798cf6821c1ffb8178b1d3bb6020e04186c96aaf4670972d367f4ed5f",
    "781019494df95b888f1578f1b4a3f8e125ea60eca47ef9207a10630671217a3"
  ],
  [
    "17f653d904210148a8e74d8e719a3061683c164aa6d79c902a19f185ab437bd",
    "6780e97985932c3860d810af1e065d454b1cb4be0e7ffe2d8cea7d52526e223"
  ],
  [
    "5c4d0c7432f9b0070436240f9855adae1467cdc9826952ae01b68cd52a3ad89",
    "1c5747f968ed91261b7ae9bf1023c999da9816e37de602d6a1a50d397752bff"
  ],
  [
    "6fedd7639fdaa2f7bad4ca0b391710f6f8a7e890250ae8ae4252bb8b39a1e58",
    "436a215f655a3fd3778b2335ffdc9aca6b98474e43d764c1f8362830b084f0e"
  ],
  [
    "7fbd45a889c5e9d127bb4f8474d6be7cb9796bbfff923b75e42a1ad4cae37d6",
    "484bd12622a6ba81cd53049c550d9ed682a8e765b656b1cbff9bbea637bd1f4"
  ],
  [
    "17d984d47937263f7966a3e7b1eea04071e678494bd749c9e02b48b3234f06d",
    "7b341ff08722c4e161005d0037204a7a2001fdda7af2cc1a0b04a027f115a0f"
  ],
  [
    "7f1822045db45ea07e1519c3ee1f7705915f35fe4dd8db1e8921b5d1c740edf",
    "33d41e06b93320ad1b3d9580380ec797a05dac3f1cc8008899110ebefde2f78"
  ],
  [
    "7b19453ecb74b7d0e2a66b9890ff73bfbbcd61a266abd6d82dbe665bf32f34d",
    "6dba2355420dac582b1f349609ea1c89b89bba2d1a68a0642f1dd12d86e73cb"
  ],
  [
    "273e82a15f395ddf2489a95685bec8bac62c4b459d1b28987d3cb27e4bc9128",
    "653375b48a4cf5d5b101c9ef533039bedce5dbeef3f59e8f168bdc99b06ca5f"
  ],
  [
    "3006c9e7fc6a553d8eb4e8a47ce9f10d1a39576ac255ae9e0a4ce3869e76212",
    "65fe9e2ef2aae608be309332d464f57e28f1df5de1a6a519751b056971f932e"
  ],
  [
    "5e8f384c8a4607fbe9789fcc52d54249d304d698562597d114c1d81452d3dee",
    "3c8bc78066b5d947dc1e405e326ee55ea606c7988f666748d259850fa259a22"
  ],
  [
    "7841b2102e9aa103fb53a642b3e167b21113ea44751ab38e0b5ef8312654db9",
    "71bf5c8308fcf9c4a7847494cd9bdd946fddf7d3a37e8bb0b201ff2343deb8e"
  ],
  [
    "40f68027420c11e3ade9aae041978dc18081c4f94943463aac92d887f922a62",
    "499c6062594a6c7e21a3cb91ea451813393bff365a27a08f1a515439b83cf42"
  ],
  [
    "6ce77a50d038b222634e87948df0590b79d66087b01e42b9b6d8fa30ebb1465",
    "35f5c46bb1be8555a93f155a174d54ec048c2ac8676e7c743054ddc52709d37"
  ],
  [
    "604f8b9f2dacb13d569262864063c2d4bb2b2cd716db6eeb2b1eeabc57746f6",
    "68c6799e24f3b44eec3049973445174727a66970f1614a782efa2b91ab1e457"
  ],
  [
    "73d620f3bfe77f672943d448d7dc05327adf64b8e7af50039c469d7f7c994c4",
    "4859deb36eaf0c802f0d1514602368143a33ec6ce8fd55248b59025debc6afb"
  ],
  [
    "3fd2bcd1c89d706a3647fbd354097f09c76636e93ae504973f944d8fc3bcc1",
    "677ef842cf5eb2444941f527abec567725e469469192354ad509a26ebb3d0e0"
  ],
  [
    "39222ea924ac17b533c72ffb2c47ffdc11d6a7f7c70fbde3a10fb0b8f35eb2f",
    "20dc4bd1089019bc1d7379b4feb3eae6eb5af59e9f253845da9fd633057e952"
  ],
  [
    "326f58994e1347f62e4102183215b5db956378d2f61f14aba4dec94577f53c",
    "7a03284c296003bbe05178a1d82efdb7b8125511d63e20e50aed789c2e52e1"
  ],
  [
    "53aa8939c74d4ee58f03bc88bace5a45c7bfcf27466201da05dc6723a5f5632",
    "2e32535ca7732904a048183247b04b426ecf9b39fc393a9cebe92fb1dc7a7f1"
  ],
  [
    "6cee1a03145e93b3e826e6067005f09c06099c98198c91c222407ba5c8c132e",
    "beaecad1274e7c6e5476a100c271aa1a6f86ee5a9fa5c2f26124d5886fa63"
  ],
  [
    "3ec659b8175e1be1bd5a252108714776b813e330393f587814f5f1f32a73332",
    "529a5cf9f8c237ae69a94217d173c8d19c156952041f5c980da557990863fa7"
  ],
  [
    "3d66ec5963d0c534d4139c8cef2e1ac48b3e7965fafabf58be26f903318af4e",
    "3d3f2de7a95f59b683725ee6283cbaf31f97c4b600df9a4621413223a468740"
  ],
  [
    "7fb38ace8e0932fac2ea0d3eb676db8d684db1817e2e4d59da7996ce398b4a",
    "68f92bd5768cdd4710249f9d49ef1d5654e497b9a4ba10bd2971366d83fb400"
  ],
  [
    "1c4a49314d6b4969cdd142c76ceb7682bfb868ace7f7568b0fc8635bda5a9fb",
    "5fc0519f1f4cc10b5771312458748c036313b87707ed0540026ac64a5955aa9"
  ],
  [
    "3073c95d08d3b97caea5f0be16b2789bee766f76b7e5499f8ce8f96abb0f344",
    "52a8974b4eb9a1f6a0ae2c83cb4715bf18d73f057255fcb3f63b74f7e78f590"
  ],
  [
    "44485b16d597a5de3604df6f7ed7e00b8aeef9e7e8dea8688255153b8bb16aa",
    "6cccb0ba170123266f24b5d93a744397dc2c44820edc4f8f5b9a0f5c9b3b940"
  ],
  [
    "7618f77b7b32d512688dd62e0b48231d9574c6361e8be353a7dc04f7c3a115e",
    "78ffcd16d80636381ca231aae70d99c9e20298b4f5388fd823ea9fa2b8ddfd9"
  ],
  [
    "7dc82fee1ef95cf5b3720fcc07f63246654bfe39762627839da40e51c75654d",
    "4c0ccdd70955da74558de20c88352df8a02aa97e4d5971c500e884740a8cb62"
  ],
  [
    "7fa5d460dc10cbb418b444d9bde97e92c70a99a222b99f244dccee7e62cc04c",
    "636163901baa5b7576c38c43407af578b8c4607e01e86011ae2dde587a89f84"
  ],
  [
    "758930d46006623a756c89bd0cc378f6a3c1f43c9a0edbb42274c35e75c16d2",
    "1d74dd9f81c2fec811b8cbd6168a745b0a111932b2a345265ef2853b50b6245"
  ],
  [
    "7332ee0626b044d664ef228f8cb84df7c643e52f6a2591ae1c9007ad61ec16e",
    "229bd8e630572cbdee54283234cf3e9f060e6382f99943bf234119d47b54470"
  ],
  [
    "78a16ef803aa20a075bb2f66c61bb2dae5698bebb94a0995fa74c3d53de1614",
    "246d588b68edb6fed96c128349908c42dcd64c46341b205e79f4aed9b5d3675"
  ],
  [
    "6e1933939bd03b67bba753cc0cbe7d2f25bad68c993887ef8c9e2fcd59b0647",
    "599413f7c204a11a5ce315eab11299ab7326603412bb00bc1c59ff75a37d6b4"
  ],
  [
    "4a79957a5a1888ad063b51c69565a2b48e8eb917183e220a1c8d3374526d30e",
    "1f092de0e069bba7fc5386e2e9a114c1618f88c4b95e220cd35ffe96f99fcad"
  ],
  [
    "3148aa3df9ece39aca84f59489f2710522216f14be6055ee0027529d1d55e2d",
    "617e9a52a92975db0ba1977f71116f7058a0d31b869ac7f3ee2fd80b0c5100c"
  ],
  [
    "5c1188e72384160ae39d07328346cda4f6c12d227448e6236f04dc971625287",
    "1643006eb3a3bc6aafd5f685cf054f2a572e6ca58c0118bcec0b833741f116d"
  ],
  [
    "3f72efc93c9b71adc4c51d8fc69d3940b20d08733af2b7d05140fdb1d1c1004",
    "7399259987c8f4ebfab46e522380707e58427d3962ee0c2a91760813f76d232"
  ],
  [
    "3129b34c03c51aa8f611e91d5cfcc9bd3ef108ee66e6d3ee35a0e0e50055bb",
    "563b18b5650085efb4cf179a029e6afff27b1d3091cd28eaa68d24fa1f801c6"
  ],
  [
    "16eac0f9fb4c67cf89a7fa4ee615bbe731d8edcb709a1b9b50c7d873a530f52",
    "7ff8288b6e199ca8f316192881424a37fb080c29daa76b1f0edaccaf580a80e"
  ],
  [
    "75f6b6028c43ce832f65d7e8e620d43b16cba215b4b94df5b60fc24e9655ee4",
    "35e9ccfaed2293a8b94b28de03bcb13eb64a26c831e26cc61a39b97969a2ff0"
  ],
  [
    "3c6152fe093bd6316897917ec56a218640ec1b2148f21db9b14fc7a5ff362e8",
    "6eef2df27ae7d63a28856b07b73e7aad7ca94f317201a1e675ffc6f9a1710dd"
  ],
  [
    "54e01b5fe4fd96052aad55b3f26b1d254dfc7e2525fffb9ae0a77eb8cc5579",
    "7c3d39232ab333675b219abc766ed9b4782c840e6b046614dedb8a619696eb0"
  ],
  [
    "d1e63f8ea8a76429cf254a6d3b668761f0dc572d4bfac4fd56d9eaf58fb6c0",
    "2bd0a84d3908a63085824c9329a0983913006ba155b56a58eb3f9becab29c45"
  ],
  [
    "2d6122f2a702edd4da7385b1580796a71d13bd72be94cfb3fec01149c006c2d",
    "70eb282fae992efa6f5915e578b640653549f23385ef3a29ab29b1b9b8ad63b"
  ],
  [
    "752fec14beaadb5ddbba6b3a17fcb86579fa588ef407fad0ea07dbb22a640d3",
    "3feb6728eca21a1e84e8f9f23010387a53a96a1cb62d86fb37996150a1299ef"
  ],
  [
    "63f94a92f27acde8f5ed949b459506f51d70c85bcc61a34d647264ecc53c65e",
    "37e5dce0646ee66f4fdb93b82d54d83a054948fa7d7fa74ab6b36246fc7383e"
  ],
  [
    "d6aa909287a2f05b9528690c741702c4c5f4d486c19a46c38215f52ef79c7b",
    "5ebe1128dd81093df4aca0df365d58adab848d1be1a94b95eeb649afd66a018"
  ],
  [
    "12866812b3053e2f7a9572bdaf5ef2b48c6fb62a0eed9ff0356df50e7d05557",
    "6785f7eb2cd1c120e4c7167b46861d10117040a2e9f2ca86a71e9d67df90613"
  ],
  [
    "46a730d05330b1b13673cb8a1b8f45460035e4a9f1a1751cfba099c4355c1c",
    "76fb0ec6cd16a8141cdcd875c8b2de9fce42d296072643d148ac7e7fa7472df"
  ],
  [
    "4bd4380a22900bd34835e0a908eacf4b6edb61eda0cf483f9212453b37e7516",
    "5e9551cd20d8d7ddbf4366880b7d5267385afa1966ff30da4baaf273b009d29"
  ],
  [
    "71f1994ad40baa2922424ae222663a64f93d8b67929e9a10f9e4c1ab19f3833",
    "85320fe68ec0d37cc19fdfd03589d66906ffa4046c80e1b094a85f27676346"
  ],
  [
    "5a63b1bf5232f28f808765c6be7ce1f81c52145b39f01c879fae0f4303bee61",
    "3bc5d6df68bb6d0577bf9ae2ae59ec0e9b2dc7dd56ea179fb38a41e853db950"
  ],
  [
    "161ded55ff1087032381e6c1449704f63ad2d88df82dfc44a71890fa09b3941",
    "78a52e0013842037274ea75daaf8eb4afc04ccc4b07bfaf3f5ee47d165e01b"
  ],
  [
    "1bfce5229c5fbff5c0f452a22317fcfcd9262f23df41840f84fe7d44cfba1a1",
    "66b387872c00e63c73006a955d42cf49c46c5708fc9d1579b9ae38341b24a3d"
  ],
  [
    "56d47dadc9cbd1dcb2ee3efcd5d4af5e6aea71df10815c68b54a14e81d11b44",
    "47e966ba54df48e9b612a903685e0060a67e4725402e8cb4cf654e54e813a3e"
  ],
  [
    "4b1c44438afd4ddf20a2cf612df2ee494ce84c7274c5529e857693e73018491",
    "430403bd31d8f0677e06abff7159384560f27b9622943fea1a3192f14bf40d4"
  ],
  [
    "7f7281728fc2214aa1dbf13176a4624b53814734abd570eb6ef7c7e32379606",
    "312da47be347fb3fa2c9089b38df372560dcace2effeeacab4d96ab11567295"
  ],
  [
    "16a28884a1be8183e0d3fc0db84a9afbf47126fd3be548c2a584aaafbfa7dfe",
    "7c3f57b3b895564ba562c1cd80b71fda6d2e611665c6ab87744f5390858fe24"
  ],
  [
    "323339f37b327a731232a9580e79952063c7c232bd1380146d8a83c285f4b8b",
    "4f16be1d983c7232f92cce6b9690695978d42cecc8eeb8c206e125d1098a265"
  ],
  [
    "624d26cbaa197e104eb83cebf2adeed09a5cdad359993fe5e3529d4d0def21d",
    "261b7da3cfb55c788977e0d8d640e3e93ae5a325d962ce85c816d7d32cfc430"
  ],
  [
    "f24ecb7ee83a3e28dab54a330dc93d0429a7aea36412e922dce8fbff40d60d",
    "b043e36a258d1df1d21b0cc7be9c4dcae1bd4ed326c110e668ac23d86805a6"
  ],
  [
    "686cea46b710bde1231483bfdbc700cfa3da6ecd5841c0e0c782f9ea24328ec",
    "7eb7407aa58edd6911c7c7e8d1e03bb52ead4a2415a0c33325872ff3a521dd6"
  ],
  [
    "3866ee1186264549df3dfcdf8705c0380c9372eef6d4081c2454d3aded1720e",
    "634c6d3e8eb8af652a4be73e3b613452c2213104ca875b66b4b15ee5b1716af"
  ],
  [
    "484c687cd2969a1d20a58cdfb9a60f280a473284503b1ecff5de514aaf8206b",
    "34d44d26b7427e51a646d1b924084762f5b461685450f21d6a472de565bebd8"
  ],
  [
    "203561333771fa0fe22c4033349f7b877d15b0542a5598e81e067968768247a",
    "2b6a533aff6e2163a36a2a89cb7415848bef48db40f952ffd380f47676707c2"
  ],
  [
    "2ffa6cca6233695760251206fc5e34c8d3692498589478cdd3d5b09f0b7c05d",
    "6c57d605478fa9626c4ed769554d075daa53e1a1d0bd4d94174d3bfeeb11ad6"
  ],
  [
    "5dccf0fa46a5571f204d0b033b45f299cbb3d9f80fded57253ea4f1c64faaef",
    "30a38e131ee8756ee5ea2a3e16618a5dbc28b5b9311308bf037ecc2039dfc7d"
  ],
  [
    "57b0a2eaebeafd950221facdd24790d7d1ab8883e5c5d55635f0d14a1ee4741",
    "7b41cc478fa6be38417271db8ed12efc0da6982552c1496025d2df0576bf4ad"
  ],
  [
    "611b5725101f611c387ccaa13889ecf3bb5595071a179ce350029bfca4ad7f1",
    "3129755977abc8995fec7eec1123a1561e429fde37ff36af002d3211831ecf4"
  ],
  [
    "1c06bbd0c52fdab9fcaf680c7a93fb821e538a2ed79f00f3c34d5afb9ea6b31",
    "3873d3bdfe0be0157bbc141198dc95497823cc222986d24c594b87bd48dc527"
  ],
  [
    "275cdbabc989c615130d36dabfa55ca9d539ed5f67c187444b0a9a12e5b7234",
    "2b7f723e68e579e551115d56f0ae71a3b787b843cc04a35b9f11084b006521"
  ],
  [
    "6cc702eb20f8b5940c7da71f8b1801f55c8c2d8e2e4a3c6c983f00bc1ffdd95",
    "5d15b3727bc66f3aba6d589acdd139fae115232eb845abe61fbdfc51341352e"
  ],
  [
    "44defb418700cee8c9bd696b872adb005490512d8bba081f8f99a9f15cc981c",
    "3b2072cdb1d919b2b65b5cb3557f0a3381d7ca293c267ca4a38f83e77bcc96e"
  ],
  [
    "fd83ce77b1578b3a9b8c3cbeaddb1504d2fd4a19c901c21ac65961224e4966",
    "110cbe64fc10c6b9c66f15ca406a35f50b723b35d83c5eb9797a57f8395f4f9"
  ],
  [
    "9dc6ff90e341875e113bbfb507724dc7095a280d2f32cb6ba61a1e0c2d2aef",
    "4aeb622896c852c2747454e8f172c9482955a42ecbe522d6ce07ecde79d0a51"
  ],
  [
    "71c58b0e47b9dd9107ebd8a8c8fa9f0534e78231bac612c1ddc7a94edf33eb7",
    "7f90edaf4792bf8334adbaa0f4ee7c654312725af188682d75f34874c4eccb9"
  ],
  [
    "1f6de1f14988778ceb2dfe844f92394f1f1e72fd1581ceb3bf336c95ce50345",
    "4f6007ed4e022d2ee9fe4ca8207c5f6c766c4f3b85260e941fb24ad0dcbf0bc"
  ],
  [
    "3ddc3ac25ede4a67a97547ed27dc920239b585fb3624177e2e8d59eba678115",
    "a9afd8f8bb759cbd1dff2addc63f47da4ba1291ea34229c09c0637dc5c8d24"
  ],
  [
    "c56b0269d8431556e471cab9d70edda3a37b391696f107b2dc370631de51d",
    "729c52f6b134f733eb750c14bd9f95c077f0f6f6ff4005701e5bedc6544599d"
  ],
  [
    "44d32ce19ac6807cb22e4f25fe1486a36a13926f147fbfa054b63ff0446177d",
    "212a21e8c124c9cd37c80d2dd66913ceaa6b6f666522f115c39382b2d5925e8"
  ],
  [
    "35dfc16f3ae6ccc06a267bf6d931601e52f3e45359ffc513570b65b96adc4f",
    "74311d10f4bece01b5ae65a6affe5c931463aa1b73a3320eeb41bbb7bb1ff62"
  ],
  [
    "e0acd9d2d907031b319b80121dc90699d003d220ea785d50e5033cdb3b1a03",
    "3911ba78d6e507485d6374b0f7d2e6198f6462a7d6d3cf046404a07af690357"
  ],
  [
    "3c57918ca254c0cb7dac251ef4e10c7d82327969552eae15d26c4c52660922a",
    "5fd5f5ff3f14e671548074114c72c48409df8a2e71fc8aa3c8acb506e2a88df"
  ],
  [
    "222ad8b61e219ba2b581f606b7c996516850a46a3db72fe1f72b5a9be6c324c",
    "72015a5e2db648112abd284fd867b59fc5606645177d26cf6e9a655c9912d42"
  ],
  [
    "3c86d5d774bc614469768ad38f7be9a53e9a233942c5c553b82e49aae684764",
    "480febea8229e130dedffff89c11f3c43e11724e6bd89d5566d78752859d41c"
  ],
  [
    "adb73bb8352d0c10175df371f7868ef2c9e0c79ac788430c480c0f7d85c187",
    "60b564785248111502e6f39c4994d6293fac22bc25f4d764b2fb1957d3c9bd8"
  ],
  [
    "3836ab8b46cf4f453a22532c886940b982029b29c42adca90ded5bf77e6bcb9",
    "7b15e91d6355f147b171a90b064a9d8b2d7bf3699bbf4987664c61c950d8996"
  ],
  [
    "12ed96af1a97c45ec31f1531e96f6fb28a03ba52ab8484545fbe0dddc97bb32",
    "6d1f522b6c6cad0940cff8e23decc72bb8d4164696af031415508b025aa8be1"
  ],
  [
    "27382994ae5878223ef802e9b4882f481a1b4008f1eec8484483471f7aa742b",
    "c31750d242b3975b0026a0e86ccdd17d0f680a8c6f53f197fc25eb1f777917"
  ],
  [
    "431677eba3715455bc235557518a74f3b111a88844ef13e159ad44bc16de3e6",
    "30000e1eb6a17d9df776981e65c6e500fded1ac12003adc9446b269812c9197"
  ],
  [
    "4b563e6f42589671579eabfa2cda5502b361c46a5ac8d45c8ed44741a925b33",
    "627bdb41678443fdd1aa607709e9699b652308615f4bea760a3b79ee0d9ab5c"
  ],
  [
    "2932fd3f81fc973ca9def6b7f1bb50f980fe589187cfe9e9f52ba4d356cf2c8",
    "1e6bfd00fa976c4770263a227048214c38850fe0f059e7b3d2c7871ef07d68f"
  ],
  [
    "e44e4f3d96d9dec775b996be57e57fdc28e7c68023109b221c414a244a0dbc",
    "58b1e52fa274812e5184e00e9ad812bec2463140adfb4bea3b2d665867dcc9"
  ],
  [
    "7fcb89be1f4bec745887bb891e53fefd665c53d00a9e74de16b8a7e1f7adfb5",
    "74af0b06633f779897e199609c71cc5649bbb65bc2c0abd4c678f0480c198d1"
  ],
  [
    "62a381ffb904ea3ff4d451d4c8459457cdbc3dc2fd2da646a95d8c1e90c0b7b",
    "1ba058658e09db9e319fa73de8ab4a992b71e4efc22c273725bdcab84e2a315"
  ],
  [
    "1b0fbb7a84c67e668450a54449c7a46261a2d355589f8b84ebfbaf9a77ee938",
    "44f8fffa33dd33a6146c35d196595e22cc4a215f61ee9197cd751400970a1b"
  ],
  [
    "78fe920bd96a356d4d95ee34adafe8fecf071d3107c36f047b4024ddc4b3eea",
    "6162f29607fdbec10181fbac6e57d5cb41b922c5791fb24bd28bcdd75d16c41"
  ],
  [
    "5629b849e026e65d119ac11821d7ab7efd9c52226f75c7427505d6818bb0c8d",
    "1539c0f90970ee8b490e45bbe5568170e5708521a0e59f976be680595906feb"
  ],
  [
    "62bc853f349bac8c6e5921d27ba85dbd9ba20a375d70a7bc008928f3e123b04",
    "6acfeb1de05ba43c3ef1a9110a983a320e77b3ca294abbc04aeca19b194f26f"
  ],
  [
    "4cf4bed663464418285cbae359b5d84ec76b5997d24f3640984c7663421190f",
    "941f818e3e3e8fb1568da85217d17f9250ebc948379014d900a7b1a848494"
  ],
  [
    "52ff3d9ffe9a302f6dfaaf74bab57c08027d5cb699a69b30830540c0a2d47a1",
    "987dd8876873778d933fbfed37aab2f7d6f669c37024f926b1edcb2ca55782"
  ],
  [
    "1109ee32f0bc53de6bfa457060b366e909d7c18061ec9845f46ac715496897f",
    "38f36f172bdfd454b9285f86e6bdece8fdffc95182c7d801b03c671cc55139b"
  ],
  [
    "4b4482f1d84efe23dadf3bb10df3dcaa251312dcdd604f616f1eb540e1f3232",
    "7c9c149dcae9135f940fb54482f9c3cd8193721643a6e23157b8020410d439c"
  ],
  [
    "69cb459b9e415b7581ca163611c470d875971d5d7949de732d1f0f200544a73",
    "a7136fa9dd00c0469863b7def3f83a5611ed628810d7e807e7a873da5a9897"
  ],
  [
    "b66a4e32ac9a4baa8f64780acd94ed3628b2b0ea874ba4dece629af65f9e62",
    "24328ba9996a24389658e3467b8b90dc3927ef8419fe28b3f55b1c1aaa51915"
  ],
  [
    "5ecc3080062dd451236de0e4eb91c5c75100733364bc5469f5fa76f79021ecb",
    "6da4abb9031a27b5be94529324fad8026e7d871570780081b0f424d4fe543c9"
  ],
  [
    "1e3146f00880bb22486d5bc73e54367d54251f4002bcf342d0393b05a4b9ce0",
    "23b6fb8e945d3205f633ba724202db5a99305f807137edf942cd60eef867699"
  ],
  [
    "2e1da8013285598b899f026c6974185db12c97b4c63509769d3d4ad1d18a4e5",
    "1e7e7b668674d1593c39d58bc7bccbf568208732b3519bc2cdf93db34366862"
  ],
  [
    "d26c3f389d81709506f184b53871497c8d36c5c9eee8e3737358204c1acba3",
    "34649c3d39f3b825947fedbca215ae30c5a5995e93b1c8efca4944cf85a082a"
  ],
  [
    "91300478a83595d548f32f259033291fc7d083953b0b8bde88c7559660c563",
    "e5d2bff57fc6551e9b80c06ac7314a71907cdcc66ce82f2cce721a670df10a"
  ],
  [
    "1f7abcb9d462c63ffe92aa56619ae8590089cca4d93ee3e5f34a63882452cc7",
    "7e9f85c7b7ca6e9a4f3a026d1048adbeef69ea9d876c6f647c257b879a81bdd"
  ],
  [
    "4d2caa1323012e4c83b0ad387308b8aef5637bc35ddd882e7f5e41cf2ca410f",
    "47150e808c81a540b6f8864e9d6636589cacaa516f82caaa96506edfbd6f0e"
  ],
  [
    "3c10a6083c38351deb3e6d1b386827d0acf48979b66b95249eb8700ec26b069",
    "47e34bfe561d903cffdd1d849b85aa3cbd31cb4a9bbd8cc2e5fd2f95016cabc"
  ],
  [
    "758bd54868eec045d0b4d3d2bc415d24bce13fee47cefdfda46425c109b657",
    "3392a7c66ea3bd7b044680bbe9f78ae86752097404c067e9d2572f55330df83"
  ],
  [
    "19e718e0ca1d2d6fadbc6006ee7dda7a385430e29f5e239cdd4bb7c3fdcb2f8",
    "5c68249b7fe03ea2e13481a63b6cd4bf74ce42009a89fee0b3f8f968b3ec709"
  ],
  [
    "28077f57ea62401806367e6d54fe45d02de5b072db787ffdcc3854e12a3e855",
    "14f3762689072f5fb41d03e94b01808c739f6d42b7b785b0e464100b150efd2"
  ],
  [
    "3b8a8cefd017363ce867265af3293cec081fa589fe561830f0078778cbd338f",
    "69ccf2383cb7b4f9c806d72535812483e7c5e9a1a5928529d64ca7e085e758d"
  ],
  [
    "77878f388d22161a2953e5aca6bac1ea480e102f329574b4b201640d44a296b",
    "7eb35706a90a03aff7c2fecca72659136547cee98038746db5aba16fd7178df"
  ],
  [
    "97332e6da70961f2ef31b7b628f1018d21db8db015922a301fca7d6fc6a8e6",
    "2e37b06f639fc7a82601b744570a2619e543cbfaf60e474107fcaf4686d3223"
  ],
  [
    "a81518d452d3aac48bf0386c3ff170ef4e684a4def242c964e129c64f4d647",
    "37506e44c85908ec7b7adda9547fbdcc2e3605151fefa77fbf127ce3bc938f2"
  ],
  [
    "e80336b2220b1d666074f6b0dac85353d0e4c2e8bd0f37055a2236a6a9fadc",
    "1cae76d73eda7a5964c5d9d3ad6748aff51f5543c56441d2fdb7b444a39846a"
  ],
  [
    "2c01fd8430ecb44e066f352c4f697fc9fda177dbe162f82862d7b9ea8c918de",
    "6e1dfa99640fdf5b30603d34c7c97c1aa6e6b7f3a2c52a21fc64b0fcac7d591"
  ],
  [
    "744e37b511cd0ddcfe15f3581947014c159de81ed055d15a13c7a2d1fa39f0f",
    "685caa8ff6979a6c63640ac638a3f9c75737f2031bd55322a47384357af164d"
  ],
  [
    "40e627ff84e1a7a9068b4368770f5956128a4d9e9e33e9cf5e24d9a242149fd",
    "2465bd6cb20bbdf810e2bc5c3c458cecf4f3aa163a7ac99c2579e5f33417f2e"
  ],
  [
    "5f635af7f554a17bceb6ccb6e637abf89ab6dadd399189b0a0390e87b1896bc",
    "2aa6238a69f89665646c0e3ca2ba5f709cc6e14351cf71e1b00ec45201417a2"
  ],
  [
    "5edad3063c9fa8305978d7e6a4e037c9fa519b8023c7608dfc3b66e5c1e8985",
    "49f405d07d7d01919da51159ecdad1031a5ac208c026fdfc14d38f633d92183"
  ],
  [
    "2fdf2e8a45858c12926a1f25a62255fb2d02d0149a15ef669f859806683e649",
    "61cfb686bb31e2524470d4ad2ae09e3cc91b16305a21d748098feb1d8ce3b3d"
  ],
  [
    "ecdbd7c37f1dffa3943977278da3bb429afdf948b4ea6cdebace3d3be82381",
    "190b67fb34f7f3ad6afd3d6b6427aa327547d8ac0fb4deeb0feeba1f63d6c60"
  ],
  [
    "233021b483f578dfa5222f8cccba5766ceee0ac65f6d4a3b1673b302a21fb3c",
    "7d4b6d44d175d4b593f06f5a6dcba2cdbc4eaa2097abaf613123546866cf4ef"
  ],
  [
    "42db4e953c2a7a743de9fe20c5798f2247f51db4eabc6f40e86c13909a310ce",
    "12c1a0764a0b9f3666e431923ce15e7fcd0ded5ab153f0b48d362cca1604e65"
  ],
  [
    "30d539e2b545fb957e40e2255f6463b52d227c9808472cee6a3d521aa283a44",
    "5f9eccf747fe6313570f99e845db32b40070acee9ce9e34da7f3c29ca53a07a"
  ],
  [
    "4bd64e5ade3e2733580a6116b4af328751198e7128f9acfe3a3496b545efb5a",
    "4d584768900dabfc0dbaa086632b8051bb3905ef79b84d96c01514441d0cc93"
  ],
  [
    "62d6e771f02e591557197d13c3e77dfa2d1794ac1808407bd8227c4be31b466",
    "5c6f5607c1808e899ba36a425911fa8566b7ea9cc80de8a80538c0fceb837c0"
  ],
  [
    "5ce406218cb2852b1d2fe1836b19462f664631785216e87ffbce26030e2101f",
    "5225f107743c255ab50e7be4a090fe39478d1ef4ff558468559d8cfa87bb94"
  ],
  [
    "670286486e8dda3dc66b0ed3149be7697d3e06c8279844079daa7e42d5af728",
    "26becabe7430380c56e320f5ae3329569cae7b0af06fd5327ee23979d200eb0"
  ],
  [
    "3ef448df33a4394c43e93e5850cd0c5a6dcb18ae1cd865d00fe8ede9336a9f5",
    "56711f6ab7e0e4f7365ac34e284ac2879f40208c46f6febcc1dcf7146ecf015"
  ],
  [
    "4b63fc130288e92f2d6ba238caa7a6364804e29829ac037c57df32fbf762bc3",
    "1eb8c80af55278b4113286c038fff2bfad2da62763bb03426506b869139da0e"
  ],
  [
    "4e7e998557b29a95f805a6e2e26efc1e970108272d4755738c04f28572295c0",
    "97cfcc2f447bde61bde71049d8200a74a3028b21703bc139143d81a3623f09"
  ],
  [
    "574b67898f02964c408f68e9470e7b615be037e40b824e6617f89cb56c21219",
    "49392d5f8e6740a1b0b7444f56d7a17363f8656c6e4c628678c86223f2e46c8"
  ],
  [
    "7e8cb50ea5d5c1b09e219e7305bcb601d99b6d7185b1c388aa8e36fe1e56554",
    "47fefa308645455c12ccb5817da338f0c4f423b341aff4a9d158891a4fd69ba"
  ],
  [
    "67266dea9e71b4ed2bf24a597a823dd048cf31e725db511edceac72998c9ef6",
    "39babd65850befde1f7c28e41dbdbb4caf82bbcf3bcb5b33161f1c2960b2d8"
  ],
  [
    "63e99c2cb9c74eb9227d48065e27abb8f606df8fc83b2c44e4ea38b046bad2b",
    "60494a53dd13ecf34e08079d343c88fb655d6d810785af81f08d5aa9bcdcf9"
  ],
  [
    "3cf0600b0f5a2a4eb78c487cd385350e8c7848e3f6983231881d7f1bbe28543",
    "56dee4288528de609976ef6b903b652127c37b0590e91a2fdbebc3f11df2628"
  ],
  [
    "758f09245fa4b8b23d290ee2b3bfcede199b4fdb11f3cf2502a8ceedd61b129",
    "622d9baadfde781e985d9722e0a04715666769a4cc7a9bea0b96d6386be1746"
  ],
  [
    "38e1a45b81492aa95d7abea2b08b8c14dc0b8a41108b036871fb737910ae18c",
    "145c611262656385e5ed6243568cd3f9f59dbfed7a01ba11e22bb8bb272e08e"
  ],
  [
    "206e54ca53a2f155bd4fc45bf2edb77798ae6623defd4cf22f2dd4a7d119dad",
    "6c94e7f0825ad81680e4cdbcaaaf4df806d57a0d1fb2331926c3fe2b79d22e8"
  ],
  [
    "56e98d2862893caebf66180e84badf19ffc8b53041eaaa313ae7286a8fac3d",
    "526306f9c01afd6e0c1198ea5de17630f5a39c4ecd02d8e6f0d613c355995c6"
  ],
  [
    "4fa56f376c83db33f9dab2656558f3399099ec1de5e3018b7a6932dba8aa378",
    "3fa0984c931c9e38113e0c0e47e4401562761f92a7a23b45168f4e80ff5b54d"
  ],
  [
    "450cfaadfecdb8a2fbd4b95c44cb1db723ee5ac9677c9c188b3d7c8eff4ca58",
    "1a552bdfc0c81be734f1f6ca9a6dd3ab4daa61c11fb53ebb7046eee25d617c7"
  ],
  [
    "6fe20e5c8a8004e33eafc84d16ef770f2f0b7bace19adaaa150f987d295a34d",
    "28a35040a2ebe9a14a162d3208d5eabc6e2f3a8310f926bd80be65aa71775e2"
  ],
  [
    "1bd65f45a35bf62ae8f9ffcbd7de2976b90518b6820c219f039c50043bb1edf",
    "fb5f0f8659f9b6ed7cb0ddd7999506d0c20b26bbe69d1915a31842cfac41eb"
  ],
  [
    "4ba4cc166be8dec764910f75b45f74b40c690c74709e90f3aa372f0bd2d6997",
    "40301cf5c1751f4b971e46c4ede85fcac5c59a5ce5ae7c48151f27b24b219c"
  ],
  [
    "21cfbc678f5a279ebb6ed124273c8df37eaf12a2d04180403ae6b5ec0b1e1ef",
    "4478ed6a346d899ad7b0b10350270aad39ddd5b68529297e4c91a54357f0a7f"
  ],
  [
    "350bfefbe3d864eaadac9cc1195c14159bb736be743aed7380d2384cadd2046",
    "5e2a4b3ad0e1d7b9b8ef72b10d68a80e5ee691d7db591fcfbaad6240d41da8b"
  ],
  [
    "529acd569127f73c8d34345f87e96cebfb48ee12a00a3861cda209337ed94e6",
    "3120671a89b705e5bfd99b0e7fd2118b4914a3ac309b3d74527cacb5ad7491"
  ],
  [
    "55d3d7956a97d10e65a4d8ffeba40deaf0db0b57f8e022cdb3df6df613f5c6d",
    "159e59a6f92f48fcf85aa96c1a03749a4c4e2cf9e2bc94dd36796daebd9b8b9"
  ],
  [
    "405f019ee8f2e972a005c549b0884b5051f63d1e78480b73208dc07d8c65a1f",
    "4301a3d0c285ad309ff24a12c100ead7f48ba1368143712f32ac141ab4d9e8d"
  ],
  [
    "376d59b298d982f02dccad0edd5bbd4e5e8fad7898750675ed0856850a7babe",
    "5233b12bbc50564eb61cc098a17d3d97f06ec7a230380e4c5d3b725cc318eba"
  ],
  [
    "2f55624af6109ef04b2ed035a44a904ace8627f55889f011f768aabf4de9a38",
    "7f64209ce7dfb63337ccf3d8c14f4093295f86996cabfee23b1655549aca089"
  ],
  [
    "3b8965e942bed2714bc2e685fb103496e1e3595ac6a343d6df45fb5ef6979ed",
    "5b7cac7a165cb69ae103dd9052fb39c00ed0aad47989005aee53972d82d45b5"
  ],
  [
    "7abfe3accdec1eae1a50049efdd9a8eb7c2921a08e8bf1fe606e9d5a4039ec4",
    "3af178e7e831f8148244d2d2b284a32991852db6212ad0a9d77540ef648a5fe"
  ],
  [
    "4983196df6ad7d6f0a8d76f86af3863ad8611374a03fc0fd00793181dbde9d",
    "204c1f91b70f975a21d24a8face664e496f00f602daaafa69a3b56098a4cf89"
  ],
  [
    "79e2b91c1531a3b16dbd53e72d94e16bf265cbec261658151acfaea3718ea72",
    "3d9bdb47e8b148c1c5e9e694ffbc2cf71aac74ae1a85e8d8c3f77e580f962eb"
  ],
  [
    "297efceec61b3be17565843cae465c52524b4ecd9331a4170f54f7de8c4556c",
    "6ccef1733624cc8b973ac63dd54e7a53604929affe81c3439525ae5ed6af993"
  ],
  [
    "44f04b1966264a23ccdc870c8563ad2efcd4c8087b5469b90e792287a5581c7",
    "1c417f0e9829fa3d3cbb7c3cf4dc7aac04c5bf66ff3f86b833a42c533aed1fc"
  ],
  [
    "6ff83f5d8b51db3be0bda80eed2e2adb7037f2f58f705e88f0f98197431ac26",
    "64f59b8428894c2b7afd740866065ded42e716c7d48accd3f117f22768ed9fd"
  ],
  [
    "14aa8187c9559f77cd1cf96b2dfc949182529936f2b0b4050ea56e134073b24",
    "5f36508c68b1dc586f3fd3f4e2bd29c6d8258491b8a6aa19ede811ce0d3d0a1"
  ],
  [
    "95e8882a68c5000d1c2be7c0b43e7f2a6f8de906485241f0285a5c73a27a83",
    "1e4cb67207ab73bc1e5d19fa2146fde6d03021393b77a55df4ddda1fd28f5b1"
  ],
  [
    "2ae0704dacb3da47d564514b4c3543505b403ba09a248c6e74593cba1867ff5",
    "5a4b5818088dc9ef4066b90a8893ae80fc89584f987ec1928ef9d72cea2bd67"
  ],
  [
    "61a10898a76fb99989e51c0e823cb60b95ec7ccccb917c42b2b28014f5fd94d",
    "23d8ec1de45366d3b86c64c2da05a2ce3d171adf52ca5522e652ffd0eeee795"
  ],
  [
    "79884133c879cf07734976fd64de220c5a972e04c2a3afb74c362d6c3beecbf",
    "2aaa0e6d4891b792b5643fdf09873343cd0e3fbba3cbd0601b481a4083f32b6"
  ],
  [
    "45f73d2fa82be6c5ccd0f62d2237efe8727c479967d27cce28e42b9a44bad5b",
    "2fa4932215f72d56d8be5205c5851c9b3e5f2a14468e4a7acace5437c6b27dd"
  ],
  [
    "37f53f771850f52f9c8f87b53c6bf0c93c2bed76f5fd1d5697356d0b2325007",
    "50f1a052b79b446fbc7b93ffa1a4515f6c3be3a76a2b0bc5eb8ff327549960c"
  ],
  [
    "71bd6d23e0d2f312d47582efa609101f15b9ccc571fca8ac4fe3457c67fbc9b",
    "3b3fdf86bd4c7fc26d60540a6439b4d179dcbf7b91efb0ddc60dfbff9a148c6"
  ],
  [
    "78219ba049438385b829c13a4993874a4a326c4143de0dd581c7b9956f99b06",
    "5505f1268dcdd4ee01b77abac3bfdcbf3f0513ab097c69ff777b4a631aaf256"
  ],
  [
    "b81e924a86536dcf68bc5a2ca2065a61103ba6c9eb0ae4cf8cce9dbe286f15",
    "653a6dfb51acfe8a844fb8362795e5549d424aed88d3a090366a44f840b5b83"
  ],
  [
    "441c0d7b7aa705046dc0e07ba5f33a7d9df23f694a05192ff8c2d7be2aa3fdc",
    "4c06568c0902bb99d428bfa0a946ed0f0ca0a51fbf07cad88e06e9c78e38a59"
  ],
  [
    "2569c8c78b6d6b92533f29f767c95720d377fa63ad5a3b9827ee0a74b0488aa",
    "4b59c81d3cfe08834f946d9d57614f5366e0bcd9349475aaaebe01341196fe0"
  ],
  [
    "3f2fa285a0471647b214eac652bbad9d58a9f2dd2e812aff0210d0d8a6eb32f",
    "4cdb18e1c2848c2b52c1a6557165bd1a8f55c2f7562f5cc0b326f73c25b696c"
  ],
  [
    "5bb5141ab4fcc5290ae9151b8045a2cd8391547ce7b3b33cbbb10f8fb538092",
    "5a36bfd52acc6a83a9913b937ec086cc27fed030b5fa70dbc5d3c12c9515f56"
  ],
  [
    "3f3fed272edf91aa7f8ca5d70005d390fbc67830ffc69c5fa3ae17582d2771",
    "459057e0883c44d8776fa217405f443e5954f08c4a5db68e437becaa664a999"
  ],
  [
    "5237ca6656237a717a739a4509f70db1b9dedbb6cd232f60c9bd8c4563a6b1f",
    "56c7799dd02896dbe7d69dd8bb9718270549592099569d107b7b49c34bf5a49"
  ],
  [
    "1cf6b8499ac881e0b2fc7def9bc1a28937033b2fc52de99e75909a620c7a281",
    "5769cf4f735366fa386b6858043dc99a100f86fbc77b16d57d77766197ba27a"
  ],
  [
    "1b74b8a6b86dbf9638cdb0601e1a332b8d880753423d38c3394902c57f15e40",
    "6bb2dc10d2ecbb913219d0ebdc8d3337d644ed8b6c4e70637ef4c7e50887488"
  ],
  [
    "61e4da415661bba52a4737e2bcde1a837787c4796b2e1854778534f1582c29b",
    "27c43e632cb7652e8508c9c38e3b4ad0d3dd6ba748d42dc84ec2685e64b9aad"
  ],
  [
    "7c460a204d23f20ce86596dae6ac9b36734e4a9f7c5b43262c97a36c6a41c6e",
    "481a11f9300ab4c4bf6924c5ca884728cc361247377065920966785d043fbbf"
  ],
  [
    "124ff5e55e4effa40daa5b9618d75c49c8b6fad95cbe8c0bfdd83cb9bed8316",
    "33a2ea15d0f71f58a00de71acd7f22ccf9002115e49dd1f7631faa0d32f9987"
  ],
  [
    "61c9f8fc86715e95ff43583a865c5a6515f93381839d557ef884a68637eaf4c",
    "5877daaa42bbab9083b571e12648a9d62ced4470d71653092b6546f4a5acceb"
  ],
  [
    "70a6b9a9e5d1fcc07dd9ebef6d8f5fcf04c6cb34932d0fe2335330ac6dc8d3d",
    "3f0cbd332ac56922e886656bee74f6e9bb4bb88f7af7bba9098678af1f38fc"
  ],
  [
    "41db8a0f1ea78443a39e08a54323743c8897eed1ddc28f41aec6f2655040d9f",
    "7d4bf32f8f4719c2e4af8b7889f3b65cfdd033dc2f971798a12170f2b26efce"
  ],
  [
    "62f035e01acdfe841104942d6c8c07f0fbd618cb85998ea24bcc24cfac1f8",
    "1caa886104b7d753fda93645a746989794cd825c62473b526ea34b3d51b5771"
  ],
  [
    "441c6f016d270e86c19843727b83b864cec060cafc813b23d7e41e5abb1a60a",
    "29fece4e40400f3acae0586f4fc8ed535e805e472123ec38d662d8a0b01c086"
  ],
  [
    "2c791ba0fb0b66177815c98191fa6188dba9c795e34a7c3c8a19086215e3cee",
    "11123151389d4b330db6a665a560407e7cd8c3807c749e2b0cffd9c3074ba77"
  ],
  [
    "5292da4ca71ae75ed0554c267747e39c7a129b3b863e1af3ebb3e368439c4ea",
    "63af6a5016deea8cc674c44f16c63c1db31f09af4fb4d2ea7917c28116661fc"
  ],
  [
    "3367388d5d1b7758dc3d92e244f227bb8a54e3d9909e7b7dd62ab5965e3efc7",
    "7ffb4833071e4b03ea755ccb9938487a478248fe9b1158a08f1ac298801c092"
  ],
  [
    "95c863314b7f18090f8eee602403be823a367a1b416d54c32e5f914e67d922",
    "159c2824f899171deee23e0ed520d4825bd667983df0a8d45d3a1f7156d91f9"
  ],
  [
    "621c6e08b3c57404644ad49ac7629832c141273fa1f323781b3395393fe985c",
    "65d1eb0140652958c4371ebec791e03317d6b2e689d90e304666f1b610783dd"
  ],
  [
    "54313129bf13993952cd2b31ed06013aba85e74c1b8a00e062031f32188a84e",
    "680129efc9eb8ec07fc180e8f6877e5f0f9f44e3000a2c586ed4ce49d12a313"
  ],
  [
    "21ea57a1c8286bb45872e78617853c47b89091670ba51c124afa3362e7260d",
    "7087e5c1536df233ec9bfe2f983e8d7622892b9bf64c450c9823898e2cc2fc8"
  ],
  [
    "3793b05b99e7a57d88db4ed0dbc3b771285abcd9052da50f88595354409f3f3",
    "12164105041c056f127e737c7cd63981e05f246bd2b6b65d1f427019c7c3801"
  ],
  [
    "befd345cef5fcae22ac37dacd6b9128cc58cbba3e3fd774e11b421c2ba392",
    "6209d25f24f88f7876ca604db23d05f78e6b3b67fb033f2f1bee221f352b8c8"
  ],
  [
    "15fa536045fda4c65ff74f10b4e669ce88b9996c6772288289d3ad725987fa6",
    "30e0c2124a35e265e931ccc66ce5ac3697d982814beb407144ff6762cb691df"
  ],
  [
    "38b795bd77ac573576dc204857a488cac2cce19809882631ca2069598c577c8",
    "786ba555d55ebef688b068bb9186a34a08cb00bdfef51619bbf911890ae9a13"
  ],
  [
    "6c66853592196c3eb8d9526dc155205e2c64097adf8684bb0e15eb460ce1c72",
    "1bb4ebf654f4250c8dd1061a4e1b464b31a8a9999ac9960446ef8108a66871a"
  ],
  [
    "5b08dfbc87ad9c00b88e78816973ad2f9c10c70f2156908892cc7b7a2a1fd30",
    "1151f407a77e2556073173d8f5c9ff561d8a23742121ca15f7d0ac391af50ea"
  ],
  [
    "309190eba106aa6ead54b5ca5817969aa68b4b4c627700799a49fc6bdd32ba1",
    "505b6a2bc7b0d78ca6ce2abe7dfb7312369918a4599cccf8a615f6701cfd851"
  ],
  [
    "89cc205966af08acc8910d563af7443d5dfbb5d88dae79c013c678c65dcecc",
    "1f8cf955694b246a423ac725791231257b88936e00347ecaa1e17045c0ab540"
  ],
  [
    "480086b61a80c36cf1e1a350baf554e58ee8d9333186b70c9c512fb9e9d5a84",
    "511edfe58f8d36a6170df743731da1ff525cfd5108be20e30ac4183d1281570"
  ],
  [
    "3caf14fb1d2e90a13ad4eb091250fe37133aabf6029633e905e5a93ead41dbb",
    "49122aff6059dfda19e4b973aba5ebe3804c91728936c6381c1ed1ea9380920"
  ],
  [
    "66d1b8fb2cabc46cd79741ce1cb7326077ad8ea3227a6427244bdd3806bdadd",
    "4a52eb74f4d5371ba3265dffd61c844f9e68d4ff0b44dc4936182f9280bb66b"
  ],
  [
    "373330c5afd53c31257fcc9050fef873e15ea9f81d9810f30744309b04e02b3",
    "5889806607b3dc97a9c5b0c8a2f16d1792099a22866b879ca480cb89a11ef5c"
  ],
  [
    "26840d0ec69a22c6818ff64b8b14633b531508c866e21d1dc9239778ae9e8c7",
    "157971f9a6e3a24d3b307be0e7c8cd352e2eb5cad33cf276270c0f309ee63fc"
  ],
  [
    "ebb84848f1c38c19a754d1b5d9460e39624dadbb30800987c9419c0f933b9f",
    "517b297cf32f4064e6d6c8e761ba8db89809604a701c7b3aa1a9c6beb370ea7"
  ],
  [
    "25780380bc0795ed0dca727c55240f1d63593e552d224adb40df2d3721c0f66",
    "10215fb5a893e0275e9f1f66b217dde35addee91ed0e8f7d79531a2ff57b8c8"
  ],
  [
    "243e1581cd1abfbf18c31c19a4c3d1cedfe69a40bb57b607c9af2717eefc742",
    "1296c27929f14535718c3a4ebe045f00afdc60afc74c7d398d8ce1b6609dc0f"
  ],
  [
    "48babb8649e054bc8e0b902c89e6940c265f48464520649502ef1064eb94562",
    "3235be7852b0526d1a16f6969ec0e5b0e09cedaadc65863dea4e47f4f398264"
  ],
  [
    "592db7c27e63489ef4bcef2eafce89f40067cd9a1ba48bc3dc76b5fc62ad9ca",
    "48b7711b570cd9ac65910e75e752f4b751fdbfb4091a28f59b8c046d3d9f8bc"
  ],
  [
    "31d133456222586ae42a9ec7ce8539ee04afbe0b2ed00a2564dab0798d9b55d",
    "a77c52fa1fd718db5c83e7fda6d7d4d9aafef9ad95cad621470f2b753729e5"
  ],
  [
    "4651668379883521e7983aafcb93811b4a72ef2975b3277773746708ef3e3fc",
    "512507f3f544d80ba5d47f73b571881e8d70d7b1d305b9704bdad036b7abc47"
  ],
  [
    "26069e359b2e847affaef604f772f36224608b7642245d0e643889ed231bddc",
    "75ae1ec379f074ebc91270077c74b4d34347ce183b676b4dbe100bfff143b9e"
  ],
  [
    "3196d01d1fa11dc3803b4813c4bbc6326869f61410f2bd14bc0f570d875aebe",
    "20313217cac79875bd2a503db1e86d1e5559911667a02524759344468d9561d"
  ],
  [
    "483256607f75f06fb126addc60cadddd602154cc4782bcc08351a48745d0b97",
    "2950a7e500ebbe9775f08be37cc2e62ccf9030de18948d1bab07a4a9173f75d"
  ],
  [
    "65f07b6050a2fc6eebe2c29ffa62f764060f7f9d3c82d2cb5e4e368aaa442c9",
    "562c9654b646cb84a213b41de203c871b3eae0a05c9c105a66a53c319c06373"
  ],
  [
    "284870f6181c43f3b01d94baa9c5b6ada0deb861145523ad9169580eb7bed35",
    "5e03e6c40c1cfa3cafb01fd0622349871832a9d35499d06408a83edc1b76d02"
  ],
  [
    "32229810a52137f0e6c3d37595c46f6132822d4b05f42674b48d7a7ac3ad85",
    "7babde959a0cf2c53ee59fc52c77c3adf899453f077f441965629f9aead30cd"
  ],
  [
    "1ea8b98a6b85e74e0a2fbc18b206e290f3ed94ce99ca665e8e2351dfade990a",
    "478e93c4724115fb1648c8d5347422adbc1a0bbf962b2312e14aec80e1be742"
  ],
  [
    "270cbaa08c79140c85b864475a0bf569cc03ac785e57f543dc444f37ce746cf",
    "3a9b8d894016680ae9d1bf3deb931d8987d4d8d8bfed45b81ccc595ec79046b"
  ],
  [
    "6943922708b8ae5b40dd7031ef2e487abc4ac39a3591368285e83d6c9c51f4d",
    "5f157c37d09634e8cbfbef90ea50af59815d011e419a691c67ca3402b5efc33"
  ],
  [
    "48ac6a80979fab4912cf0cb557d917a0bd68825d8658ec100496eaae6ff62e1",
    "2b6931350ab183402e39476340eb1177b7006f7a552915581e29a79bd7203a0"
  ],
  [
    "e3adf9517d92ef22d1e2a787740a292ba32d5ca69faa9e8675f63ed816dce5",
    "36bccf69bb12dadd610145a3399213248d193660d8dc90a2e206f23bf2c7997"
  ],
  [
    "5e6c8ae5afb2fa470f767581f3d578cf6a49547e4b78665edfd45776948bef8",
    "6cbfc11953dd7e195d2ce74e52a60df524767b44c4608bdd755be4bc85eb74c"
  ],
  [
    "15a576a1242d39300f0db3ad770983825988da0457718ecd596c63a0a0eb4a6",
    "69a42e5f6f5a63349b57683a4609bba90f556a1680fa1ec3b02ee7d3211f903"
  ],
  [
    "274cd14e4fbf2ed07402e8ad8075b320c5f76b7ea45ea36af523e95ed63ab50",
    "6ca640f9557c5f2d8b27f6ce95b108880ff4e4816b26b70b6506114389ce656"
  ],
  [
    "4d8284e132e2fe81c5f71be1e3c79ab51b229e2c56c323e207cda179999d123",
    "116cfc00e9fbee1cf16af6282123cdf20eed13021c2037ef4c86f94eb6e6cba"
  ],
  [
    "4056194fb5643e97991942ef5b63cadd89080bf57a01489c4398aca03f0980a",
    "2e2cddb434fa6f6da7859c3d518f0ced8795eea043a6c9613fb3e020103339f"
  ],
  [
    "5d119d5c5ce532afc0875e0ee9b026d878c8773d34237f90a0d0670da6f01b3",
    "4a79fc025ce076b6a4742fbcc8cad313d0a8220c58024a41a5a674c0947e64b"
  ],
  [
    "11800ce4061d99b9d53fd4138802335258f7798c5a935c9979f5a949ce1d483",
    "36745a4741a5c7290eaa8f2a3f9ec955ccb7ca323272e5d35d35c2a724ffac8"
  ],
  [
    "4302525bceb97fa642fd5560a4a39fba3d2c06f68e6aff3332ff1854439ebb3",
    "e31edfd081ce82f8177b2d7d96e69851d09e908c2517114ffb37ee12c0ac64"
  ],
  [
    "2f5fcbb96f0a66fd3bdfbcc78bda361cb812570f50e7c476533d56eee01c0e3",
    "527428a34855b5695c479d8fb7e831a299f7897f36682a74169cc60d160df2d"
  ],
  [
    "52167df045ad0dc999b98de3d035aced9da4434211149b8cf4bf20e774580cf",
    "19051d2a1ad3fab190c5dfaf45188b49b4e90cca22aae54f0a785562d3d3f41"
  ],
  [
    "541b5332491dbdb2b6f6bccceb7634970c046963891fae936dd950f4432b961",
    "78fa54da996a51e3a9c06091d58c2405a806649da2bb1f323807c4eec50eda2"
  ],
  [
    "5f11e973da659b7738f87ca5bd4f3bd02207dd3c8d978f0d3e83fe81030febd",
    "137aba7027069f62d25caed416e13537687bb1428e71e5f0a0c52d52f2e65bc"
  ],
  [
    "15ec941ee6c2110b819b5541be52981c09d83484c9dc735c43f39f5778718b4",
    "4561826142dc5b56acfcf605a78a4090472bb61235bcd605a765e05d0a7e549"
  ],
  [
    "68ba398736d659522f484406110b43c68158bf4992094acf797a38979c587a4",
    "7c1d9e1702e28afddf22fed7a7a79df4315c174d0c6c4f4c75bc77d9b56777f"
  ],
  [
    "67889cea31c81a429fbae643a4fce0ecd690a5c32b99397e39ed6d7a08702df",
    "7ea277c80b671146c9e455b98f42f45b941ac95ca2d15c8fa9ea82ee9b45e01"
  ],
  [
    "596f2c68390ac26505d3c2eca5c77d46f8f3acbed192a2649d8c525a58d2334",
    "49f3bd8c62c610d5c19c52d970bde24b270c4ff7ae900453b909e72483974a0"
  ],
  [
    "567779fb8b0afe592cea284629e3621ccfae3c4d7d3dc559c9fed750591a395",
    "6010bdc33f1cdb374facefff537e7910b72a1120502f312a7ce41df0d552ddd"
  ],
  [
    "cebed0233e810aa6a29a8b0829d28f1c92f303d14dd73d6b12da98117dfc7",
    "4bdd51e1192a00df23aa8d0673e4915877ca41ddb8c9eaf21d39dd167fde7b7"
  ],
  [
    "4c7085f066adeb6781596771972b188177e63f2e2b3788d03e033cdd5af1f06",
    "2929ee89f525862b0cedb3ab9b5166e1680cb77fb4668f10a6a3d76b5434566"
  ],
  [
    "760e341bd836899c226176f47685f69438270c150c6fe7744cd723cd1e72359",
    "1bf09f2f1aac1a10ce8bdf20d5d178db747f01a4aa0aa8a5e4bfeef562cd94e"
  ],
  [
    "6016b94c00b54920027ef64902c61478244b1936337d2ad41d9a8d43dd6a4b2",
    "3bf3dd9bce7f6d6f120de87fcbce6219340b59c2c1d75ee0d45105d33aab1cd"
  ],
  [
    "4929e44ff692eb944d1045bee96e750219cda3bda0500029f0df49a1db30b5b",
    "2e138dcbd092242699004b4ce98764ffe4e892841f56830af298581cd1e523f"
  ],
  [
    "5972d0e526311bacb70a04e88969b6c63c7399b578f0dc28bbd00d65ef01da7",
    "76b22bca9ac12d26530e7b0757e646beb3bbc5680d0f3f82fb8ee57ed4b5e39"
  ],
  [
    "2ca0a42a26e26934ca2d48db960b4719113d87c5e57fb437d557c5eb4e03ac7",
    "62778c02561d4ec5d83a132afd7763a8349207c6b5d01fba70b56ba660cba2e"
  ],
  [
    "5137ee53f076e21a2c23da09f63c0d275408c31e4634a6b6373be5cf13e6c00",
    "14fb446c077beb78e04de3282a63bfde12f9af85caaca4ddfab506cee31c0c1"
  ],
  [
    "7d944853d1627b63f560aeda33acf640d35a4ee4d23a744957a2dae9d5b7c6c",
    "bcb411a210710acbcb9ea12680d89e3e4e652228b6786d3886e95f4d9e6970"
  ],
  [
    "37d412c2ffb173a728477446b60b2b702d07a5243cb5fc8963e623a5ee75843",
    "672c79968908f92cd0cb0b4c65ba86e8f359b015623a89441e1bf859bba84cb"
  ],
  [
    "5b37f472aa80398bff12cc74c8ee784c4fc89757292580d3a498bff17e9f114",
    "7d79da1aab9cfef58a5f3d1c9ec466956a45f8d2af0c1da6dd4c93f720fae6e"
  ],
  [
    "25c09b3f1188c562571536202eb0f5fc4b9a7590417b8ea58b4343685d88a63",
    "3d5b817c73b37e9a1d24ca923351359b42ced2f3cafbcac8c2d6322dc767bb"
  ],
  [
    "32e60904e73f9756f71e0a918d302aeca17cad4acacc81bab15702ab5ff78f0",
    "bcf4c0204f8275072f98a65b09ac58b87cdc9c70c4edfe99fe18870a3a5459"
  ],
  [
    "49c35575996c1517d2daed90d2fe4a58e674d6b4aaa7288d0642c8bf59e562f",
    "57eeee00adea4ca80eeabab57852cbf03f1a57e21872cd44221e0550b9193b8"
  ],
  [
    "10e1776b4c2a867bf1b028c6edec224cc6616c747e272f49e69b67b02a893dd",
    "8d45d62ec8e627b56950f2f7622a0438647f9e9f28e723e4a37cebc039a1b0"
  ],
  [
    "79a93a75ecbe943acc964fd39ecfc971dc6555b2bc335e7b53f52f4eb16cd36",
    "146132a68ce2ca8b48363612226771ac547eb3cf52b6eb7981718faac08aa3c"
  ],
  [
    "6b22d32e0590e169504e7f19864fd646d0994e7ed3e578a5b88f6e095913439",
    "68c3b22d859fb85e5c8fa0a8aea932285945b230957e603394333e9ad5acd82"
  ],
  [
    "71ce5ec8286eb8c93b8481c6d19cf0a288ef4da4397e9c80f65023e516bc097",
    "54470babc742780cd8a05499026e738ccbf81d4170d1731734de68a8e5b402c"
  ],
  [
    "27beb13a43bc6a1f6ce046da438b0beac5899ff4d57962dcfb6476b563f74b",
    "14074e9e93ee45394dfbe833998b9d1691961f8ba3166224b36404448c61bb3"
  ],
  [
    "6b1de6c8f161aa6509a1dcacf2c0aa1bcf6ee9d9b40e032a9d72f77a6fa298c",
    "5e9312eb5b59d6cbadd7d3dcbc39f1b5bd9a8346fdcfdf1107bada6f9cc048"
  ],
  [
    "32670fc3fa43bf39974ba72ea51f0d045d92d084a81fe5282dfc8309aa900b9",
    "518fee521bf1af62356aac3b7e53fdbf57121e030c6e9572b3de69912ca4eb4"
  ],
  [
    "4b9ca363eabed9c66091a347375f7065cd28f49f914447de7cc1461f1375f1e",
    "3a1a3a2e5e7e72476befe2571ece708052d740d02cbe6fed58740968ae609c4"
  ],
  [
    "4cc6da42863a3deca62fa218b7a3b50e034eb4bafd393eccba3f4cbe192ef10",
    "20bfa683c884f203713953b26d2821287ecd305fa2cb70570474533fc07f918"
  ],
  [
    "87705353c44a5ccec8de65cf5433be6b3d9bd21eea49b60e6c907cf1a67a6a",
    "112804b13eee56e3b01aff75fa08fa8374c44fc461aed8a30ad54acd09c24eb"
  ],
  [
    "6cf6eeeb9d339c0a05f72fd5af73fc7588e6d957100ee8999109437bc126cae",
    "54fa257cea22032eac272fcd034dadf2e00d602ef9e519cf7072023c130aad1"
  ],
  [
    "19b32925048c5519d929650c833661b452ef7be7963fab0b6b328ab7dd7a28a",
    "1bd0c14a10bf9b88ea61011c0b2e64d07da151c6203800d5a5d12063838a510"
  ],
  [
    "12a5fc5559428bc3b4eff97b21b63668b866e0722807f1db1f19696bacd9b0d",
    "4c2eb07f0c24047a3d73b560144f3fd32c99d6dbd9fc7cd2fd2a72a6e4b24c7"
  ],
  [
    "13662b7a7d390aa76eb86a7c3bff6d9913eb28db6bd1a7c42de5cdad2e35ce2",
    "40626aded7f56f82cc431ae30527b096f57fbfbc04d3e12a5abae3edf301cf1"
  ],
  [
    "255825bd49b8a2cce114360bd9c8fe8c641af64c8e7710107213cfcb006f43d",
    "3619cce4482335232f9e76a1460be9d296f2d468d26e4f95a78c71524fe59cc"
  ],
  [
    "7f83009eeed4f12f54d341bbf06066480cfcdf51dda103ac54d4bcecf6b3b31",
    "4269519d28faafd7fd68bebfd8404d71ba05d62c4bb6d65d24aa6802fb84ab6"
  ],
  [
    "2f325650eb316646b4eec903fe44828fcb11054f1bd42ca3a77f7e734110b35",
    "44f976082271016f9048e22c507d97d628722bb431f8d5cc1890524e6c386bf"
  ],
  [
    "750b166bb6edc0ee80fae39c7c106879036738df2d79fb2294e1c21e9a24d6b",
    "54f8aa297a1afafe2a17a3254f45861167414327e918d17003c6aad01d0b24c"
  ],
  [
    "3aedb10db9cf3285cdeee375879396fac1fb50dd259e1716f8c01e66f67ca72",
    "7feb9400f621f58c21601f23b7ec7c94a9b6b193c1cd74a8a60846aedadd359"
  ],
  [
    "4ab7151702de76faa493e7a0b1ac20ee4d10c33b83fec9477547cb1236973eb",
    "63f1f122e3ef3acc46b0915ac69c3f5772879799cad889a817f55f5853d1235"
  ],
  [
    "1675ead0d20e5bc3a7a7331999a87ac4c916ae29669e54197bb02aa6364520f",
    "4d1122da90d49e491922d9b533a6a668e2f65a2737ebb391ebb29fb7c1f8a9d"
  ],
  [
    "2f7148111ef53c613157aeec12e16a20f13481da4390b6ce18a85d1d8547087",
    "2eeda779ab395597651d2a0b833ccf53b10280750139916ae2baf4ec57c633d"
  ],
  [
    "4439c7810e7b2ba772b701ec3acdca0b80c9df23047710b87f7dc3f13b337d3",
    "5029cfe704c602a8a4662af0a5860ec03fb88f046d0e3400f2ce7638014c621"
  ],
  [
    "2248eec40b5732a6a488b681f093643af7937071bc73118acae295a32b51b05",
    "1577e4aec30a97b648de4d0b19cf8891151b4eb11f8de9c6d7312f091552e19"
  ],
  [
    "4738424e558d4e0d87a3124ca02ea24f0adc6b7a9768b0d3945ed2a6104857c",
    "33576f92aca3f0c8ae689c3c274c2de6b918940d86a6852e02fc99e35d1614"
  ],
  [
    "7829edd8b866ebf7baaf604ed13d19a9797578f44bbc51b1cd67ca53803e96b",
    "5559040a6083f2af1f9133ccaf5bc2ce06e56ddfc7dd410e9635c0116b62722"
  ],
  [
    "7f927b881f2cdc05e1a69e40bb714af47b630d1425f08ab5d574ee698f33d51",
    "26a465288e96572de303203bd38f4a03031e8158da0591cb037c0a5111d1056"
  ],
  [
    "36a65598552f8753580d1655417d645a140966e10a1e1663015f9fdfae44881",
    "33d5bbfaebf59eae72b89b1aea12ab2ba3c9617f8c3baed1ec16bdf668381b5"
  ],
  [
    "403becfa545c826782026ff409cc16c9d4fe428f1b5b6e630c92439d2fa5fd",
    "47bd6f2bf5d74f710ecb479c79b01fb774fbdad590e683a415cdedf33f71dc5"
  ],
  [
    "3a747826d241b877d3d56b16e0b810cf088eda4fd6048da174c9991a942a5eb",
    "2c7ba19b0a3486a2cdb84d4a388d34beb077a0e467ba44590166f93f6a09d2e"
  ],
  [
    "3d60cd375842714b37bda89dd1f13a7e0f3ff133b522209617d031bce05a537",
    "f77f216451ab01ad5226844d2162a7f32744688bcb4325445539e2ce5cec4"
  ],
  [
    "235bf66f67c9100e7f0e22bb299cdfaa603644b240e0770aec7e7fd163e2a65",
    "37110b3fa83ece3990afca2bea8d5ebb3c7aace60a0147f8e6ab733e2f2b4d5"
  ],
  [
    "3b796d4eb69a55471fa86108f787b3604874e92b6887a7667a6c2bfbbd9a42b",
    "4912d6dc0419732ef82cb3278415851d4e2d7ca89e0f4d7128cc9de51b810fe"
  ],
  [
    "48d53516dd51e49faa7ab46c8c10db1befd10f23c6a9d9bc3640a2f0da44518",
    "73a2fb3d064adadf21aa1362c04affc660598f38a9e069b3afb74d0a99ae9ee"
  ],
  [
    "48c32cff161ed145da0d5b73084897647abb777adf65738559ceab6939cf3e0",
    "3d99308978e828f857c382df32b472bda81e8ec8e30c8844077ba6d6d2ba903"
  ],
  [
    "2947ff091a8ec9684affbc9a62e09e598841c4a6dc638088492aa47dea57097",
    "19a2cc97975e547f97a4d02e42f89e6ced6f5a953cfccdec347867d26926541"
  ],
  [
    "1960d85f30475615f82484eba0bdafb7ea7cac3809f0518a757d66f02b01676",
    "36c8f77baabf0cc8805d993bbe62041fcf4e3239cf9d53278a4fbd91e75eeb7"
  ],
  [
    "2765f28074d21d5a055340b6d40092d2bbef807e02009fabfa08ec0b9bdf38b",
    "7fb189e0553d5df52b6843661814824b3f3cbebbd54988f042fb256c6bf30b"
  ],
  [
    "348836cb2aaa00212f4b1a4e2d7fc5417f246bf2fe5c9a16ebabda449e2e08a",
    "3f7276fd7d69e0d55ce5ee1d2d830534a27227fe0b6d8a36c93f9a78b872969"
  ],
  [
    "7afb9d34b6a42ea8c6d870e4b8191c274201dc1f93a1a2219a2392b7e345a31",
    "42bbc20dc7115e0758b364a110227b16b64ec58fc535ce5ff1a9ad8b8a09fdd"
  ],
  [
    "2cae0c2afee1767fd4c66f52e1f176d217e92e89cc19eb36d5a6c1715f641a",
    "5335efe2d9bc3667d25ea88bf76438a4d6ab9ba5c512f9da7d0529b79b62d83"
  ],
  [
    "1cc5fde334707723c3a06f00c106db88664284a2df47bb6b144d9f960aea3e2",
    "dbbf610d100316938bcd8bcd078513512ecb50d4579690dbefaa419c05980d"
  ],
  [
    "54e90cb8f3a2998d2675c5780679e06c0556b1e618f8fdf07f9a4b2466fbf1e",
    "16248676b6f06ec5e34994bc3115f85c8147b54f34d8500928f2fdc051e2089"
  ],
  [
    "525c70a2ba0dbdd68d75640f47f13d0d415ea595f7030f533f4625c2a46523b",
    "58292c8675e5e1a438f49e0c05648d9a7aa997f2f1fd77d5de1944afe5d7eea"
  ],
  [
    "54726d78d099007393348787a03107ab492e59690a46c87fb02ec554f2353bd",
    "53b54b77184ba75a3391e0ebfa6d6974db028f3f8e34bbd5460759a5848dd76"
  ],
  [
    "4ac81a66903537769d3aac6c483ccc08535cb767b6b5e1ec8017a7393ab70ae",
    "2cb22b77a8a05d26f11a4dec80eff292633aa05553a889c5ab16b6ac6e2ab17"
  ],
  [
    "21d0175349e21114988a2930b9a607d43245783cb4a0c984ce27f4c4206708",
    "59f1f49342cc5496213d3329bf4ca7fb0044337449c579bf53147a1dac9e67c"
  ],
  [
    "167f821b381f4c8adcc39789475fb55ba639e5124fe75f26dd61be396dd5e66",
    "22002c87d4cafb47ac9d27286d5cf5ff7a6715d69814118269b0729be9e4b3a"
  ],
  [
    "31010666c6db83a9f9e4db4c48173afd405783ac53852a6e38a8ff925528843",
    "1f466dc9b5d9094107c741dbf380f9fd98d8549cd50f67169901516f8cce74c"
  ],
  [
    "1ad3875769a5053388a86edc85dd80fdffbbda6a456aea497ff81a0f1f6707b",
    "2de7cdec5e2bad56a71bd2f33a4ae4c874e1ad4210a6ac32b443cfa34e85b1b"
  ],
  [
    "c489650fb7f459ce09cd05a456fc5a46b849b38a671298ed645bcdaab168b0",
    "45610d092b8af1c43ceed474cd17f7bbee65120aa6fa4d37f949e7e41f25327"
  ],
  [
    "394256a5ef4d7af5459587a0bd2edb8acaf5ecfef2563c9a04daf34a4abe4c6",
    "1ebee390dae1403c0c53994e1d064fa64e20fcb45392e209b2b99486a559ffd"
  ],
  [
    "410a1511fead6151e9bedb089b9832d0fe01fab76d3f8459929f767525aeb27",
    "361f0a5ffe09fcc3ad4eff3f5e89508ac247af80267100b69de3c59df561cfa"
  ],
  [
    "38cd437c9f659e110a869605c182ee9fdc26de36baf559d9229e258267bb734",
    "624b1128ea7739bf1cbd0e423af92a4884323c868d2ba0ee9d362946edee2d1"
  ],
  [
    "78b126e50b7042d2a019f95cb87a3213c664ca1bafe345999b1e9e2dac1e608",
    "19e398196b22f4488cbe854c614ad8c353839abc5ab3a4f3f5c03c16ba8a198"
  ],
  [
    "6d3a5ce91132f385a91823c5c8046c4b638f5fe63357424410d901457cdb867",
    "7b80bae16d2d487e122495174f7a70992bc5dafbed72bf84127ead7c57302bb"
  ],
  [
    "32d053a904dc4d88fbe7d0b96e0cbeca22a00aa5c79c753d52b0b60abf31602",
    "3af6a02e5cae6d6490354ae51185149e3fdb6d0d9caab90e95ff58aa0c40377"
  ],
  [
    "49b1fbff5bdb0aa6938b066dde0ed772c0d81f9eff52e7fe038b0ccbd78adb5",
    "1c6e57834eb14d507eed8b36c81ddf92fa91c242467061927a742fafa82b43d"
  ],
  [
    "2f28b8994ca6f234d9293d26196b43b9d1d5306844348c4a638102c05de85f5",
    "759cfb172eab065d477248b3569f4ff5791055f01e95fe71b94b8e615d73c96"
  ],
  [
    "3c2ee954ff534f856f59188fa0f29ed8a022aee0cac52d634f6dc58cd514d70",
    "22bd162e74925f0a876bd8a206b8767dfdd7c898576a73a490f138d9a7f99c6"
  ],
  [
    "5763a7cab001e1aaeabf9ab5b9b2fffe6cc2b299ab04ec4933da74d960e1ab",
    "715ee4f8ee93ab5a1dba00f0a6abc4eec47d49b61254cc27fc36a031e32f0f8"
  ],
  [
    "19976ad8d7b7f47c785408243a227401996b36e47c7a78a7bc7d4256233ba9a",
    "896b713c5d7777b0703821a73c1d9a4c3755501042120534ff13990975e1f5"
  ],
  [
    "61674b992c29827186cab5ff454758dbbed8e89bc23d0bd33193afccc3a04bc",
    "38e1020744c13903809ea30a0662fdb5226ae760cdcf10800faabec452e00f8"
  ],
  [
    "2ea2d48bcb83c0c9cda4efe11f07165cfcbc9ccd26526e5fb12556316d4b1df",
    "1d2d68b74ad384c5c4a9c85453104216357bfcdf635680b40215f0f800974cb"
  ],
  [
    "7881212050264c40c336ed3a15dd2cd868ec9a558f5b728869eab66e8b8ed54",
    "21aaefcc8ad8a161b8971d6880321781dbd939570c540da4c330922b8c81e9b"
  ],
  [
    "b6be88ce0461d20f59c5199573cda0170b61decf6e8e69a6d32f1695adc4ed",
    "5536e4808370716f2bb3423a9a49a38ddbfe91faf3b7a35eb53d3519238b6cf"
  ],
  [
    "e5972af1655eb6dde2e8c77cc58044299922441b5ee41ceaf5cafedc765bcc",
    "550282f37a4783dd60801c237045992d6fbe82a5902e7d837ea25f6f98c7b3a"
  ],
  [
    "7efc1aad1f580d8f50274f1c114c40056be19a8c96fa8c4cb5bf85e1e7f3e4",
    "2689f1c3898b114d668be6413643ee9f879913d40c262541fd0316264c60a4f"
  ],
  [
    "7939db98037f59b0113e9d60051f75ac9c3cfd1a3eb535c73e2d945068c6c5c",
    "410914ca8bbf3c65cdf3e9772ca790c19131c50068d34b7346c10260a578a8e"
  ],
  [
    "225b77ad00a2b83d26690190b74867326eca4f55bfbc3a13be036225ca3b1b5",
    "411faafef89042ce6beb64309fdaff70fa53e9d32d79a21e7f82f80e79ff05e"
  ],
  [
    "1501e64c99c8b6658b0479f2c05c9142d246eaabfccf2fcec8dc4399539d8e1",
    "3bab1e3339e42c9ee66c65b0b20236fdd9362d3ce786ad3a9779ab578af50a8"
  ],
  [
    "59b907b941f24fb8ea2458153e55f07534b388e835af7b69f3c9f54392a335",
    "1d5438c4f2f68a417f3d56f916d899a6ffe910f5f2989ca31687f1b10f60db8"
  ],
  [
    "2887d08a26f484546f360e33abbf7a998b7170a5b30070938b84f072c676bf3",
    "62a78e8d00e5d3a59e2fc424ffa08961567ba1ef24c8531cd7bceee6074a535"
  ],
  [
    "6e3cc8076b3d45377929033af35aab0c6d19ae4fd47c0daf844079ca04c46eb",
    "7b90f338e4d848aa8f19d0b5c3bca916a2a9024acbf14bddb278bca2aa39e5f"
  ],
  [
    "34844dacdd3ec54a3af328bb9d67715ab33425e194ac9977ca02ef22e8f7a88",
    "3c1affc6372f32a1634748124f9e1a03c4f0c993971da0dc28888b0801279d"
  ],
  [
    "436b192e03a49796cf9bc5e93c88268b71c9c24f9c3a85322bba634ebea309d",
    "67a8091ef69d62abcb28ce5df4dc7d53f8dc2b9690344f75ecd03a6d9386044"
  ],
  [
    "592d25b68baff87a6d7fd41ff0dadbddc1bd1316683de3b2d677501c0eb14e4",
    "27ad1e1099683f54589010faeefb19e38569ace43653be8787a42b0591e7bc5"
  ],
  [
    "89a5111ae911512ba62e87b97f643c0219702f235c70f62c6678a129302009",
    "557fa3d98e9ce7b83b47545013a4498f3de43787fb66b1a54521222242f7c1b"
  ],
  [
    "1c9b5e53377e72da5066cb08566bbf9ec31ec1877f455d932cd9b1aa375d34e",
    "72f79555a8bc207863f32d482fca54692825449fd8963fcea3de3a8183a739a"
  ],
  [
    "574a6e05eb14591729515be239ea8c1fa9e12d4049d42876f76c8ff37bca03",
    "5f99b3af43ca68c1c73e8190d5f73c8de162ba643d7d5f0cd73cfa8135db6d3"
  ],
  [
    "513fc5c2e16505b2b25a2f284e167d5401194bcac0dc3ecf8b7c9acb560daa1",
    "687ee7a1a8954d08d3856e1a16ded808e419e789736d3f55f79f7693bad69f5"
  ],
  [
    "53d48bd1205274b1c2b0a0ceb3d21c5fcd7c8892a784931603240b288a598b9",
    "35387abd7ea59c9b956de44d36533cad1f6668c438d666651695ff3862159be"
  ],
  [
    "213eb1ea99e08825110dd61094eb6e8145119dc1c507636f068730b1e086d44",
    "744f6853f4f02f4f042468d0739e0c9f64df720b87ed77d1979547084ef7a89"
  ],
  [
    "735ef017d091ca23264ad0aa7bb9b2be3309b4539605e79ed4a652ccb2fbe3c",
    "7f0ccc7a5747c4e921fff97d431169f690763427e2cfd1ad74d7a0308d7faa9"
  ],
  [
    "3f36babc5a30070b610ed97db44997e6d9115c9c0579ad8f75d295a17130001",
    "79047908a2474e32d5c712a07bf5c4ad522590bb5d6cefda410d30528e12ca8"
  ],
  [
    "51c04907ae88a5926b242fb2862cb1f2c651a94e6caad5bff8601c079fded74",
    "10a585a269f460aed43f54c7de13cdf623fc8de5957526997278be939ef32ad"
  ],
  [
    "c1e1bd626a735aa2c065831317217ecce68e377eb1f67e54ce2e97bc2ef2dc",
    "53c5af23a9b482f420be6dfd37b6886154cfd130794098e1f51c1885ac2556a"
  ],
  [
    "5aff3b30775ae4758e604a4a6262803a545f5ef4e7855fa245ac6a6431a9ece",
    "39a4799e5519047f29333bee9c86c99bfa8056d4aa381c396c4a44331fe795f"
  ],
  [
    "3d753e9723701a8e9d99b91bb93dee2eda7ffa5072fb2cd5c5fd99aebcdb299",
    "15798bf5c17d6d5880fed1553af32dd8d8baf2888c715a886575448a24c7975"
  ],
  [
    "6593e5078466b07a4222d2e544da826d2c583c9cc5f2eaea148b129b00d4aa0",
    "11b352b08a0a61d3cd67d1dc08069dec3bde907b3da0f56de5011b956bf8744"
  ],
  [
    "7a6eb353c5be9ff03fe4a06c01fb71aad2b38144179a291ebcbb2c2417cca65",
    "3de3ecb12f2fa699b46a9d399abf77ca17bebc3e491bfb2542dd0fba991e2bb"
  ],
  [
    "2c7ead583d6c32162091034a9eddfa775b4e84b8bdbea939edb2a80dcf64f6",
    "461790ce40d9c276d962b2a1e9a74d66e9d7335962e234e8a2fc6963d31722d"
  ],
  [
    "34285af023d9b4c2c2b88e8704bf2c05a9b553b00b2e70ff05f8c2970cb134f",
    "33fe678e7671760a83836107428dbade68c3593fbe568f3f8f1b2c568099c44"
  ],
  [
    "6222f720a24466263db6a11842f117fc4bb78da6705f140e48869db3e087441",
    "6eff5b9bf3aeedc962bc5a24b66e7bdad2153450ed53a058bf2c8dbf2907693"
  ],
  [
    "17c6ec5ea206eb97cbf53851e37ce391080e0d2bf1e5395610f79ab0503f7ce",
    "3adb71ca3523d88ceb1e365f12dfb24895453c14daf0046b2626cddadfdf5f7"
  ],
  [
    "70859f9771a713e54974ce11cdaf44b0dcc3e9befa0c0834908d877eeaafd27",
    "d18f794bf0cc0623b711e7450030424e52326c45ba9b03341883ae4828a5f8"
  ],
  [
    "2a820cfd0fd4ab0871e7b303cd545a3086caf8fa818c087a4017197da74efbf",
    "5f992683ff37f6c041b84bfc01503d333ac9763505cc8f69473da01812969d1"
  ],
  [
    "5b0526de2c07fe7cd73e3884f642d57a0ac5e13c68590ed03a14e530616e8c1",
    "eec69d0cbd92c9fca31ec967dba848bec368e792d6678797946a5e34fe3487"
  ],
  [
    "6cf6b3efee707210cb3a72f1e885c3d0953aefb43e5e148c740aa1641725c61",
    "911cb630b898e2c1a9115f9e45bafe3b819edfb1eab6e15612d14289939984"
  ],
  [
    "74e913de55f1e46143cb2ecfc580f8d3d3908f200281322b84e21c989cda293",
    "761d2736c9ac7670ba905bc2629c6c0dbe988820a4454ff415ba68710f7df92"
  ],
  [
    "44084305e0c911a40b7cbefe5f13cffe9a99375d1a584c4a2200958050af7a9",
    "249c83877371564708ea525b64b1e7e12785460d83364446531c9adcacba5f0"
  ],
  [
    "2bf71ad4d1bee1a67fb300477029f54bdb0e09f78bf2ac2e8afc7465a7adbcc",
    "6244dd6cad282539049be57487bfd9900bb0d5da805d02b535096368fcb4cd5"
  ],
  [
    "3a62d8f763b62def36e4089458046a49c5ecb91b861549530773e0548ff2bb",
    "6a10a03ba61e6ac657270465c09aa9526cf1ebe96bdecdf0e7000476a47b9eb"
  ],
  [
    "284eed3a17c51e0677d4fe897f056abe9def8af07a4630e6ca5723e2aa6677",
    "516a06ac1d5626ed03d2eee9de6f60f0311eca703a99b0fb31b9c66b01c27c7"
  ],
  [
    "2a2c63b16cccd685f731d06fe93ce2cffb358d34d03dda9a7368185c1eb0c32",
    "7180baca0ba81284809f92eca1654cd76b925a9242e5d5e0f18d0a55d13c6ec"
  ],
  [
    "5f9466017ec09769611389ea5370ad68dda936d3f5816c9e928ff9574abf9a7",
    "6619b5b145bb5f4f29deb7a4cd68ef4da3995312fa6537f0d01684da4267ece"
  ],
  [
    "74f229babe01b4962b3307589c1a13019134b1db6822698388bebb55d21c30f",
    "156ae857ab3279f754facba0db36398dffec8c31e5e160473198f2f891b7531"
  ],
  [
    "334b9fe3a5fd99bc966ddd1309698fd32afd1f235062f2c275b6616a185de45",
    "221a60053583cc0607f6f2e6966b62fc9dac00538bb7eb1148e007a92116d2"
  ],
  [
    "7ad710ba002a67c731efbaba2149d16fec5d2f7aa3d126fd9886172e9f4ea30",
    "3a10f8e902a7a13aec94d66415347e1314f9bac83a7db176096b809b25ffb86"
  ],
  [
    "4306dd0a184a3283c3097ff8f7434cec80912e9dc04b7df21ba73fda9f8e6d8",
    "6d42bd3d1a8dbddafd09e872e2aa3891ae79ec939dc1b382196bc21c4ab749"
  ],
  [
    "1c3f2124e1135c32a426d1d14e471edd9e0f2c7bd703ee123cbbd608e8c4be7",
    "3cc607a3c3f1ab68dd5fa56c65996002721b8ad8ad4b0dd9e5b1467d316583"
  ],
  [
    "294af33272ffcee0b56a436de1b73759cbddebef4c07888b42c2f92b0b68e1",
    "d837164311d5dca8d37b99ef9eb22708643c83d1cbdfe852f63ea07b06fbad"
  ],
  [
    "753bdb5439a19bbffdfa02b1dc24e8368f22d0a8276b109c11e6feb26f56f39",
    "6ed396231af93647633eab467f1a034f38e76823eb85baf97cae56e2dcd9f75"
  ],
  [
    "5674f0cb892b733fc0b50e121d8679afed0a925c32594cc65ffe83bebe7748e",
    "7fbf0325dd38dd94905adab2c52758552292a6a103d9edfcb11938828e828c8"
  ],
  [
    "4a8f053573a0a74251059d0229d89b6660407ba0b491779fd10f87a5117c81f",
    "21b70112485398bf67ec9d733df24a1df30dea718a93b786f41ed04e3ae3c5e"
  ],
  [
    "726c01ec4a08df8fc8de173311f50d4f3b97c5a9cf68c1536146f827db95ae8",
    "15013cafadefa7f1c4e4dfdd70bd4d3979dd18bd7f0332572ce2a3fd8773d12"
  ],
  [
    "38ac0fbfa98937257460db7e6645d7e5112b6fce7234813fc8a704e8ade8da2",
    "73c0109f86048aad08c443f781ae60ad13b99f7b9cfdf3128fe6d6eeb799a7b"
  ],
  [
    "6f6d3a38621582ace092eb50ecfe9eff265df141ebdcab8653299116fcea291",
    "4a1bf3f39bc919c8f1b720a0b1ce952cad17f2ba98308ee6b76dd9b6f3d7b75"
  ],
  [
    "6a307fc28e1df8d9ad01766419e097797d65cb674436fa1c8f012d3de2c2a1f",
    "26911a635ba824db004875d79dd84834a97ac12643e42829015bf88c1fd6f05"
  ],
  [
    "2a74860e3336d6db916555894cc8028f41508812925db1925457afe40257155",
    "5f8da573f4c39816ce2dba8a20224223a7cfec53117ec78973930c0e9b60244"
  ],
  [
    "4d2b49e1ed0799f719b8269f092cb489a466a645bc0ccabafdc678864c176d7",
    "5410083df7d256f18cbf5697ae5e52c31e075d8a3b27e21d6f5177ca882f6c1"
  ],
  [
    "110ecb9fbf6c333d168cee473cc5ad98809b6cb9eb5d1f6cd28ab5fab504fd3",
    "7e3c54d7533d9f8c3310f219dab0cc3ea4d39b418a748eeffd6bae2b8637a43"
  ],
  [
    "5be4d711b80da70e6d3ac493250bbfd16f20b25f31919b3a91cf14ffbac1096",
    "7f55a0919f082e8885f1515e83c5b39b6022404503507498e1b4422d79c43e2"
  ],
  [
    "2605125b95ca4ba93a21cbbba5762898a7cf9e988f07ab9e64cb3868e3b139d",
    "62f0ccf55b9fc0eaf9736fc8ee484e2acdbe259813af9803cf815829a5e9d3b"
  ],
  [
    "1092bbbf206f2a3068167c3dd99a72de31e206f6c504c071c8214d105ff814d",
    "309f489f68a62089f53b96df5d4fbc3ecc5a1a42eb7ece0e49bad17ad490ff4"
  ],
  [
    "2abdee9409d9c92559ca3f4e6bddd649c31aa09b90bfcb4a612af491241e18d",
    "3ffa8eac180a29de3f8a69efca84bac046f921f5725e96a6ff0530be1436aaf"
  ],
  [
    "376313f27d00bb1aae7ec991745efe6ee28c6b50de0c6cd9845cc4bb4f83543",
    "6a8e0a9389ba528b156fa94ac090a895d7b795818d4941c29415d9e2984c547"
  ],
  [
    "a80380c71bd466a696b3f0fbf02817c9459d9798f4f3899cf32edf647fe066",
    "6a09805e814e7cdfc76eba4b79f1df5ae559e0f0aba9f728d3cba4ea5c57471"
  ],
  [
    "223694b921d247d989a79b9b2b2f07496036c40cb043eab074a9d6a2cd2ffed",
    "c247217f1b1df35e30d9e15fdaadf42d6fb0edd3a5a7e265d4cdc426c120aa"
  ],
  [
    "102333620df278c6714bbc880fc087db58c1b9b4d77ed4d61b32a74bfc7c3e2",
    "6a77d37727ccf71c2caeb151faf4404d4b94e9047f9f0a7c3966367f3b53c65"
  ],
  [
    "891626f466536929ee7eadcd18b41925706dedab7528ed5f0f7abf039eb9d2",
    "5f73d11c141c933a35b2d0d06e5cbae614a20d17dc3b439f8bcdc3413c5ea37"
  ],
  [
    "215c23fd3f073f870e5e80303967391bf173f8adcdbeec72d131c557babc203",
    "10634332e9d9439a321597dc5b0fac9ff478834c3d6e281735f21a4a5e13266"
  ],
  [
    "21ea0bdc1332bc36e6aeb43be9071651c27e4ea2eadec636c8d818d4af72a36",
    "3a523d9643dccc6bb9c7c58413312caa3e60ba9c7c7f0177e0f3f469a3241e3"
  ],
  [
    "60deaed1bffb6190beed40caaf2bfab5e43d3707aff7ad3f278d571aa247eae",
    "e41f71ff254c1418e6a66992af307789fe04d6606fb2670900bb1a089fd879"
  ],
  [
    "1e1fac4a1646253fb1332fadc21fbdd3e3a24a840d129400f520ae4116a4cf5",
    "69c406f9f46576afad68808de0ab7e8922b6226af748e721d9097e21f1800f3"
  ],
  [
    "5db0ddcdf79ffe74d6454c12d2bc60b06776db03c75dc413f5be42ea9a91b5e",
    "134c3d6c699841f17306835bb193785228ffe7ab212a01a861c56b086a18cec"
  ],
  [
    "626814e320fb5bea505b248fd1c1389ad586c1cfe04923fe2f83173e915f4f8",
    "7ae407a926e887206a8b85cf485f1f327c9bb8ccbb6897024e2d122877d8ee0"
  ],
  [
    "23186237dc7d3b570cea645282ad4c359731bbfa54e7f036426bf6493812cd",
    "7d1fbab7e61a22d3b00993290d9f4cd5d820061573e787f66c2cff9a18e1eaf"
  ],
  [
    "54302dcb0e6cc1c6e44cca8f61a63bb2ca65048d53fb325d36ff12c49a58202",
    "1b77b3e37d13504b348046268d8ae25ce98ad783c25561a879dcc77e99c2426"
  ],
  [
    "13961b56b9fc0e412e468c385c22bd0680a25624ec211ffbb6bc877b2a6926c",
    "62f7f7792c77cd981fad13cb6863fe099c4d971c1374109185eae99943f16e9"
  ],
  [
    "47abd7308c70659af3f00fafe6837298af3cb530b6c2ba710ffd07a6bc1ae98",
    "75d0c8a7377aa9f0663d0c124a5659750847afabc29e39893fd27534a4a03cb"
  ],
  [
    "2c6276b764fb398fa555857dbe0ce0ec18fab7a233bf23851295739801f0585",
    "5d8f4897ce44007ec5bfcb9aeb78b8f6e1d40a514f72d213c9300d2770d2b8c"
  ]
], vE = {};
ut(vE, {
  BlockStatus: () => V1,
  BlockTag: () => hf,
  EntryPointType: () => B1,
  RPC: () => hn,
  SIMULATION_FLAG: () => F1,
  Sequencer: () => SE,
  TransactionExecutionStatus: () => j1,
  TransactionFinalityStatus: () => z1,
  TransactionStatus: () => H1,
  TransactionType: () => M1,
  Uint: () => uf,
  ValidateType: () => $1
});
var F1 = /* @__PURE__ */ ((e) => (e.SKIP_VALIDATE = "SKIP_VALIDATE", e.SKIP_EXECUTE = "SKIP_EXECUTE", e))(F1 || {}), $1 = /* @__PURE__ */ ((e) => (e.DEPLOY = "DEPLOY", e.CALL = "CALL", e.INVOKE = "INVOKE", e))($1 || {}), uf = /* @__PURE__ */ ((e) => (e.u8 = "core::integer::u8", e.u16 = "core::integer::u16", e.u32 = "core::integer::u32", e.u64 = "core::integer::u64", e.u128 = "core::integer::u128", e.u256 = "core::integer::u256", e))(uf || {}), B1 = /* @__PURE__ */ ((e) => (e.EXTERNAL = "EXTERNAL", e.L1_HANDLER = "L1_HANDLER", e.CONSTRUCTOR = "CONSTRUCTOR", e))(B1 || {}), M1 = /* @__PURE__ */ ((e) => (e.DECLARE = "DECLARE", e.DEPLOY = "DEPLOY", e.DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT", e.INVOKE = "INVOKE_FUNCTION", e))(M1 || {}), H1 = /* @__PURE__ */ ((e) => (e.NOT_RECEIVED = "NOT_RECEIVED", e.RECEIVED = "RECEIVED", e.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2", e.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1", e.REJECTED = "REJECTED", e.REVERTED = "REVERTED", e))(H1 || {}), z1 = /* @__PURE__ */ ((e) => (e.NOT_RECEIVED = "NOT_RECEIVED", e.RECEIVED = "RECEIVED", e.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2", e.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1", e))(z1 || {}), j1 = /* @__PURE__ */ ((e) => (e.REJECTED = "REJECTED", e.REVERTED = "REVERTED", e.SUCCEEDED = "SUCCEEDED", e))(j1 || {}), V1 = /* @__PURE__ */ ((e) => (e.PENDING = "PENDING", e.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1", e.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2", e.REJECTED = "REJECTED", e))(V1 || {}), hf = /* @__PURE__ */ ((e) => (e.pending = "pending", e.latest = "latest", e))(hf || {}), hn = {};
ut(hn, {
  SimulationFlag: () => lo,
  TransactionExecutionStatus: () => ho,
  TransactionFinalityStatus: () => uo,
  TransactionType: () => xE
});
var q1 = /* @__PURE__ */ ((e) => (e.DECLARE = "DECLARE", e.DEPLOY = "DEPLOY", e.DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT", e.INVOKE = "INVOKE", e.L1_HANDLER = "L1_HANDLER", e))(q1 || {}), K1 = /* @__PURE__ */ ((e) => (e.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2", e.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1", e))(K1 || {}), G1 = /* @__PURE__ */ ((e) => (e.SUCCEEDED = "SUCCEEDED", e.REVERTED = "REVERTED", e))(G1 || {}), W1 = /* @__PURE__ */ ((e) => (e.SKIP_VALIDATE = "SKIP_VALIDATE", e.SKIP_FEE_CHARGE = "SKIP_FEE_CHARGE", e))(W1 || {}), xE = q1, lo = W1, uo = K1, ho = G1, SE = {};
function mt(e, t) {
  if (!e)
    throw new Error(t || "Assertion failure");
}
var DE = {};
ut(DE, {
  assertInRange: () => AE,
  bigNumberishArrayToDecimalStringArray: () => X1,
  bigNumberishArrayToHexadecimalStringArray: () => J1,
  cleanHex: () => bo,
  getDecimalString: () => Q1,
  getHexString: () => pf,
  getHexStringArray: () => eb,
  hexToBytes: () => tb,
  hexToDecimalString: () => Y1,
  isBigInt: () => Us,
  isHex: () => yr,
  isStringWholeNumber: () => la,
  toBigInt: () => ne,
  toCairoBool: () => po,
  toHex: () => ee,
  toHexString: () => bf,
  toStorageKey: () => Z1
});
function yr(e) {
  return /^0x[0-9a-f]*$/i.test(e);
}
function ne(e) {
  return BigInt(e);
}
function Us(e) {
  return typeof e == "bigint";
}
function ee(e) {
  return kt(ne(e).toString(16));
}
function Z1(e) {
  return kt(ne(e).toString(16).padStart(64, "0"));
}
function Y1(e) {
  return BigInt(kt(e)).toString(10);
}
var bo = (e) => e.toLowerCase().replace(/^(0x)0+/, "$1");
function AE(e, t, r, n = "") {
  const a = n === "" ? "invalid length" : `invalid ${n} length`, i = BigInt(e), c = BigInt(t), s = BigInt(r);
  mt(
    i >= c && i <= s,
    `Message not signable, ${a}.`
  );
}
function X1(e) {
  return e.map((t) => ne(t).toString(10));
}
function J1(e) {
  return e.map((t) => ee(t));
}
var la = (e) => /^\d+$/.test(e), bf = (e) => ee(e);
function Q1(e) {
  if (yr(e))
    return Y1(e);
  if (la(e))
    return e;
  throw new Error(`${e} need to be hex-string or whole-number-string`);
}
function pf(e) {
  if (yr(e))
    return e;
  if (la(e))
    return bf(e);
  throw new Error(`${e} need to be hex-string or whole-number-string`);
}
function eb(e) {
  return e.map((t) => pf(t));
}
var po = (e) => (+e).toString();
function tb(e) {
  if (!yr(e))
    throw new Error(`${e} need to be a hex-string`);
  let t = da(e);
  return t.length % 2 !== 0 && (t = `0${t}`), Wr(t);
}
var IE = {};
ut(IE, {
  getSelector: () => _f,
  getSelectorFromName: () => rr,
  keccakBn: () => rb,
  starknetKeccak: () => gf
});
function rb(e) {
  const t = da(ee(BigInt(e))), r = t.length % 2 === 0 ? t : `0${t}`;
  return kt(oi(tb(kt(r))).toString(16));
}
function CE(e) {
  return kt(oi(ks(e)).toString(16));
}
function gf(e) {
  return BigInt(CE(e)) & N1;
}
function rr(e) {
  return ee(gf(e));
}
function _f(e) {
  return yr(e) ? e : la(e) ? bf(e) : rr(e);
}
var TE = {};
ut(TE, {
  decodeShortString: () => Ef,
  encodeShortString: () => en,
  isASCII: () => yf,
  isDecimalString: () => ab,
  isLongText: () => wf,
  isShortString: () => gi,
  isShortText: () => OE,
  isText: () => _i,
  splitLongString: () => mf
});
var nb = 31;
function yf(e) {
  return /^[\x00-\x7F]*$/.test(e);
}
function gi(e) {
  return e.length <= nb;
}
function ab(e) {
  return /^[0-9]*$/i.test(e);
}
function _i(e) {
  return typeof e == "string" && !yr(e) && !la(e);
}
var OE = (e) => _i(e) && gi(e), wf = (e) => _i(e) && !gi(e);
function mf(e) {
  const t = RegExp(`[^]{1,${nb}}`, "g");
  return e.match(t) || [];
}
function en(e) {
  if (!yf(e))
    throw new Error(`${e} is not an ASCII string`);
  if (!gi(e))
    throw new Error(`${e} is too long`);
  return kt(e.replace(/./g, (t) => t.charCodeAt(0).toString(16)));
}
function Ef(e) {
  if (!yf(e))
    throw new Error(`${e} is not an ASCII string`);
  if (yr(e))
    return da(e).replace(/.{2}/g, (t) => String.fromCharCode(parseInt(t, 16)));
  if (ab(e))
    return Ef("0X".concat(BigInt(e).toString(16)));
  throw new Error(`${e} is not Hex or decimal`);
}
var NE = {};
ut(NE, {
  felt: () => Zt,
  getArrayType: () => yi,
  isCairo1Abi: () => ob,
  isCairo1Type: () => Yr,
  isLen: () => Dn,
  isTypeArray: () => Tr,
  isTypeBool: () => $s,
  isTypeContractAddress: () => cb,
  isTypeFelt: () => as,
  isTypeNamedTuple: () => sb,
  isTypeStruct: () => Qn,
  isTypeTuple: () => pr,
  isTypeUint: () => Sf,
  isTypeUint256: () => Or,
  tuple: () => PE,
  uint256: () => Df
});
var RE = {};
ut(RE, {
  UINT_128_MAX: () => vf,
  UINT_256_MAX: () => ib,
  bnToUint256: () => LE,
  isUint256: () => xf,
  uint256ToBN: () => Fs
});
function Fs(e) {
  return (ne(e.high) << 128n) + ne(e.low);
}
var vf = (1n << 128n) - 1n, ib = (1n << 256n) - 1n;
function xf(e) {
  return ne(e) <= ib;
}
function LE(e) {
  const t = ne(e);
  if (!xf(t))
    throw new Error("Number is too large");
  return {
    low: kt((t & vf).toString(16)),
    high: kt((t >> 128n).toString(16))
  };
}
var Dn = (e) => /_len$/.test(e), as = (e) => e === "felt" || e === "core::felt252", Tr = (e) => /\*/.test(e) || e.startsWith("core::array::Array::"), pr = (e) => /^\(.*\)$/i.test(e), sb = (e) => /\(.*\)/i.test(e) && e.includes(":"), Qn = (e, t) => e in t, Sf = (e) => Object.values(uf).includes(e), Or = (e) => e === "core::integer::u256", $s = (e) => e === "core::bool", cb = (e) => e === "core::starknet::contract_address::ContractAddress", Yr = (e) => e.includes("core::"), yi = (e) => Yr(e) ? e.substring(e.indexOf("<") + 1, e.lastIndexOf(">")) : e.replace("*", "");
function ob(e) {
  const t = e.find((r) => r.type === "function");
  if (!t) {
    if (e.find((r) => r.type === "interface"))
      return !0;
    throw new Error("Error in ABI. No function in ABI.");
  }
  if (t.inputs.length)
    return Yr(t.inputs[0].type);
  if (t.outputs.length)
    return Yr(t.outputs[0].type);
  throw new Error(`Error in ABI. No input/output in function ${t.name}`);
}
var Df = (e) => {
  const t = BigInt(e);
  if (!xf(t))
    throw new Error("Number is too large");
  return {
    // eslint-disable-next-line no-bitwise
    low: (t & vf).toString(10),
    // eslint-disable-next-line no-bitwise
    high: (t >> 128n).toString(10)
  };
}, PE = (...e) => ({ ...e });
function Zt(e) {
  if (Us(e) || typeof e == "number" && Number.isInteger(e))
    return e.toString();
  if (_i(e)) {
    if (!gi(e))
      throw new Error(
        `${e} is a long string > 31 chars, felt can store short strings, split it to array of short strings`
      );
    const t = en(e);
    return BigInt(t).toString();
  }
  if (typeof e == "string" && yr(e))
    return BigInt(e).toString();
  if (typeof e == "string" && la(e))
    return e;
  if (typeof e == "boolean")
    return `${+e}`;
  throw new Error(`${e} can't be computed by felt()`);
}
var Sc = {
  isBN: (e, t, r) => {
    if (!Us(e[r]))
      throw new Error(
        `Data and formatter mismatch on ${r}:${t[r]}, expected response data ${r}:${e[r]} to be BN instead it is ${typeof e[r]}`
      );
  },
  unknown: (e, t, r) => {
    throw new Error(`Unhandled formatter type on ${r}:${t[r]} for data ${r}:${e[r]}`);
  }
};
function Vi(e, t, r) {
  return Object.entries(e).reduce((n, [a, i]) => {
    const c = r ?? t[a];
    if (!(a in t) && !r)
      return n[a] = i, n;
    if (c === "string") {
      if (Array.isArray(e[a])) {
        const s = Vi(
          e[a],
          e[a].map((d) => c)
        );
        return n[a] = Object.values(s).join(""), n;
      }
      return Sc.isBN(e, t, a), n[a] = Ef(i), n;
    }
    if (c === "number")
      return Sc.isBN(e, t, a), n[a] = Number(i), n;
    if (typeof c == "function")
      return n[a] = c(i), n;
    if (Array.isArray(c)) {
      const s = Vi(e[a], c, c[0]);
      return n[a] = Object.values(s), n;
    }
    return typeof c == "object" ? (n[a] = Vi(e[a], c), n) : (Sc.unknown(e, t, a), n);
  }, {});
}
var kE = class {
  constructor(e) {
    this.abi = e;
  }
  /**
   * abi method inputs length without '_len' inputs
   * cairo 0 reducer
   * @param abiMethod FunctionAbi
   * @returns number
   */
  methodInputsLength(e) {
    return e.inputs.reduce((t, r) => Dn(r.name) ? t : t + 1, 0);
  }
  /**
   * get method definition from abi
   * @param name string
   * @returns FunctionAbi | undefined
   */
  getMethod(e) {
    return this.abi.find((t) => t.name === e);
  }
  /**
   * Get Abi in legacy format
   * @returns Abi
   */
  getLegacyFormat() {
    return this.abi;
  }
}, UE = class {
  constructor(e) {
    this.abi = e;
  }
  /**
   * abi method inputs length
   * @param abiMethod FunctionAbi
   * @returns number
   */
  methodInputsLength(e) {
    return e.inputs.length;
  }
  /**
   * get method definition from abi
   * @param name string
   * @returns FunctionAbi | undefined
   */
  getMethod(e) {
    return this.abi.find((r) => r.type === "interface").items.find((r) => r.name === e);
  }
  /**
   * Get Abi in legacy format
   * @returns Abi
   */
  getLegacyFormat() {
    return this.abi.flatMap((e) => e.type === "interface" ? e.items : e);
  }
};
function FE(e) {
  const t = $E(e);
  if (t === 0 || t === 1)
    return new kE(e);
  if (t === 2)
    return new UE(e);
  throw Error(`Unsupported ABI version ${t}`);
}
function $E(e) {
  return e.find((t) => t.type === "interface") ? 2 : ob(e) ? 1 : 0;
}
function _l(e, t, r) {
  return e === "constructor" && !r && !t.length;
}
function BE(e) {
  const t = e.substring(0, e.indexOf(":")), r = e.substring(t.length + 1);
  return { name: t, type: r };
}
function fb(e) {
  if (!e.includes("("))
    return { subTuple: [], result: e };
  const t = [];
  let r = "", n = 0;
  for (; n < e.length; ) {
    if (e[n] === "(") {
      let a = 1;
      const i = n;
      for (n++; a; )
        e[n] === ")" && a--, e[n] === "(" && a++, n++;
      t.push(e.substring(i, n)), r += " ", n--;
    } else
      r += e[n];
    n++;
  }
  return {
    subTuple: t,
    result: r
  };
}
function ME(e) {
  const t = e.replace(/\s/g, "").slice(1, -1), { subTuple: r, result: n } = fb(t);
  let a = n.split(",").map((i) => r.length ? i.replace(" ", r.shift()) : i);
  return sb(e) && (a = a.reduce((i, c) => i.concat(BE(c)), [])), a;
}
function HE(e) {
  const t = e.replace(/\s/g, "").slice(1, -1), { subTuple: r, result: n } = fb(t);
  return n.split(",").map((i) => r.length ? i.replace(" ", r.shift()) : i);
}
function Af(e) {
  return Yr(e) ? HE(e) : ME(e);
}
function Dc(e) {
  return Error(
    `Your object includes the property : ${e}, containing an Uint256 object without the 'low' and 'high' keys.`
  );
}
function zE(e, t, r) {
  const n = (c, s) => s.reduce((f, l) => {
    const p = (w) => Object.defineProperty(f, l.name, {
      enumerable: !0,
      value: w ?? c[l.name]
    });
    if (c[l.name] === "undefined" && (Yr(l.type) || !Dn(l.name)))
      throw Error(`Your object needs a property with key : ${l.name} .`);
    switch (!0) {
      case Qn(l.type, r):
        p(
          n(
            c[l.name],
            r[l.type].members
          )
        );
        break;
      case Or(l.type): {
        const w = c[l.name];
        if (typeof w != "object") {
          p();
          break;
        }
        if (!("low" in w && "high" in w))
          throw Dc(l.name);
        p({ low: w.low, high: w.high });
        break;
      }
      case pr(l.type):
        p(i(c[l.name], l));
        break;
      case Tr(l.type):
        p(a(c[l.name], l));
        break;
      case (!Yr(l.type) && Dn(l.name)):
        break;
      default:
        p();
    }
    return f;
  }, {});
  function a(c, s) {
    const d = yi(s.type);
    if (typeof c == "string")
      return c;
    switch (!0) {
      case d in r:
        return c.map((f) => n(f, r[d].members));
      case d === "core::integer::u256":
        return c.map((f) => {
          if (typeof f != "object")
            return f;
          if (!("low" in f && "high" in f))
            throw Dc(s.name);
          return { low: f.low, high: f.high };
        });
      case pr(d):
        return c.map((f) => i(f, { name: "0", type: d }));
      case Tr(d):
        return c.map((f) => a(f, { name: "0", type: d }));
      default:
        return c;
    }
  }
  function i(c, s) {
    return Af(s.type).reduce((l, p, w) => {
      const g = Object.keys(c), m = (I) => Object.defineProperty(l, w.toString(), {
        enumerable: !0,
        value: I ?? c[g[w]]
      }), S = p?.type ? p.type : p;
      switch (!0) {
        case Qn(S, r):
          m(
            n(
              c[g[w]],
              r[S].members
            )
          );
          break;
        case Or(S): {
          const I = c[g[w]];
          if (typeof I != "object") {
            m();
            break;
          }
          if (!("low" in I && "high" in I))
            throw Dc(s.name);
          m({ low: I.low, high: I.high });
          break;
        }
        case pr(S):
          m(
            i(c[g[w]], {
              name: "0",
              type: S
            })
          );
          break;
        case Tr(S):
          m(
            a(c[g[w]], {
              name: "0",
              type: S
            })
          );
          break;
        default:
          m();
      }
      return l;
    }, {});
  }
  return n(e, t);
}
function db(e, t) {
  switch (!0) {
    case Or(e):
      const r = Df(t);
      return [Zt(r.low), Zt(r.high)];
    default:
      return Zt(t);
  }
}
function jE(e, t) {
  const r = Af(t), n = Object.values(e);
  if (n.length !== r.length)
    throw Error(
      `ParseTuple: provided and expected abi tuple size do not match.
      provided: ${n} 
      expected: ${r}`
    );
  return r.map((a, i) => ({
    element: n[i],
    type: a.type ?? a
  }));
}
function yl(e) {
  if (typeof e == "object") {
    const { low: r, high: n } = e;
    return [Zt(r), Zt(n)];
  }
  const t = Df(e);
  return [Zt(t.low), Zt(t.high)];
}
function $a(e, t, r) {
  if (e === void 0)
    throw Error(`Missing parameter for type ${t}`);
  if (Array.isArray(e)) {
    const n = [];
    n.push(Zt(e.length));
    const a = yi(t);
    return e.reduce((i, c) => i.concat($a(c, a, r)), n);
  }
  if (r[t] && r[t].members.length) {
    if (Or(t))
      return yl(e);
    const { members: n } = r[t], a = e;
    return n.reduce((i, c) => i.concat($a(a[c.name], c.type, r)), []);
  }
  if (pr(t))
    return jE(e, t).reduce((a, i) => {
      const c = $a(i.element, i.type, r);
      return a.concat(c);
    }, []);
  if (Or(t))
    return yl(e);
  if (typeof e == "object")
    throw Error(`Parameter ${e} do not align with abi parameter ${t}`);
  return db(t, e);
}
function VE(e, t, r) {
  const { name: n, type: a } = t;
  let { value: i } = e.next();
  switch (!0) {
    case Tr(a):
      if (!Array.isArray(i) && !_i(i))
        throw Error(`ABI expected parameter ${n} to be array or long string, got ${i}`);
      return typeof i == "string" && (i = mf(i)), $a(i, t.type, r);
    case (Qn(a, r) || pr(a) || Or(a)):
      return $a(i, a, r);
    default:
      return db(a, i);
  }
}
function lb(e, t) {
  let r;
  switch (!0) {
    case $s(e):
      return r = t.next().value, !!BigInt(r);
    case Or(e):
      const n = t.next().value, a = t.next().value;
      return Fs({ low: n, high: a });
    default:
      return r = t.next().value, BigInt(r);
  }
}
function Gn(e, t, r) {
  if (Or(t.type)) {
    const n = e.next().value, a = e.next().value;
    return Fs({ low: n, high: a });
  }
  if (t.type in r && r[t.type])
    return r[t.type].members.reduce((n, a) => (n[a.name] = Gn(e, a, r), n), {});
  if (pr(t.type))
    return Af(t.type).reduce((a, i, c) => {
      const s = i?.name ? i.name : c, d = i?.type ? i.type : i, f = { name: s, type: d };
      return a[s] = Gn(e, f, r), a;
    }, {});
  if (Tr(t.type)) {
    const n = [], a = { name: "", type: yi(t.type) }, i = BigInt(e.next().value);
    for (; n.length < i; )
      n.push(Gn(e, a, r));
    return n;
  }
  return lb(t.type, e);
}
function qE(e, t, r, n) {
  const { name: a, type: i } = t;
  let c;
  switch (!0) {
    case Dn(a):
      return c = e.next().value, BigInt(c);
    case (i in r || pr(i)):
      return Gn(e, t, r);
    case Tr(i):
      if (Yr(i))
        return Gn(e, t, r);
      const s = [];
      if (n && n[`${a}_len`]) {
        const d = n[`${a}_len`];
        for (; s.length < d; )
          s.push(
            Gn(
              e,
              { name: a, type: t.type.replace("*", "") },
              r
            )
          );
      }
      return s;
    default:
      return lb(i, e);
  }
}
var ub = (e, t) => {
  mt(
    typeof e == "string" || typeof e == "number" || typeof e == "bigint",
    `Validate: arg ${t.name} should be a felt typed as (String, Number or BigInt)`
  );
}, If = (e, t) => {
  typeof e == "number" && mt(
    e <= Number.MAX_SAFE_INTEGER,
    "Validation: Parameter is to large to be typed as Number use (BigInt or String)"
  ), mt(
    typeof e == "string" || typeof e == "number" || typeof e == "bigint" || typeof e == "object" && "low" in e && "high" in e,
    `Validate: arg ${t.name} of cairo ZORG type ${t.type} should be type (String, Number or BigInt)`
  );
  const r = typeof e == "object" ? Fs(e) : ne(e);
  switch (t.type) {
    case "core::integer::u8":
      mt(
        r >= 0n && r <= 255n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0 - 255]`
      );
      break;
    case "core::integer::u16":
      mt(
        r >= 0n && r <= 65535n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 65535]`
      );
      break;
    case "core::integer::u32":
      mt(
        r >= 0n && r <= 4294967295n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 4294967295]`
      );
      break;
    case "core::integer::u64":
      mt(
        r >= 0n && r <= 2n ** 64n - 1n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^64-1]`
      );
      break;
    case "core::integer::u128":
      mt(
        r >= 0n && r <= 2n ** 128n - 1n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^128-1]`
      );
      break;
    case "core::integer::u256":
      mt(
        r >= 0n && r <= 2n ** 256n - 1n,
        `Validate: arg ${t.name} is ${t.type} 0 - 2^256-1`
      );
      break;
  }
}, hb = (e, t) => {
  mt(
    typeof e == "boolean",
    `Validate: arg ${t.name} of cairo type ${t.type} should be type (Boolean)`
  );
}, bb = (e, t, r) => {
  if (t.type === "core::integer::u256") {
    If(e, t);
    return;
  }
  mt(
    typeof e == "object" && !Array.isArray(e),
    `Validate: arg ${t.name} is cairo type struct (${t.type}), and should be defined as js object (not array)`
  ), r[t.type].members.forEach(({ name: n }) => {
    mt(
      Object.keys(e).includes(n),
      `Validate: arg ${t.name} should have a property ${n}`
    );
  });
}, pb = (e, t) => {
  mt(
    typeof e == "object" && !Array.isArray(e),
    `Validate: arg ${t.name} should be a tuple (defined as object)`
  );
}, gb = (e, t, r) => {
  const n = yi(t.type);
  if (!(as(n) && wf(e)))
    switch (mt(Array.isArray(e), `Validate: arg ${t.name} should be an Array`), !0) {
      case as(n):
        e.forEach((a) => ub(a, t));
        break;
      case pr(n):
        e.forEach((a) => pb(a, { name: t.name, type: n }));
        break;
      case Qn(n, r):
        e.forEach(
          (a) => bb(a, { name: t.name, type: n }, r)
        );
        break;
      case Sf(n):
        e.forEach((a) => If(a, t));
        break;
      case $s(n):
        e.forEach((a) => hb(a, t));
        break;
      case Tr(n):
        e.forEach(
          (a) => gb(a, { name: "", type: n }, r)
        );
        break;
      default:
        throw new Error(
          `Validate Unhandled: argument ${t.name}, type ${t.type}, value ${e}`
        );
    }
};
function wl(e, t, r) {
  e.inputs.reduce((n, a) => {
    const i = t[n];
    switch (!0) {
      case Dn(a.name):
        return n;
      case as(a.type):
        ub(i, a);
        break;
      case Sf(a.type):
        If(i, a);
        break;
      case $s(a.type):
        hb(i, a);
        break;
      case cb(a.type):
        break;
      case Qn(a.type, r):
        bb(i, a, r);
        break;
      case pr(a.type):
        pb(i, a);
        break;
      case Tr(a.type):
        gb(i, a, r);
        break;
      default:
        throw new Error(
          `Validate Unhandled: argument ${a.name}, type ${a.type}, value ${i}`
        );
    }
    return n + 1;
  }, 0);
}
var Ne = class {
  constructor(e) {
    this.structs = Ne.getAbiStruct(e), this.parser = FE(e), this.abi = this.parser.getLegacyFormat();
  }
  /**
   * Validate arguments passed to the method as corresponding to the ones in the abi
   * @param type ValidateType - type of the method
   * @param method string - name of the method
   * @param args ArgsOrCalldata - arguments that are passed to the method
   */
  validate(e, t, r = []) {
    if (e !== "DEPLOY") {
      const i = this.abi.filter((c) => {
        if (c.type !== "function")
          return !1;
        const s = c.stateMutability === "view" || c.state_mutability === "view";
        return e === "INVOKE" ? !s : s;
      }).map((c) => c.name);
      mt(
        i.includes(t),
        `${e === "INVOKE" ? "invocable" : "viewable"} method not found in abi`
      );
    }
    const n = this.abi.find(
      (i) => e === "DEPLOY" ? i.name === t && i.type === "constructor" : i.name === t && i.type === "function"
    );
    if (_l(t, r, n))
      return;
    const a = this.parser.methodInputsLength(n);
    if (r.length !== a)
      throw Error(
        `Invalid number of arguments, expected ${a} arguments, but got ${r.length}`
      );
    wl(n, r, this.structs);
  }
  /**
   * Compile contract callData with abi
   * Parse the calldata by using input fields from the abi for that method
   * @param method string - method name
   * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).
   * @return Calldata - parsed arguments in format that contract is expecting
   * @example
   * ```typescript
   * const calldata = myCallData.compile("constructor",["0x34a",[1,3n]]);
   * ```
   * ```typescript
   * const calldata2 = myCallData.compile("constructor",{list:[1,3n],balance:"0x34"}); // wrong order is valid
   * ```
   */
  compile(e, t) {
    const r = this.abi.find((c) => c.name === e);
    if (_l(e, t, r))
      return [];
    let n;
    if (Array.isArray(t))
      n = t;
    else {
      const c = zE(t, r.inputs, this.structs);
      n = Object.values(c), wl(r, n, this.structs);
    }
    const a = n[Symbol.iterator](), i = r.inputs.reduce(
      (c, s) => Dn(s.name) ? c : c.concat(VE(a, s, this.structs)),
      []
    );
    return Object.defineProperty(i, "__compiled__", {
      enumerable: !1,
      writable: !1,
      value: !0
    }), i;
  }
  /**
   * Compile contract callData without abi
   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data
   * @returns Calldata
   */
  static compile(e) {
    const t = (n) => {
      const a = (i, c = "") => {
        const s = Array.isArray(i) ? [i.length.toString(), ...i] : i;
        return Object.entries(s).flatMap(([d, f]) => {
          let l = f;
          wf(l) && (l = mf(l)), d === "entrypoint" && (l = rr(l));
          const p = Array.isArray(s) && d === "0" ? "$$len" : d;
          return Us(l) ? [[`${c}${p}`, Zt(l)]] : Object(l) === l ? a(l, `${c}${p}.`) : [[`${c}${p}`, Zt(l)]];
        });
      };
      return Object.fromEntries(a(n));
    };
    let r;
    if (Array.isArray(e)) {
      const n = { ...e }, a = t(n);
      r = Object.values(a);
    } else {
      const n = t(e);
      r = Object.values(n);
    }
    return Object.defineProperty(r, "__compiled__", {
      enumerable: !1,
      writable: !1,
      value: !0
    }), r;
  }
  /**
   * Parse elements of the response array and structuring them into response object
   * @param method string - method name
   * @param response string[] - response from the method
   * @return Result - parsed response corresponding to the abi
   */
  parse(e, t) {
    const { outputs: r } = this.abi.find((i) => i.name === e), n = t.flat()[Symbol.iterator](), a = r.flat().reduce((i, c, s) => {
      const d = c.name ?? s;
      return i[d] = qE(n, c, this.structs, i), i[d] && i[`${d}_len`] && delete i[`${d}_len`], i;
    }, {});
    return Object.keys(a).length === 1 && 0 in a ? a[0] : a;
  }
  /**
   * Format cairo method response data to native js values based on provided format schema
   * @param method string - cairo method name
   * @param response string[] - cairo method response
   * @param format object - formatter object schema
   * @returns Result - parsed and formatted response object
   */
  format(e, t, r) {
    const n = this.parse(e, t);
    return Vi(n, r);
  }
  /**
   * Helper to extract structs from abi
   * @param abi Abi
   * @returns AbiStructs - structs from abi
   */
  static getAbiStruct(e) {
    return e.filter((t) => t.type === "struct").reduce(
      (t, r) => ({
        ...t,
        [r.name]: r
      }),
      {}
    );
  }
  /**
   * Helper: Compile HexCalldata | RawCalldata | RawArgs
   * @param rawCalldata HexCalldata | RawCalldata | RawArgs
   * @returns Calldata
   */
  static toCalldata(e = []) {
    return Ne.compile(e);
  }
  /**
   * Helper: Convert raw to HexCalldata
   * @param raw HexCalldata | RawCalldata | RawArgs
   * @returns HexCalldata
   */
  static toHex(e = []) {
    return Ne.compile(e).map((r) => ee(r));
  }
}, KE = {};
ut(KE, {
  calculateContractAddressFromHash: () => qi,
  calculateDeclareTransactionHash: () => yb,
  calculateDeployAccountTransactionHash: () => wb,
  calculateDeployTransactionHash: () => XE,
  calculateTransactionHash: () => mb,
  calculateTransactionHashCommon: () => wi,
  computeCompiledClassHash: () => xb,
  computeContractClassHash: () => Db,
  computeHashOnElements: () => Dt,
  computeLegacyContractClassHash: () => vb,
  computeSierraContractClassHash: () => Sb,
  default: () => Eb,
  feeTransactionVersion: () => Hn,
  feeTransactionVersion_2: () => is,
  formatSpaces: () => Xa,
  getSelector: () => _f,
  getSelectorFromName: () => rr,
  getVersionsByType: () => Cf,
  keccakBn: () => rb,
  poseidon: () => Pg,
  starknetKeccak: () => gf,
  transactionVersion: () => zr,
  transactionVersion_2: () => ea
});
var GE = {};
ut(GE, {
  starkCurve: () => y_,
  weierstrass: () => zg
});
var WE = {};
ut(WE, {
  parse: () => Xr,
  parseAlwaysAsBig: () => _b,
  stringify: () => Nr,
  stringifyAlwaysAsBig: () => YE
});
var ZE = (e) => {
  if (!di(e))
    return parseFloat(e);
  const t = parseInt(e, 10);
  return Number.isSafeInteger(t) ? t : BigInt(e);
}, Xr = (e) => Ph(String(e), void 0, ZE), _b = (e) => Ph(String(e), void 0, P_), Nr = (e, t, r, n) => kh(e, t, r, n), YE = Nr, zr = 1n, ea = 2n, Hn = 2n ** 128n + zr, is = 2n ** 128n + ea;
function Cf(e) {
  return e === "fee" ? { v1: Hn, v2: is } : { v1: zr, v2: ea };
}
function Dt(e) {
  return [...e, e.length].reduce((t, r) => ia(ne(t), ne(r)), 0).toString();
}
function wi(e, t, r, n, a, i, c, s = []) {
  const d = Dt(a), f = [
    e,
    t,
    r,
    n,
    d,
    i,
    c,
    ...s
  ];
  return Dt(f);
}
function XE(e, t, r, n, a = "constructor") {
  return wi(
    "0x6465706c6f79",
    r,
    e,
    rr(a),
    t,
    0,
    n
  );
}
function yb(e, t, r, n, a, i, c) {
  return wi(
    "0x6465636c617265",
    r,
    t,
    0,
    [e],
    n,
    a,
    [i, ...c ? [c] : []]
  );
}
function wb(e, t, r, n, a, i, c, s) {
  const d = [t, n, ...r];
  return wi(
    "0x6465706c6f795f6163636f756e74",
    a,
    e,
    0,
    d,
    i,
    c,
    [s]
  );
}
function mb(e, t, r, n, a, i) {
  return wi(
    "0x696e766f6b65",
    t,
    e,
    0,
    r,
    n,
    a,
    [i]
  );
}
function qi(e, t, r, n) {
  const a = Ne.compile(r), i = Dt(a), c = Zt("0x535441524b4e45545f434f4e54524143545f41444452455353");
  return Dt([
    c,
    n,
    e,
    t,
    i
  ]);
}
function JE(e, t) {
  return e === "attributes" || e === "accessible_scopes" ? Array.isArray(t) && t.length === 0 ? void 0 : t : e === "debug_info" ? null : t === null ? void 0 : t;
}
function Xa(e) {
  let t = !1;
  const r = [];
  for (const n of e)
    n === '"' && !(r.length > 0 && r.slice(-1)[0] === "\\") && (t = !t), t ? r.push(n) : r.push(n === ":" ? ": " : n === "," ? ", " : n);
  return r.join("");
}
function Eb(e) {
  const { abi: t, program: r } = e, a = Xa(Nr({ abi: t, program: r }, JE));
  return kt(oi(ks(a)).toString(16));
}
function vb(e) {
  const t = typeof e == "string" ? Xr(e) : e, r = ee(R1), n = Dt(
    t.entry_points_by_type.EXTERNAL.flatMap((f) => [f.selector, f.offset])
  ), a = Dt(
    t.entry_points_by_type.L1_HANDLER.flatMap((f) => [f.selector, f.offset])
  ), i = Dt(
    t.entry_points_by_type.CONSTRUCTOR.flatMap((f) => [f.selector, f.offset])
  ), c = Dt(
    t.program.builtins.map((f) => en(f))
  ), s = Eb(t), d = Dt(t.program.data);
  return Dt([
    r,
    n,
    a,
    i,
    c,
    s,
    d
  ]);
}
function QE(e) {
  return Zr(
    e.flatMap((t) => BigInt(en(t)))
  );
}
function Ac(e) {
  const t = e.flatMap((r) => [BigInt(r.selector), BigInt(r.offset), QE(r.builtins)]);
  return Zr(t);
}
function xb(e) {
  const r = BigInt(en("COMPILED_CLASS_V1")), n = Ac(e.entry_points_by_type.EXTERNAL), a = Ac(e.entry_points_by_type.L1_HANDLER), i = Ac(e.entry_points_by_type.CONSTRUCTOR), c = Zr(e.bytecode.map((s) => BigInt(s)));
  return ee(
    Zr([
      r,
      n,
      a,
      i,
      c
    ])
  );
}
function Ic(e) {
  const t = e.flatMap((r) => [BigInt(r.selector), BigInt(r.function_idx)]);
  return Zr(t);
}
function ev(e) {
  const t = Xa(Nr(e.abi, null));
  return BigInt(kt(oi(ks(t)).toString(16)));
}
function Sb(e) {
  const r = BigInt(en("CONTRACT_CLASS_V0.1.0")), n = Ic(e.entry_points_by_type.EXTERNAL), a = Ic(e.entry_points_by_type.L1_HANDLER), i = Ic(e.entry_points_by_type.CONSTRUCTOR), c = ev(e), s = Zr(e.sierra_program.map((d) => BigInt(d)));
  return ee(
    Zr([
      r,
      n,
      a,
      i,
      c,
      s
    ])
  );
}
function Db(e) {
  const t = typeof e == "string" ? Xr(e) : e;
  return "sierra_program" in t ? Sb(t) : vb(t);
}
var tv = {};
ut(tv, {
  compressProgram: () => Tf,
  decompressProgram: () => go,
  estimatedFeeToMaxFee: () => wn,
  formatSignature: () => Bs,
  makeAddress: () => rv,
  randomAddress: () => Of,
  signatureToDecimalArray: () => Bn,
  signatureToHexArray: () => Mn
});
function Tf(e) {
  const t = typeof e == "string" ? e : Nr(e), r = Gm(t);
  return S1(r);
}
function go(e) {
  if (Array.isArray(e))
    return e;
  const t = lf(Wm(x1(e)));
  return Xr(t);
}
function Of() {
  const e = Go.randomPrivateKey();
  return Zo(e);
}
function rv(e) {
  return kt(e).toLowerCase();
}
function Bs(e) {
  if (!e)
    throw Error("formatSignature: provided signature is undefined");
  if (Array.isArray(e))
    return e.map((t) => ee(t));
  try {
    const { r: t, s: r } = e;
    return [ee(t), ee(r)];
  } catch {
    throw new Error("Signature need to be weierstrass.SignatureType or an array for custom");
  }
}
function Bn(e) {
  return X1(Bs(e));
}
function Mn(e) {
  return J1(Bs(e));
}
function wn(e, t = 0.5) {
  const r = Math.round((1 + t) * 100);
  return ne(e) * ne(r) / 100n;
}
function gr(e) {
  return "sierra_program" in (typeof e == "string" ? Xr(e) : e);
}
function Cc(e) {
  const t = { ...e };
  if (gr(e.contract) && (!e.compiledClassHash && e.casm && (t.compiledClassHash = xb(e.casm)), !t.compiledClassHash))
    throw new Error(
      "Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash"
    );
  if (t.classHash = e.classHash ?? Db(e.contract), !t.classHash)
    throw new Error("Extract classHash failed, provide (CompiledContract).json file or classHash");
  return t;
}
var Ab = typeof window < "u" && window.fetch || // use buildin fetch in browser if available
typeof global < "u" && global.fetch || // use buildin fetch in node, react-native and service worker if available
cE, nv = {};
ut(nv, {
  createSierraContractClass: () => Ib,
  parseContract: () => Nf,
  wait: () => ss
});
function ss(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function Ib(e) {
  const t = { ...e };
  return delete t.sierra_program_debug_info, t.abi = Xa(Nr(e.abi)), t.sierra_program = Xa(Nr(e.sierra_program)), t.sierra_program = Tf(t.sierra_program), t;
}
function Nf(e) {
  const t = typeof e == "string" ? Xr(e) : e;
  return gr(e) ? Ib(t) : {
    ...t,
    ..."program" in t && { program: Tf(t.program) }
  };
}
var av = class {
  parseGetBlockResponse(e) {
    return {
      timestamp: e.timestamp,
      block_hash: e.block_hash,
      block_number: e.block_number,
      new_root: e.new_root,
      parent_hash: e.parent_hash,
      status: e.status,
      transactions: e.transactions
    };
  }
  parseGetTransactionResponse(e) {
    return {
      calldata: e.calldata || [],
      contract_address: e.contract_address,
      sender_address: e.contract_address,
      max_fee: e.max_fee,
      nonce: e.nonce,
      signature: e.signature || [],
      transaction_hash: e.transaction_hash,
      version: e.version
    };
  }
  parseFeeEstimateResponse(e) {
    return {
      overall_fee: ne(e[0].overall_fee),
      gas_consumed: ne(e[0].gas_consumed),
      gas_price: ne(e[0].gas_price)
    };
  }
  parseFeeEstimateBulkResponse(e) {
    return e.map((t) => ({
      overall_fee: ne(t.overall_fee),
      gas_consumed: ne(t.gas_consumed),
      gas_price: ne(t.gas_price)
    }));
  }
  parseCallContractResponse(e) {
    return {
      result: e
    };
  }
  parseSimulateTransactionResponse(e) {
    return e.map((t) => ({
      ...t,
      suggestedMaxFee: wn(BigInt(t.fee_estimation.overall_fee))
    }));
  }
  parseContractClassResponse(e) {
    return {
      ...e,
      abi: typeof e.abi == "string" ? JSON.parse(e.abi) : e.abi
    };
  }
};
function iv(e, t = e.constructor) {
  const { captureStackTrace: r } = Error;
  r && r(e, t);
}
function sv(e, t) {
  const { setPrototypeOf: r } = Object;
  r ? r(e, t) : e.__proto__ = t;
}
var cv = class extends Error {
  constructor(e) {
    super(e), Object.defineProperty(this, "name", {
      value: new.target.name,
      enumerable: !1,
      configurable: !0
    }), sv(this, new.target.prototype), iv(this);
  }
}, ta = class extends cv {
}, ov = class extends ta {
  constructor(e, t) {
    super(e), this.errorCode = t;
  }
}, fv = class extends ta {
  constructor(e, t) {
    super(e), this.errorCode = t;
  }
}, dv = {};
ut(dv, {
  StarknetIdContract: () => Ob,
  getStarknetIdContract: () => Rf,
  useDecoded: () => Cb,
  useEncoded: () => Tb
});
var ur = "abcdefghijklmnopqrstuvwxyz0123456789-", zn = BigInt(ur.length + 1), dt = "", ml = BigInt(ur.length), _o = BigInt(dt.length), El = BigInt(dt.length + 1);
function yo(e) {
  let t = 0;
  for (; e.endsWith(dt[dt.length - 1]); )
    e = e.substring(0, e.length - 1), t += 1;
  return [e, t];
}
function Cb(e) {
  let t = "";
  return e.forEach((r) => {
    for (; r !== Mt; ) {
      const i = r % zn;
      if (r /= zn, i === BigInt(ur.length)) {
        const c = r / El;
        if (c === Mt) {
          const s = r % El;
          r = c, s === Mt ? t += ur[0] : t += dt[Number(s) - 1];
        } else {
          const s = r % _o;
          t += dt[Number(s)], r /= _o;
        }
      } else
        t += ur[Number(i)];
    }
    const [n, a] = yo(t);
    a && (t = n + (a % 2 === 0 ? dt[dt.length - 1].repeat(a / 2 - 1) + dt[0] + ur[1] : dt[dt.length - 1].repeat((a - 1) / 2 + 1))), t += ".";
  }), t && t.concat("stark");
}
function Tb(e) {
  let t = BigInt(0), r = BigInt(1);
  if (e.endsWith(dt[0] + ur[1])) {
    const [n, a] = yo(e.substring(0, e.length - 2));
    e = n + dt[dt.length - 1].repeat(2 * (a + 1));
  } else {
    const [n, a] = yo(e);
    a && (e = n + dt[dt.length - 1].repeat(1 + 2 * (a - 1)));
  }
  for (let n = 0; n < e.length; n += 1) {
    const a = e[n], i = ur.indexOf(a), c = BigInt(ur.indexOf(a));
    if (i !== -1)
      n === e.length - 1 && e[n] === ur[0] ? (t += r * ml, r *= zn, r *= zn) : (t += r * c, r *= zn);
    else if (dt.indexOf(a) !== -1) {
      t += r * ml, r *= zn;
      const s = (n === e.length - 1 ? 1 : 0) + dt.indexOf(a);
      t += r * BigInt(s), r *= _o;
    }
  }
  return t;
}
var Ob = /* @__PURE__ */ ((e) => (e.MAINNET = "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678", e.TESTNET = "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce", e))(Ob || {});
function Rf(e) {
  switch (e) {
    case "0x534e5f4d41494e":
      return "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
    case "0x534e5f474f45524c49":
      return "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce";
    default:
      throw new Error("Starknet.id is not yet deployed on this network");
  }
}
async function Lf(e, t, r) {
  const n = await e.getChainId(), a = r ?? Rf(n);
  try {
    const c = (await e.callContract({
      contractAddress: a,
      entrypoint: "address_to_domain",
      calldata: Ne.compile({
        address: t
      })
    })).result.map((d) => BigInt(d)).slice(1), s = Cb(c);
    if (!s)
      throw Error("Starkname not found");
    return s;
  } catch (i) {
    throw i instanceof Error && i.message === "Starkname not found" ? i : Error("Could not get stark name");
  }
}
async function Pf(e, t, r) {
  const n = await e.getChainId(), a = r ?? Rf(n);
  try {
    return (await e.callContract({
      contractAddress: a,
      entrypoint: "domain_to_address",
      calldata: Ne.compile({
        domain: [Tb(t.replace(".stark", "")).toString(10)]
      })
    })).result[0];
  } catch {
    throw Error("Could not get address from stark name");
  }
}
var lv = Object.values(hf), Je = class {
  constructor(e) {
    this.hash = null, this.number = null, this.tag = null, this.valueOf = () => this.number, this.toString = () => this.hash, this.setIdentifier(e);
  }
  setIdentifier(e) {
    typeof e == "string" && yr(e) ? this.hash = e : typeof e == "bigint" ? this.hash = ee(e) : typeof e == "number" ? this.number = e : typeof e == "string" && lv.includes(e) ? this.tag = e : this.tag = "pending";
  }
  // TODO: fix any
  get queryIdentifier() {
    return this.number !== null ? `blockNumber=${this.number}` : this.hash !== null ? `blockHash=${this.hash}` : `blockNumber=${this.tag}`;
  }
  // TODO: fix any
  get identifier() {
    return this.number !== null ? { block_number: this.number } : this.hash !== null ? { block_hash: this.hash } : this.tag;
  }
  set identifier(e) {
    this.setIdentifier(e);
  }
  get sequencerIdentifier() {
    return this.hash !== null ? { blockHash: this.hash } : { blockNumber: this.number ?? this.tag };
  }
}, Tc = {
  headers: { "Content-Type": "application/json" },
  blockIdentifier: "pending",
  retries: 200
}, vl = class {
  constructor(e) {
    this.responseParser = new av();
    const { nodeUrl: t, retries: r, headers: n, blockIdentifier: a, chainId: i } = e;
    this.nodeUrl = t, this.retries = r || Tc.retries, this.headers = { ...Tc.headers, ...n }, this.blockIdentifier = a || Tc.blockIdentifier, this.chainId = i, this.getChainId();
  }
  fetch(e, t) {
    const r = Nr({ method: e, jsonrpc: "2.0", params: t, id: 0 });
    return Ab(this.nodeUrl, {
      method: "POST",
      body: r,
      headers: this.headers
    });
  }
  errorHandler(e) {
    if (e) {
      const { code: t, message: r } = e;
      throw new ta(`${t}: ${r}`);
    }
  }
  async fetchEndpoint(e, t) {
    try {
      const r = await this.fetch(e, t), { error: n, result: a } = await r.json();
      return this.errorHandler(n), a;
    } catch (r) {
      throw this.errorHandler(r?.response?.data), r;
    }
  }
  // Methods from Interface
  async getChainId() {
    return this.chainId ?? (this.chainId = await this.fetchEndpoint("starknet_chainId")), this.chainId;
  }
  async getBlock(e = this.blockIdentifier) {
    return this.getBlockWithTxHashes(e).then(
      this.responseParser.parseGetBlockResponse
    );
  }
  async getBlockHashAndNumber() {
    return this.fetchEndpoint("starknet_blockHashAndNumber");
  }
  async getBlockWithTxHashes(e = this.blockIdentifier) {
    const t = new Je(e).identifier;
    return this.fetchEndpoint("starknet_getBlockWithTxHashes", { block_id: t });
  }
  async getBlockWithTxs(e = this.blockIdentifier) {
    const t = new Je(e).identifier;
    return this.fetchEndpoint("starknet_getBlockWithTxs", { block_id: t });
  }
  async getClassHashAt(e, t = this.blockIdentifier) {
    const r = new Je(t).identifier;
    return this.fetchEndpoint("starknet_getClassHashAt", {
      block_id: r,
      contract_address: e
    });
  }
  async getNonceForAddress(e, t = this.blockIdentifier) {
    const r = new Je(t).identifier;
    return this.fetchEndpoint("starknet_getNonce", {
      contract_address: e,
      block_id: r
    });
  }
  async getPendingTransactions() {
    return this.fetchEndpoint("starknet_pendingTransactions");
  }
  async getProtocolVersion() {
    throw new Error("Pathfinder does not implement this rpc 0.1.0 method");
  }
  async getStateUpdate(e = this.blockIdentifier) {
    const t = new Je(e).identifier;
    return this.fetchEndpoint("starknet_getStateUpdate", { block_id: t });
  }
  async getStorageAt(e, t, r = this.blockIdentifier) {
    const n = Z1(t), a = new Je(r).identifier;
    return this.fetchEndpoint("starknet_getStorageAt", {
      contract_address: e,
      key: n,
      block_id: a
    });
  }
  // Methods from Interface
  async getTransaction(e) {
    return this.getTransactionByHash(e).then(this.responseParser.parseGetTransactionResponse);
  }
  async getTransactionByHash(e) {
    return this.fetchEndpoint("starknet_getTransactionByHash", { transaction_hash: e });
  }
  async getTransactionByBlockIdAndIndex(e, t) {
    const r = new Je(e).identifier;
    return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex", { block_id: r, index: t });
  }
  async getTransactionReceipt(e) {
    return this.fetchEndpoint("starknet_getTransactionReceipt", { transaction_hash: e });
  }
  async getClassByHash(e) {
    return this.getClass(e);
  }
  async getClass(e, t = this.blockIdentifier) {
    const r = new Je(t).identifier;
    return this.fetchEndpoint("starknet_getClass", {
      class_hash: e,
      block_id: r
    }).then(this.responseParser.parseContractClassResponse);
  }
  async getClassAt(e, t = this.blockIdentifier) {
    const r = new Je(t).identifier;
    return this.fetchEndpoint("starknet_getClassAt", {
      block_id: r,
      contract_address: e
    }).then(this.responseParser.parseContractClassResponse);
  }
  async getCode(e, t) {
    throw new Error("RPC does not implement getCode function");
  }
  async getEstimateFee(e, t, r = this.blockIdentifier) {
    return this.getInvokeEstimateFee(e, t, r);
  }
  async getInvokeEstimateFee(e, t, r = this.blockIdentifier) {
    const n = new Je(r).identifier, a = this.buildTransaction(
      {
        type: "INVOKE_FUNCTION",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("starknet_estimateFee", {
      request: [a],
      block_id: n
    }).then(this.responseParser.parseFeeEstimateResponse);
  }
  async getDeclareEstimateFee(e, t, r = this.blockIdentifier) {
    const n = new Je(r).identifier, a = this.buildTransaction(
      {
        type: "DECLARE",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("starknet_estimateFee", {
      request: [a],
      block_id: n
    }).then(this.responseParser.parseFeeEstimateResponse);
  }
  async getDeployAccountEstimateFee(e, t, r = this.blockIdentifier) {
    const n = new Je(r).identifier, a = this.buildTransaction(
      {
        type: "DEPLOY_ACCOUNT",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("starknet_estimateFee", {
      request: [a],
      block_id: n
    }).then(this.responseParser.parseFeeEstimateResponse);
  }
  async getEstimateFeeBulk(e, { blockIdentifier: t = this.blockIdentifier, skipValidate: r = !1 }) {
    r && console.warn("getEstimateFeeBulk RPC does not support skipValidate");
    const n = new Je(t).identifier;
    return this.fetchEndpoint("starknet_estimateFee", {
      request: e.map((a) => this.buildTransaction(a, "fee")),
      block_id: n
    }).then(this.responseParser.parseFeeEstimateBulkResponse);
  }
  async declareContract({ contract: e, signature: t, senderAddress: r, compiledClassHash: n }, a) {
    return gr(e) ? this.fetchEndpoint("starknet_addDeclareTransaction", {
      declare_transaction: {
        type: hn.TransactionType.DECLARE,
        contract_class: {
          sierra_program: go(e.sierra_program),
          contract_class_version: e.contract_class_version,
          entry_points_by_type: e.entry_points_by_type,
          abi: e.abi
        },
        compiled_class_hash: n || "",
        version: O1,
        max_fee: ee(a.maxFee || 0),
        signature: Mn(t),
        sender_address: r,
        nonce: ee(a.nonce)
      }
    }) : this.fetchEndpoint("starknet_addDeclareTransaction", {
      declare_transaction: {
        type: hn.TransactionType.DECLARE,
        contract_class: {
          program: e.program,
          entry_points_by_type: e.entry_points_by_type,
          abi: e.abi
        },
        version: T1,
        max_fee: ee(a.maxFee || 0),
        signature: Mn(t),
        sender_address: r,
        nonce: ee(a.nonce)
      }
    });
  }
  async deployAccountContract({ classHash: e, constructorCalldata: t, addressSalt: r, signature: n }, a) {
    return this.fetchEndpoint("starknet_addDeployAccountTransaction", {
      deploy_account_transaction: {
        constructor_calldata: Ne.toHex(t || []),
        class_hash: ee(e),
        contract_address_salt: ee(r || 0),
        type: hn.TransactionType.DEPLOY_ACCOUNT,
        max_fee: ee(a.maxFee || 0),
        version: ee(a.version || 0),
        signature: Mn(n),
        nonce: ee(a.nonce)
      }
    });
  }
  async invokeFunction(e, t) {
    return this.fetchEndpoint("starknet_addInvokeTransaction", {
      invoke_transaction: {
        sender_address: e.contractAddress,
        calldata: Ne.toHex(e.calldata),
        type: hn.TransactionType.INVOKE,
        max_fee: ee(t.maxFee || 0),
        version: "0x1",
        signature: Mn(e.signature),
        nonce: ee(t.nonce)
      }
    });
  }
  // Methods from Interface
  async callContract(e, t = this.blockIdentifier) {
    const r = new Je(t).identifier, n = await this.fetchEndpoint("starknet_call", {
      request: {
        contract_address: e.contractAddress,
        entry_point_selector: rr(e.entrypoint),
        calldata: Ne.toHex(e.calldata)
      },
      block_id: r
    });
    return this.responseParser.parseCallContractResponse(n);
  }
  async traceTransaction(e) {
    return this.fetchEndpoint("starknet_traceTransaction", { transaction_hash: e });
  }
  async traceBlockTransactions(e) {
    return this.fetchEndpoint("starknet_traceBlockTransactions", { block_hash: e });
  }
  async waitForTransaction(e, t) {
    let { retries: r } = this, n = !1, a = !1, i = {};
    const c = t?.retryInterval ?? 5e3, s = t?.errorStates ?? [ho.REVERTED], d = t?.successStates ?? [
      ho.SUCCEEDED,
      uo.ACCEPTED_ON_L1,
      uo.ACCEPTED_ON_L2
    ];
    for (; !n; ) {
      await ss(c);
      try {
        i = await this.getTransactionReceipt(e);
        const f = fo(i.execution_status), l = fo(i.finality_status);
        if (!f || !l)
          throw new Error("waiting for transaction status");
        if (d.includes(f) || d.includes(l))
          n = !0;
        else if (s.includes(f) || s.includes(l)) {
          const p = `${f}: ${l}: ${i.revert_reason}`, w = new Error(p);
          throw w.response = i, a = !0, w;
        }
      } catch (f) {
        if (f instanceof Error && a)
          throw f;
        if (r === 0)
          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
      }
      r -= 1;
    }
    return await ss(c), i;
  }
  /**
   * Gets the transaction count from a block.
   *
   *
   * @param blockIdentifier
   * @returns Number of transactions
   */
  async getTransactionCount(e = this.blockIdentifier) {
    const t = new Je(e).identifier;
    return this.fetchEndpoint("starknet_getBlockTransactionCount", { block_id: t });
  }
  /**
   * Gets the latest block number
   *
   *
   * @returns Number of the latest block
   */
  async getBlockNumber() {
    return this.fetchEndpoint("starknet_blockNumber");
  }
  /**
   * Gets syncing status of the node
   *
   *
   * @returns Object with the stats data
   */
  async getSyncingStats() {
    return this.fetchEndpoint("starknet_syncing");
  }
  /**
   * Gets all the events filtered
   *
   *
   * @returns events and the pagination of the events
   */
  async getEvents(e) {
    return this.fetchEndpoint("starknet_getEvents", { filter: e });
  }
  async getSimulateTransaction(e, {
    blockIdentifier: t = this.blockIdentifier,
    skipValidate: r = !1,
    skipExecute: n = !1,
    // @deprecated
    skipFeeCharge: a = !0
    // Pathfinder currently does not support `starknet_simulateTransactions` without `SKIP_FEE_CHARGE` simulation flag being set. This will become supported in a future release
  }) {
    const i = new Je(t).identifier, c = [];
    return r && c.push(lo.SKIP_VALIDATE), (n || a) && c.push(lo.SKIP_FEE_CHARGE), this.fetchEndpoint("starknet_simulateTransactions", {
      block_id: i,
      transactions: e.map((s) => this.buildTransaction(s)),
      simulation_flags: c
    }).then(this.responseParser.parseSimulateTransactionResponse);
  }
  async getStarkName(e, t) {
    return Lf(this, e, t);
  }
  async getAddressFromStarkName(e, t) {
    return Pf(this, e, t);
  }
  buildTransaction(e, t) {
    const r = Cf(t), n = {
      signature: Mn(e.signature),
      nonce: ee(e.nonce),
      max_fee: ee(e.maxFee || 0)
    };
    if (e.type === "INVOKE_FUNCTION")
      return {
        type: hn.TransactionType.INVOKE,
        // Diff between sequencer and rpc invoke type
        sender_address: e.contractAddress,
        calldata: Ne.toHex(e.calldata),
        version: ee(e.version || r.v1),
        // HEX_STR_TRANSACTION_VERSION_1, // as any HOTFIX TODO: Resolve spec version
        ...n
      };
    if (e.type === "DECLARE")
      return gr(e.contract) ? {
        // compiled_class_hash
        type: e.type,
        contract_class: {
          ...e.contract,
          sierra_program: go(e.contract.sierra_program)
        },
        compiled_class_hash: e.compiledClassHash || "",
        sender_address: e.senderAddress,
        version: ee(e.version || r.v2),
        // HEX_STR_TRANSACTION_VERSION_2, // as any HOTFIX TODO: Resolve spec version
        ...n
      } : {
        type: e.type,
        contract_class: e.contract,
        sender_address: e.senderAddress,
        version: ee(e.version || r.v1),
        // HEX_STR_TRANSACTION_VERSION_1, // as any HOTFIX TODO: Resolve spec version
        ...n
      };
    if (e.type === "DEPLOY_ACCOUNT")
      return {
        type: e.type,
        constructor_calldata: Ne.toHex(e.constructorCalldata || []),
        class_hash: ee(e.classHash),
        contract_address_salt: ee(e.addressSalt || 0),
        version: ee(e.version || r.v1),
        ...n
      };
    throw Error("RPC buildTransaction received unknown TransactionType");
  }
}, uv = class {
}, hv = class extends uv {
  parseGetBlockResponse(e) {
    return {
      ...e,
      new_root: e.state_root,
      parent_hash: e.parent_block_hash,
      transactions: Object.values(e.transactions).map((t) => "transaction_hash" in t && t.transaction_hash).filter(Boolean)
    };
  }
  parseGetTransactionResponse(e) {
    if (e.status === "NOT_RECEIVED" && e.finality_status === "NOT_RECEIVED")
      throw new ta();
    return {
      ...e,
      calldata: "calldata" in e.transaction ? e.transaction.calldata : [],
      contract_class: "contract_class" in e.transaction ? e.transaction.contract_class : void 0,
      entry_point_selector: "entry_point_selector" in e.transaction ? e.transaction.entry_point_selector : void 0,
      max_fee: "max_fee" in e.transaction ? e.transaction.max_fee : void 0,
      nonce: e.transaction.nonce,
      sender_address: "sender_address" in e.transaction ? e.transaction.sender_address : void 0,
      signature: "signature" in e.transaction ? e.transaction.signature : void 0,
      transaction_hash: "transaction_hash" in e.transaction ? e.transaction.transaction_hash : void 0,
      version: "version" in e.transaction ? e.transaction.version : void 0
    };
  }
  parseGetTransactionReceiptResponse(e) {
    return {
      ...e,
      messages_sent: e.l2_to_l1_messages,
      ..."revert_error" in e && { revert_reason: e.revert_error }
    };
  }
  parseFeeEstimateResponse(e) {
    if ("overall_fee" in e) {
      let t = {};
      try {
        t = {
          gas_consumed: ne(e.gas_usage),
          gas_price: ne(e.gas_price)
        };
      } catch {
      }
      return {
        overall_fee: ne(e.overall_fee),
        ...t
      };
    }
    return {
      overall_fee: ne(e.amount)
    };
  }
  parseFeeEstimateBulkResponse(e) {
    return [].concat(e).map((t) => {
      if ("overall_fee" in t) {
        let r = {};
        try {
          r = {
            gas_consumed: ne(t.gas_usage),
            gas_price: ne(t.gas_price)
          };
        } catch {
        }
        return {
          overall_fee: ne(t.overall_fee),
          ...r
        };
      }
      return {
        overall_fee: ne(t.amount)
      };
    });
  }
  parseSimulateTransactionResponse(e) {
    const t = "overall_fee" in e.fee_estimation ? e.fee_estimation.overall_fee : e.fee_estimation.amount;
    return [
      {
        transaction_trace: e.trace,
        fee_estimation: e.fee_estimation,
        suggestedMaxFee: wn(BigInt(t))
      }
    ];
  }
  parseCallContractResponse(e) {
    return {
      result: e.result
    };
  }
  parseInvokeFunctionResponse(e) {
    return {
      transaction_hash: e.transaction_hash
    };
  }
  parseDeployContractResponse(e) {
    return {
      transaction_hash: e.transaction_hash,
      contract_address: e.address
    };
  }
  parseDeclareContractResponse(e) {
    return {
      transaction_hash: e.transaction_hash,
      class_hash: e.class_hash
    };
  }
  parseGetStateUpdateResponse(e) {
    const t = Object.entries(e.state_diff.nonces).map(([n, a]) => ({
      contract_address: n,
      nonce: a
    })), r = Object.entries(e.state_diff.storage_diffs).map(
      ([n, a]) => ({ address: n, storage_entries: a })
    );
    return {
      ...e,
      state_diff: {
        ...e.state_diff,
        storage_diffs: r,
        nonces: t
      }
    };
  }
  parseContractClassResponse(e) {
    const t = gr(e) ? e : Nf(e);
    return {
      ...t,
      abi: typeof t.abi == "string" ? JSON.parse(t.abi) : t.abi
    };
  }
}, bv = /^(?:\w+:)?\/\/(\S+)$/, pv = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/, gv = /^[^\s.]+\.\S{2,}$/;
function _v(e) {
  if (!e || typeof e != "string")
    return !1;
  const t = e.match(bv);
  if (!t)
    return !1;
  const r = t[1];
  return r ? !!(pv.test(r) || gv.test(r)) : !1;
}
function Ca(e, t, r) {
  return _v(r) ? r : E1(e, r ?? t);
}
function yv(e) {
  return e === void 0 || Object.keys(e).length === 0 || Object.keys(e).length === 1 && Object.entries(e).every(([t, r]) => t === "blockIdentifier" && r === null);
}
var xl = {
  network: "SN_GOERLI2",
  blockIdentifier: "pending"
  /* pending */
}, Ba = class {
  constructor(e = xl) {
    this.responseParser = new hv(), "network" in e ? (this.baseUrl = Ba.getNetworkFromName(e.network), this.feederGatewayUrl = Ca(this.baseUrl, "feeder_gateway"), this.gatewayUrl = Ca(this.baseUrl, "gateway")) : (this.baseUrl = e.baseUrl, this.feederGatewayUrl = Ca(
      this.baseUrl,
      "feeder_gateway",
      e.feederGatewayUrl
    ), this.gatewayUrl = Ca(this.baseUrl, "gateway", e.gatewayUrl)), this.chainId = e?.chainId ?? Ba.getChainIdFromBaseUrl(this.baseUrl), this.headers = e.headers, this.blockIdentifier = e?.blockIdentifier || xl.blockIdentifier;
  }
  static getNetworkFromName(e) {
    switch (e) {
      case "SN_MAIN":
        return "https://alpha-mainnet.starknet.io";
      case "SN_GOERLI":
        return "https://alpha4.starknet.io";
      case "SN_GOERLI2":
        return "https://alpha4-2.starknet.io";
      default:
        throw new Error("Could not detect base url from NetworkName");
    }
  }
  static getChainIdFromBaseUrl(e) {
    try {
      const t = new URL(e);
      return t.host.includes("mainnet.starknet.io") ? "0x534e5f4d41494e" : t.host.includes("alpha4-2.starknet.io") ? "0x534e5f474f45524c4932" : "0x534e5f474f45524c49";
    } catch {
      return console.error(`Could not parse baseUrl: ${e}`), "0x534e5f474f45524c49";
    }
  }
  getFetchUrl(e) {
    return ["add_transaction"].includes(e) ? this.gatewayUrl : this.feederGatewayUrl;
  }
  getFetchMethod(e) {
    return [
      "add_transaction",
      "call_contract",
      "estimate_fee",
      "estimate_message_fee",
      "estimate_fee_bulk",
      "simulate_transaction"
    ].includes(e) ? "POST" : "GET";
  }
  getQueryString(e) {
    return yv(e) ? "" : `?${Object.entries(e).map(([r, n]) => r === "blockIdentifier" ? `${new Je(n).queryIdentifier}` : `${r}=${n}`).join("&")}`;
  }
  getHeaders(e) {
    return e === "POST" ? {
      "Content-Type": "application/json",
      ...this.headers
    } : this.headers;
  }
  // typesafe fetch
  async fetchEndpoint(e, ...[t, r]) {
    const n = this.getFetchUrl(e), a = this.getFetchMethod(e), i = this.getQueryString(t), c = E1(n, e, i);
    return this.fetch(c, {
      method: a,
      body: r
    });
  }
  async fetch(e, t) {
    const r = Ca(this.baseUrl, "", e), n = t?.method ?? "GET", a = this.getHeaders(n), i = Nr(t?.body);
    try {
      const c = await Ab(r, {
        method: n,
        body: i,
        headers: a
      }), s = await c.text();
      if (!c.ok) {
        let f;
        try {
          f = Xr(s);
        } catch {
          throw new fv(c.statusText, c.status);
        }
        throw new ov(f.message, f.code);
      }
      return (t?.parseAlwaysAsBigInt ? _b : Xr)(s);
    } catch (c) {
      throw c instanceof Error && !(c instanceof ta) ? Error(`Could not ${n} from endpoint \`${r}\`: ${c.message}`) : c;
    }
  }
  async getChainId() {
    return Promise.resolve(this.chainId);
  }
  async callContract({ contractAddress: e, entrypoint: t, calldata: r = [] }, n = this.blockIdentifier) {
    return this.fetchEndpoint(
      "call_contract",
      { blockIdentifier: n },
      {
        // TODO - determine best choice once both are fully supported in devnet
        // signature: [],
        // sender_address: contractAddress,
        contract_address: e,
        entry_point_selector: rr(t),
        calldata: Ne.compile(r)
      }
    ).then(this.responseParser.parseCallContractResponse);
  }
  async getBlock(e = this.blockIdentifier) {
    return this.fetchEndpoint("get_block", { blockIdentifier: e }).then(
      this.responseParser.parseGetBlockResponse
    );
  }
  async getNonceForAddress(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_nonce", { contractAddress: e, blockIdentifier: t });
  }
  async getStorageAt(e, t, r = this.blockIdentifier) {
    const n = ne(t).toString(10);
    return this.fetchEndpoint("get_storage_at", {
      blockIdentifier: r,
      contractAddress: e,
      key: n
    });
  }
  async getTransaction(e) {
    const t = ee(e);
    return this.fetchEndpoint("get_transaction", { transactionHash: t }).then((r) => {
      if (Object.values(r).length === 1)
        throw new ta(r.status);
      return this.responseParser.parseGetTransactionResponse(r);
    });
  }
  async getTransactionReceipt(e) {
    const t = ee(e);
    return this.fetchEndpoint("get_transaction_receipt", { transactionHash: t }).then(
      this.responseParser.parseGetTransactionReceiptResponse
    );
  }
  async getClassAt(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_full_contract", { blockIdentifier: t, contractAddress: e }).then(
      this.responseParser.parseContractClassResponse
    );
  }
  async getClassHashAt(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_class_hash_at", { blockIdentifier: t, contractAddress: e });
  }
  async getClassByHash(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_class_by_hash", { classHash: e, blockIdentifier: t }).then(
      this.responseParser.parseContractClassResponse
    );
  }
  async getCompiledClassByClassHash(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_compiled_class_by_class_hash", { classHash: e, blockIdentifier: t });
  }
  async invokeFunction(e, t) {
    return this.fetchEndpoint("add_transaction", void 0, {
      type: "INVOKE_FUNCTION",
      sender_address: e.contractAddress,
      calldata: Ne.compile(e.calldata ?? []),
      signature: Bn(e.signature),
      nonce: ee(t.nonce),
      max_fee: ee(t.maxFee || 0),
      version: "0x1"
    }).then(this.responseParser.parseInvokeFunctionResponse);
  }
  async deployAccountContract({ classHash: e, constructorCalldata: t, addressSalt: r, signature: n }, a) {
    return this.fetchEndpoint("add_transaction", void 0, {
      type: "DEPLOY_ACCOUNT",
      contract_address_salt: r ?? Of(),
      constructor_calldata: Ne.compile(t ?? []),
      class_hash: ee(e),
      max_fee: ee(a.maxFee || 0),
      version: ee(a.version || 0),
      nonce: ee(a.nonce),
      signature: Bn(n)
    }).then(this.responseParser.parseDeployContractResponse);
  }
  async declareContract({ senderAddress: e, contract: t, signature: r, compiledClassHash: n }, a) {
    return gr(t) ? this.fetchEndpoint("add_transaction", void 0, {
      type: "DECLARE",
      sender_address: e,
      compiled_class_hash: n,
      contract_class: t,
      nonce: ee(a.nonce),
      signature: Bn(r),
      max_fee: ee(a.maxFee || 0),
      version: ee(ea)
    }).then(this.responseParser.parseDeclareContractResponse) : this.fetchEndpoint("add_transaction", void 0, {
      type: "DECLARE",
      contract_class: t,
      nonce: ee(a.nonce),
      signature: Bn(r),
      sender_address: e,
      max_fee: ee(a.maxFee || 0),
      version: ee(zr)
    }).then(this.responseParser.parseDeclareContractResponse);
  }
  async getEstimateFee(e, t, r = this.blockIdentifier, n = !1) {
    return this.getInvokeEstimateFee(e, t, r, n);
  }
  async getInvokeEstimateFee(e, t, r = this.blockIdentifier, n = !1) {
    const a = this.buildTransaction(
      {
        type: "INVOKE_FUNCTION",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("estimate_fee", { blockIdentifier: r, skipValidate: n }, a).then(
      this.responseParser.parseFeeEstimateResponse
    );
  }
  async getDeclareEstimateFee(e, t, r = this.blockIdentifier, n = !1) {
    const a = this.buildTransaction(
      {
        type: "DECLARE",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("estimate_fee", { blockIdentifier: r, skipValidate: n }, a).then(
      this.responseParser.parseFeeEstimateResponse
    );
  }
  async getDeployAccountEstimateFee(e, t, r = this.blockIdentifier, n = !1) {
    const a = this.buildTransaction(
      {
        type: "DEPLOY_ACCOUNT",
        ...e,
        ...t
      },
      "fee"
    );
    return this.fetchEndpoint("estimate_fee", { blockIdentifier: r, skipValidate: n }, a).then(
      this.responseParser.parseFeeEstimateResponse
    );
  }
  async getEstimateFeeBulk(e, { blockIdentifier: t = this.blockIdentifier, skipValidate: r = !1 }) {
    const n = e.map((a) => this.buildTransaction(a, "fee"));
    return this.fetchEndpoint(
      "estimate_fee_bulk",
      { blockIdentifier: t, skipValidate: r },
      n
    ).then(this.responseParser.parseFeeEstimateBulkResponse);
  }
  async getCode(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_code", { contractAddress: e, blockIdentifier: t });
  }
  async waitForTransaction(e, t) {
    let r, n = !1, a = 0;
    const i = t?.retryInterval ?? 5e3, c = t?.errorStates ?? [
      "REJECTED",
      "NOT_RECEIVED",
      "REVERTED"
      /* REVERTED */
    ], s = t?.successStates ?? [
      "SUCCEEDED",
      "ACCEPTED_ON_L1",
      "ACCEPTED_ON_L2"
      /* ACCEPTED_ON_L2 */
    ];
    for (; !n; )
      if (await ss(i), r = await this.getTransactionStatus(e), r.finality_status === "NOT_RECEIVED" && a < 3)
        a += 1;
      else if (s.includes(r.finality_status) || s.includes(r.execution_status))
        n = !0;
      else if (c.includes(r.finality_status) || c.includes(r.execution_status)) {
        let f;
        r.tx_failure_reason ? f = `${r.tx_status}: ${r.tx_failure_reason.code}
${r.tx_failure_reason.error_message}` : r.tx_revert_reason ? f = `${r.tx_status}: ${r.tx_revert_reason}` : f = r.tx_status;
        const l = new Error(f);
        throw l.response = r, l;
      }
    return await this.getTransactionReceipt(e);
  }
  /**
   * Gets the status of a transaction.
   * @param txHash BigNumberish
   * @returns GetTransactionStatusResponse - the transaction status object
   */
  async getTransactionStatus(e) {
    const t = ee(e);
    return this.fetchEndpoint("get_transaction_status", { transactionHash: t });
  }
  /**
   * Gets the smart contract address on the goerli testnet.
   * @returns GetContractAddressesResponse - starknet smart contract addresses
   */
  async getContractAddresses() {
    return this.fetchEndpoint("get_contract_addresses");
  }
  /**
   * Gets the transaction trace from a tx id.
   * @param txHash BigNumberish
   * @returns TransactionTraceResponse - the transaction trace
   */
  async getTransactionTrace(e) {
    const t = ee(e);
    return this.fetchEndpoint("get_transaction_trace", { transactionHash: t });
  }
  async estimateMessageFee({ from_address: e, to_address: t, entry_point_selector: r, payload: n }, a = this.blockIdentifier) {
    const i = {
      from_address: Q1(e),
      to_address: pf(t),
      entry_point_selector: _f(r),
      payload: eb(n)
    };
    return this.fetchEndpoint("estimate_message_fee", { blockIdentifier: a }, i);
  }
  /**
   * Simulate transaction using Sequencer provider
   * WARNING!: Sequencer will process only first element from invocations array
   *
   * @param invocations Array of invocations, but only first invocation will be processed
   * @param blockIdentifier block identifier, default 'latest'
   * @param skipValidate Skip Account __validate__ method
   * @returns
   */
  async getSimulateTransaction(e, {
    blockIdentifier: t = this.blockIdentifier,
    skipValidate: r = !1,
    skipExecute: n = !1
  }) {
    e.length > 1 && console.warn("Sequencer simulate process only first element from invocations list"), n && console.warn("Sequencer can't skip account __execute__");
    const a = this.buildTransaction(e[0]);
    return this.fetchEndpoint(
      "simulate_transaction",
      {
        blockIdentifier: t,
        skipValidate: r ?? !1
      },
      a
    ).then(this.responseParser.parseSimulateTransactionResponse);
  }
  async getStateUpdate(e = this.blockIdentifier) {
    const t = new Je(e).sequencerIdentifier;
    return this.fetchEndpoint("get_state_update", { ...t }).then(
      this.responseParser.parseGetStateUpdateResponse
    );
  }
  // consider adding an optional trace retrieval parameter to the getBlock method
  async getBlockTraces(e = this.blockIdentifier) {
    const t = new Je(e).sequencerIdentifier;
    return this.fetchEndpoint("get_block_traces", { ...t });
  }
  async getStarkName(e, t) {
    return Lf(this, e, t);
  }
  async getAddressFromStarkName(e, t) {
    return Pf(this, e, t);
  }
  /**
   * Build Single AccountTransaction from Single AccountInvocation
   * @param invocation AccountInvocationItem
   * @param versionType 'fee' | 'transaction' - used to determine default versions
   * @returns AccountTransactionItem
   */
  buildTransaction(e, t) {
    const r = Cf(t), n = {
      signature: Bn(e.signature),
      nonce: ee(e.nonce)
    };
    if (e.type === "INVOKE_FUNCTION")
      return {
        type: e.type,
        sender_address: e.contractAddress,
        calldata: Ne.compile(e.calldata ?? []),
        version: ee(e.version || r.v1),
        ...n
      };
    if (e.type === "DECLARE")
      return gr(e.contract) ? {
        type: e.type,
        contract_class: e.contract,
        compiled_class_hash: e.compiledClassHash,
        sender_address: e.senderAddress,
        version: ee(e.version || r.v2),
        // fee on getDeclareEstimateFee use t.v. instead of feet.v.
        ...n
      } : {
        type: e.type,
        contract_class: e.contract,
        sender_address: e.senderAddress,
        version: ee(e.version || r.v1),
        // fee from getDeclareEstimateFee use t.v. instead of feet.v.
        ...n
      };
    if (e.type === "DEPLOY_ACCOUNT")
      return {
        type: e.type,
        constructor_calldata: Ne.compile(e.constructorCalldata || []),
        class_hash: ee(e.classHash),
        contract_address_salt: ee(e.addressSalt || 0),
        version: ee(e.version || r.v1),
        ...n
      };
    throw Error("Sequencer buildTransaction received unknown TransactionType");
  }
}, Ja = class {
  constructor(e) {
    e instanceof Ja ? this.provider = e.provider : e instanceof vl || e instanceof Ba ? this.provider = e : e && "rpc" in e ? this.provider = new vl(e.rpc) : e && "sequencer" in e ? this.provider = new Ba(e.sequencer) : this.provider = new Ba();
  }
  async getChainId() {
    return this.provider.getChainId();
  }
  async getBlock(e) {
    return this.provider.getBlock(e);
  }
  async getClassAt(e, t) {
    return this.provider.getClassAt(e, t);
  }
  async getClassHashAt(e, t) {
    return this.provider.getClassHashAt(e, t);
  }
  getClassByHash(e) {
    return this.provider.getClassByHash(e);
  }
  async getEstimateFee(e, t, r) {
    return this.provider.getEstimateFee(e, t, r);
  }
  async getInvokeEstimateFee(e, t, r, n) {
    return this.provider.getInvokeEstimateFee(
      e,
      t,
      r,
      n
    );
  }
  async getEstimateFeeBulk(e, t) {
    return this.provider.getEstimateFeeBulk(e, t);
  }
  async getNonceForAddress(e, t) {
    return this.provider.getNonceForAddress(e, t);
  }
  async getStorageAt(e, t, r) {
    return this.provider.getStorageAt(e, t, r);
  }
  async getTransaction(e) {
    return this.provider.getTransaction(e);
  }
  async getTransactionReceipt(e) {
    return this.provider.getTransactionReceipt(e);
  }
  async callContract(e, t) {
    return this.provider.callContract(e, t);
  }
  async invokeFunction(e, t) {
    return this.provider.invokeFunction(e, t);
  }
  async deployAccountContract(e, t) {
    return this.provider.deployAccountContract(e, t);
  }
  async declareContract(e, t) {
    return this.provider.declareContract(e, t);
  }
  async getDeclareEstimateFee(e, t, r, n) {
    return this.provider.getDeclareEstimateFee(e, t, r, n);
  }
  getDeployAccountEstimateFee(e, t, r, n) {
    return this.provider.getDeployAccountEstimateFee(
      e,
      t,
      r,
      n
    );
  }
  async getCode(e, t) {
    return this.provider.getCode(e, t);
  }
  async waitForTransaction(e, t) {
    return this.provider.waitForTransaction(e, t);
  }
  async getSimulateTransaction(e, t) {
    return this.provider.getSimulateTransaction(e, t);
  }
  async getStateUpdate(e) {
    return this.provider.getStateUpdate(e);
  }
  async getStarkName(e, t) {
    return Lf(this, e, t);
  }
  async getAddressFromStarkName(e, t) {
    return Pf(this, e, t);
  }
}, wv = {};
ut(wv, {
  fromCallsToExecuteCalldata: () => kf,
  fromCallsToExecuteCalldataWithNonce: () => mv,
  fromCallsToExecuteCalldata_cairo1: () => Rb,
  getExecuteCalldata: () => cs,
  transformCallsToMulticallArrays: () => Nb,
  transformCallsToMulticallArrays_cairo1: () => Ev
});
var Nb = (e) => {
  const t = [], r = [];
  return e.forEach((n) => {
    const a = Ne.compile(n.calldata || []);
    t.push({
      to: ne(n.contractAddress).toString(10),
      selector: ne(rr(n.entrypoint)).toString(10),
      data_offset: r.length.toString(),
      data_len: a.length.toString()
    }), r.push(...a);
  }), {
    callArray: t,
    calldata: Ne.compile({ calldata: r })
  };
}, kf = (e) => {
  const { callArray: t, calldata: r } = Nb(e);
  return [...Ne.compile({ callArray: t }), ...r];
}, mv = (e, t) => [...kf(e), ne(t).toString()], Ev = (e) => e.map((r) => ({
  to: ne(r.contractAddress).toString(10),
  selector: ne(rr(r.entrypoint)).toString(10),
  calldata: Ne.compile(r.calldata || [])
})), Rb = (e) => {
  const t = e.map((r) => ({
    contractAddress: r.contractAddress,
    entrypoint: r.entrypoint,
    calldata: r.calldata
  }));
  return Ne.compile({ orderCalls: t });
}, cs = (e, t = "0") => t === "1" ? Rb(e) : kf(e), vv = {};
ut(vv, {
  encodeData: () => $b,
  encodeType: () => Ub,
  encodeValue: () => Ff,
  getDependencies: () => Uf,
  getMessageHash: () => $f,
  getStructHash: () => Qa,
  getTypeHash: () => Fb,
  isMerkleTreeType: () => kb,
  prepareSelector: () => Pb
});
var xv = {};
ut(xv, {
  MerkleTree: () => Wn,
  proofMerklePath: () => Lb
});
var Wn = class {
  constructor(e) {
    this.branches = [], this.leaves = e, this.root = this.build(e);
  }
  build(e) {
    if (e.length === 1)
      return e[0];
    e.length !== this.leaves.length && this.branches.push(e);
    const t = [];
    for (let r = 0; r < e.length; r += 2)
      r + 1 === e.length ? t.push(Wn.hash(e[r], "0x0")) : t.push(Wn.hash(e[r], e[r + 1]));
    return this.build(t);
  }
  static hash(e, t) {
    const [r, n] = [ne(e), ne(t)].sort((a, i) => a >= i ? 1 : -1);
    return ia(r, n);
  }
  getProof(e, t = this.leaves, r = []) {
    const n = t.indexOf(e);
    if (n === -1)
      throw new Error("leaf not found");
    if (t.length === 1)
      return r;
    const a = n % 2 === 0, i = (a ? t[n + 1] : t[n - 1]) ?? "0x0", c = [...r, i], s = this.leaves.length === t.length ? -1 : this.branches.findIndex((f) => f.length === t.length), d = this.branches[s + 1] ?? [this.root];
    return this.getProof(
      Wn.hash(a ? e : i, a ? i : e),
      d,
      c
    );
  }
};
function Lb(e, t, r) {
  if (r.length === 0)
    return e === t;
  const [n, ...a] = r;
  return Lb(e, Wn.hash(t, n), a);
}
function Sv(e) {
  try {
    return ee(e);
  } catch {
    if (typeof e == "string")
      return ee(en(e));
    throw new Error(`Invalid BigNumberish: ${e}`);
  }
}
var Dv = (e) => {
  const t = e;
  return !!(t.types && t.primaryType && t.message);
};
function Pb(e) {
  return yr(e) ? e : rr(e);
}
function kb(e) {
  return e.type === "merkletree";
}
var Uf = (e, t, r = []) => (t[t.length - 1] === "*" && (t = t.slice(0, -1)), r.includes(t) || !e[t] ? r : [
  t,
  ...e[t].reduce(
    (n, a) => [
      ...n,
      ...Uf(e, a.type, n).filter(
        (i) => !n.includes(i)
      )
    ],
    []
  )
]);
function Av(e, t) {
  if (t.parent && t.key) {
    const n = e[t.parent].find((i) => i.name === t.key);
    if (!kb(n))
      throw new Error(`${t.key} is not a merkle tree`);
    if (n.contains.endsWith("*"))
      throw new Error(`Merkle tree contain property must not be an array but was given ${t.key}`);
    return n.contains;
  }
  return "raw";
}
var Ub = (e, t) => {
  const [r, ...n] = Uf(e, t);
  return (r ? [r, ...n.sort()] : []).map((i) => `${i}(${e[i].map((c) => `${c.name}:${c.type}`)})`).join("");
}, Fb = (e, t) => rr(Ub(e, t)), Ff = (e, t, r, n = {}) => {
  if (e[t])
    return [t, Qa(e, t, r)];
  if (Object.keys(e).map((a) => `${a}*`).includes(t)) {
    const a = r.map((i) => Qa(e, t.slice(0, -1), i));
    return [t, Dt(a)];
  }
  if (t === "merkletree") {
    const a = Av(e, n), i = r.map((s) => Ff(e, a, s)[1]), { root: c } = new Wn(i);
    return ["felt", c];
  }
  return t === "felt*" ? ["felt*", Dt(r)] : t === "selector" ? ["felt", Pb(r)] : [t, Sv(r)];
}, $b = (e, t, r) => {
  const [n, a] = e[t].reduce(
    ([i, c], s) => {
      if (r[s.name] === void 0 || r[s.name] === null)
        throw new Error(`Cannot encode data: missing data for '${s.name}'`);
      const d = r[s.name], [f, l] = Ff(e, s.type, d, {
        parent: t,
        key: s.name
      });
      return [
        [...i, f],
        [...c, l]
      ];
    },
    [["felt"], [Fb(e, t)]]
  );
  return [n, a];
}, Qa = (e, t, r) => Dt($b(e, t, r)[1]), $f = (e, t) => {
  if (!Dv(e))
    throw new Error("Typed data does not match JSON schema");
  const r = [
    en("StarkNet Message"),
    Qa(e.types, "StarkNetDomain", e.domain),
    t,
    Qa(e.types, e.primaryType, e.message)
  ];
  return Dt(r);
}, Iv = class {
  constructor(e = Go.randomPrivateKey()) {
    this.pk = e instanceof Uint8Array ? D1(e) : ee(e);
  }
  async getPubKey() {
    return Zo(this.pk);
  }
  async signMessage(e, t) {
    const r = $f(e, t);
    return Ta(r, this.pk);
  }
  async signTransaction(e, t, r) {
    if (r && r.length !== e.length)
      throw new Error("ABI must be provided for each transaction or no transaction");
    const n = cs(e, t.cairoVersion), a = mb(
      t.walletAddress,
      t.version,
      n,
      t.maxFee,
      t.chainId,
      t.nonce
    );
    return Ta(a, this.pk);
  }
  async signDeployAccountTransaction({
    classHash: e,
    contractAddress: t,
    constructorCalldata: r,
    addressSalt: n,
    maxFee: a,
    version: i,
    chainId: c,
    nonce: s
  }) {
    const d = wb(
      t,
      e,
      Ne.compile(r),
      n,
      i,
      a,
      c,
      s
    );
    return Ta(d, this.pk);
  }
  async signDeclareTransaction({
    classHash: e,
    senderAddress: t,
    chainId: r,
    maxFee: n,
    version: a,
    nonce: i,
    compiledClassHash: c
  }) {
    const s = yb(
      e,
      t,
      a,
      n,
      r,
      i,
      c
    );
    return Ta(s, this.pk);
  }
};
function Cv(e) {
  if (!e.events)
    throw new Error("UDC emited event is empty");
  const t = e.events.find(
    (r) => bo(r.from_address) === bo(un.ADDRESS)
  ) || {
    data: []
  };
  return {
    transaction_hash: e.transaction_hash,
    contract_address: t.data[0],
    address: t.data[0],
    deployer: t.data[1],
    unique: t.data[2],
    classHash: t.data[3],
    calldata_len: t.data[4],
    calldata: t.data.slice(5, 5 + parseInt(t.data[4], 16)),
    salt: t.data[t.data.length - 1]
  };
}
var Tv = class extends Ja {
  constructor(e, t, r, n = "0") {
    super(e), this.deploySelf = this.deployAccount, this.address = t.toLowerCase(), this.signer = typeof r == "string" || r instanceof Uint8Array ? new Iv(r) : r, this.cairoVersion = n;
  }
  async getNonce(e) {
    return super.getNonceForAddress(this.address, e);
  }
  async getNonceSafe(e) {
    try {
      return ne(e ?? await this.getNonce());
    } catch {
      return 0n;
    }
  }
  async estimateFee(e, t) {
    return this.estimateInvokeFee(e, t);
  }
  async estimateInvokeFee(e, { nonce: t, blockIdentifier: r, skipValidate: n } = {}) {
    const a = Array.isArray(e) ? e : [e], i = ne(t ?? await this.getNonce()), c = ne(Hn), s = await this.getChainId(), d = {
      walletAddress: this.address,
      nonce: i,
      maxFee: Mt,
      version: c,
      chainId: s,
      cairoVersion: this.cairoVersion
    }, f = await this.buildInvocation(a, d), l = await super.getInvokeEstimateFee(
      { ...f },
      { version: c, nonce: i },
      r,
      n
    ), p = wn(l.overall_fee);
    return {
      ...l,
      suggestedMaxFee: p
    };
  }
  async estimateDeclareFee({ contract: e, classHash: t, casm: r, compiledClassHash: n }, { blockIdentifier: a, nonce: i, skipValidate: c } = {}) {
    const s = ne(i ?? await this.getNonce()), d = gr(e) ? is : Hn, f = await this.getChainId(), l = await this.buildDeclarePayload(
      { classHash: t, contract: e, casm: r, compiledClassHash: n },
      {
        nonce: s,
        chainId: f,
        version: d,
        walletAddress: this.address,
        maxFee: Mt,
        cairoVersion: this.cairoVersion
      }
    ), p = await super.getDeclareEstimateFee(
      l,
      { version: d, nonce: s },
      a,
      c
    ), w = wn(p.overall_fee);
    return {
      ...p,
      suggestedMaxFee: w
    };
  }
  async estimateAccountDeployFee({
    classHash: e,
    addressSalt: t = 0,
    constructorCalldata: r = [],
    contractAddress: n
  }, { blockIdentifier: a, skipValidate: i } = {}) {
    const c = ne(Hn), s = Mt, d = await this.getChainId(), f = await this.buildAccountDeployPayload(
      { classHash: e, addressSalt: t, constructorCalldata: r, contractAddress: n },
      {
        nonce: s,
        chainId: d,
        version: c,
        walletAddress: this.address,
        maxFee: Mt,
        cairoVersion: this.cairoVersion
      }
    ), l = await super.getDeployAccountEstimateFee(
      { ...f },
      { version: c, nonce: s },
      a,
      i
    ), p = wn(l.overall_fee);
    return {
      ...l,
      suggestedMaxFee: p
    };
  }
  async estimateDeployFee(e, t) {
    const r = this.buildUDCContractPayload(e);
    return this.estimateInvokeFee(r, t);
  }
  async estimateFeeBulk(e, { nonce: t, blockIdentifier: r, skipValidate: n } = {}) {
    const a = await this.accountInvocationsFactory(e, {
      versions: [Hn, is],
      nonce: t,
      blockIdentifier: r
    }), i = await super.getEstimateFeeBulk(a, {
      blockIdentifier: r,
      skipValidate: n
    });
    return [].concat(i).map((c) => {
      const s = wn(c.overall_fee);
      return {
        ...c,
        suggestedMaxFee: s
      };
    });
  }
  async buildInvocation(e, t) {
    const r = cs(e, this.cairoVersion), n = await this.signer.signTransaction(e, t);
    return {
      contractAddress: this.address,
      calldata: r,
      signature: n
    };
  }
  async execute(e, t = void 0, r = {}) {
    const n = Array.isArray(e) ? e : [e], a = ne(r.nonce ?? await this.getNonce()), i = r.maxFee ?? await this.getSuggestedMaxFee(
      { type: "INVOKE_FUNCTION", payload: e },
      r
    ), c = ne(zr), s = await this.getChainId(), d = {
      walletAddress: this.address,
      nonce: a,
      maxFee: i,
      version: c,
      chainId: s,
      cairoVersion: this.cairoVersion
    }, f = await this.signer.signTransaction(n, d, t), l = cs(n, this.cairoVersion);
    return this.invokeFunction(
      { contractAddress: this.address, calldata: l, signature: f },
      {
        nonce: a,
        maxFee: i,
        version: c
      }
    );
  }
  /**
   * First check if contract is already declared, if not declare it
   * If contract already declared returned transaction_hash is ''.
   * Method will pass even if contract is already declared
   * @param payload DeclareContractPayload
   * @param transactionsDetail (optional) InvocationsDetails = \{\}
   * @returns DeclareContractResponse
   */
  async declareIfNot(e, t = {}) {
    const r = Cc(e);
    try {
      await this.getClassByHash(r.classHash);
    } catch {
      return this.declare(e, t);
    }
    return {
      transaction_hash: "",
      class_hash: r.classHash
    };
  }
  async declare(e, t = {}) {
    const r = Cc(e), n = {};
    n.nonce = ne(t.nonce ?? await this.getNonce()), n.maxFee = t.maxFee ?? await this.getSuggestedMaxFee(
      {
        type: "DECLARE",
        payload: r
      },
      t
    ), n.version = gr(e.contract) ? ea : zr, n.chainId = await this.getChainId();
    const a = await this.buildDeclarePayload(r, {
      ...n,
      walletAddress: this.address,
      cairoVersion: this.cairoVersion
    });
    return this.declareContract(a, n);
  }
  async deploy(e, t) {
    const r = [].concat(e).map((c) => {
      const {
        classHash: s,
        salt: d,
        unique: f = !0,
        constructorCalldata: l = []
      } = c, p = Ne.compile(l), w = d ?? Of();
      return {
        call: {
          contractAddress: un.ADDRESS,
          entrypoint: un.ENTRYPOINT,
          calldata: [
            s,
            w,
            po(f),
            p.length,
            ...p
          ]
        },
        address: qi(
          f ? ia(this.address, w) : w,
          s,
          p,
          f ? un.ADDRESS : 0
        )
      };
    }), n = r.map((c) => c.call), a = r.map((c) => c.address);
    return {
      ...await this.execute(n, void 0, t),
      contract_address: a
    };
  }
  async deployContract(e, t) {
    const r = await this.deploy(e, t), n = await this.waitForTransaction(r.transaction_hash);
    return Cv(n);
  }
  async declareAndDeploy(e, t) {
    const { constructorCalldata: r, salt: n, unique: a } = e;
    let i = await this.declareIfNot(e, t);
    if (i.transaction_hash !== "") {
      const s = await this.waitForTransaction(i.transaction_hash);
      i = { ...i, ...s };
    }
    const c = await this.deployContract(
      { classHash: i.class_hash, salt: n, unique: a, constructorCalldata: r },
      t
    );
    return { declare: { ...i }, deploy: c };
  }
  async deployAccount({
    classHash: e,
    constructorCalldata: t = [],
    addressSalt: r = 0,
    contractAddress: n
  }, a = {}) {
    const i = ne(zr), c = Mt, s = await this.getChainId(), d = Ne.compile(t), f = n ?? qi(r, e, d, 0), l = a.maxFee ?? await this.getSuggestedMaxFee(
      {
        type: "DEPLOY_ACCOUNT",
        payload: {
          classHash: e,
          constructorCalldata: d,
          addressSalt: r,
          contractAddress: f
        }
      },
      a
    ), p = await this.signer.signDeployAccountTransaction({
      classHash: e,
      constructorCalldata: d,
      contractAddress: f,
      addressSalt: r,
      chainId: s,
      maxFee: l,
      version: i,
      nonce: c
    });
    return this.deployAccountContract(
      { classHash: e, addressSalt: r, constructorCalldata: t, signature: p },
      {
        nonce: c,
        maxFee: l,
        version: i
      }
    );
  }
  async signMessage(e) {
    return this.signer.signMessage(e, this.address);
  }
  async hashMessage(e) {
    return $f(e, this.address);
  }
  async verifyMessageHash(e, t) {
    try {
      return await this.callContract({
        contractAddress: this.address,
        entrypoint: "isValidSignature",
        calldata: Ne.compile({
          hash: ne(e).toString(),
          signature: Bs(t)
        })
      }), !0;
    } catch {
      return !1;
    }
  }
  async verifyMessage(e, t) {
    const r = await this.hashMessage(e);
    return this.verifyMessageHash(r, t);
  }
  async getSuggestedMaxFee({ type: e, payload: t }, r) {
    let n;
    switch (e) {
      case "INVOKE_FUNCTION":
        n = await this.estimateInvokeFee(t, r);
        break;
      case "DECLARE":
        n = await this.estimateDeclareFee(t, r);
        break;
      case "DEPLOY_ACCOUNT":
        n = await this.estimateAccountDeployFee(t, r);
        break;
      case "DEPLOY":
        n = await this.estimateDeployFee(t, r);
        break;
      default:
        n = { suggestedMaxFee: Mt, overall_fee: Mt };
        break;
    }
    return n.suggestedMaxFee;
  }
  /**
   * will be renamed to buildDeclareContractTransaction
   */
  async buildDeclarePayload(e, { nonce: t, chainId: r, version: n, walletAddress: a, maxFee: i }) {
    const { classHash: c, contract: s, compiledClassHash: d } = Cc(e), f = Nf(s), l = await this.signer.signDeclareTransaction({
      classHash: c,
      compiledClassHash: d,
      senderAddress: a,
      chainId: r,
      maxFee: i,
      version: n,
      nonce: t
    });
    return {
      senderAddress: a,
      signature: l,
      contract: f,
      compiledClassHash: d
    };
  }
  async buildAccountDeployPayload({
    classHash: e,
    addressSalt: t = 0,
    constructorCalldata: r = [],
    contractAddress: n
  }, { nonce: a, chainId: i, version: c, maxFee: s }) {
    const d = Ne.compile(r), f = n ?? qi(t, e, d, 0), l = await this.signer.signDeployAccountTransaction({
      classHash: e,
      contractAddress: f,
      chainId: i,
      maxFee: s,
      version: c,
      nonce: a,
      addressSalt: t,
      constructorCalldata: d
    });
    return {
      classHash: e,
      addressSalt: t,
      constructorCalldata: d,
      signature: l
    };
  }
  buildUDCContractPayload(e) {
    return [].concat(e).map((r) => {
      const {
        classHash: n,
        salt: a = "0",
        unique: i = !0,
        constructorCalldata: c = []
      } = r, s = Ne.compile(c);
      return {
        contractAddress: un.ADDRESS,
        entrypoint: un.ENTRYPOINT,
        calldata: [
          n,
          a,
          po(i),
          s.length,
          ...s
        ]
      };
    });
  }
  async simulateTransaction(e, { nonce: t, blockIdentifier: r, skipValidate: n, skipExecute: a } = {}) {
    const i = await this.accountInvocationsFactory(e, {
      versions: [zr, ea],
      nonce: t,
      blockIdentifier: r
    });
    return super.getSimulateTransaction(i, {
      blockIdentifier: r,
      skipValidate: n,
      skipExecute: a
    });
  }
  async accountInvocationsFactory(e, { versions: t, nonce: r, blockIdentifier: n }) {
    const a = t[0], i = await this.getNonceSafe(r), c = await this.getChainId();
    return Promise.all(
      [].concat(e).map(async (s, d) => {
        const f = {
          walletAddress: this.address,
          nonce: ne(Number(i) + d),
          maxFee: Mt,
          version: a,
          chainId: c,
          cairoVersion: this.cairoVersion
        }, l = "payload" in s ? s.payload : s, p = {
          type: s.type,
          version: a,
          nonce: ne(Number(i) + d),
          blockIdentifier: n
        };
        if (s.type === "INVOKE_FUNCTION") {
          const w = await this.buildInvocation(
            [].concat(l),
            f
          );
          return {
            ...p,
            ...w
          };
        }
        if (s.type === "DECLARE") {
          f.version = gr(l.contract) ? ne(t[1]) : ne(t[0]);
          const w = await this.buildDeclarePayload(l, f);
          return {
            ...p,
            ...w,
            version: f.version
          };
        }
        if (s.type === "DEPLOY_ACCOUNT") {
          const w = await this.buildAccountDeployPayload(l, f);
          return {
            ...p,
            ...w
          };
        }
        if (s.type === "DEPLOY") {
          const w = this.buildUDCContractPayload(l), g = await this.buildInvocation(w, f);
          return {
            ...p,
            ...g,
            type: "INVOKE_FUNCTION"
            /* INVOKE */
          };
        }
        throw Error(`accountInvocationsFactory: unsupported transaction type: ${s}`);
      })
    );
  }
  async getStarkName(e = this.address, t) {
    return super.getStarkName(e, t);
  }
};
new Ja();
function Ov(e) {
  return typeof e < "u" && typeof e.context < "u";
}
const dr = { init: "signer_init", uri: "signer_uri", created: "signer_created", updated: "signer_updated", deleted: "signer_deleted", event: "signer_event" };
class Nv extends w4 {
  constructor(t) {
    super(), this.events = new zt.EventEmitter(), this.pending = !1, this.initializing = !1, this.requiredNamespaces = t?.requiredNamespaces || {}, this.opts = t?.client;
  }
  get connected() {
    return typeof this.session < "u";
  }
  get connecting() {
    return this.pending;
  }
  get chains() {
    return this.session ? pu(this.session.namespaces) : Q5(this.requiredNamespaces);
  }
  get accounts() {
    return this.session ? bu(this.session.namespaces) : [];
  }
  on(t, r) {
    this.events.on(t, r);
  }
  once(t, r) {
    this.events.once(t, r);
  }
  off(t, r) {
    this.events.off(t, r);
  }
  removeListener(t, r) {
    this.events.removeListener(t, r);
  }
  async open() {
    if (this.pending)
      return new Promise((t, r) => {
        this.events.once("open", () => {
          if (this.events.once("open_error", (n) => {
            r(n);
          }), typeof this.client > "u")
            return r(new Error("Sign Client not initialized"));
          t();
        });
      });
    try {
      this.pending = !0;
      const t = await this.register(), r = t.find({ requiredNamespaces: this.requiredNamespaces });
      if (r.length)
        return this.onOpen(r[0]);
      const { uri: n, approval: a } = await t.connect({ requiredNamespaces: this.requiredNamespaces });
      this.events.emit(dr.uri, { uri: n }), this.session = await a(), this.events.emit(dr.created, this.session), this.onOpen();
    } catch (t) {
      throw this.events.emit("open_error", t), t;
    }
  }
  async close() {
    typeof this.session > "u" || (await (await this.register()).disconnect({ topic: this.session.topic, reason: Qe("USER_DISCONNECTED") }), this.onClose());
  }
  async send(t, r) {
    if (typeof this.client > "u" && (this.client = await this.register(), this.connected || await this.open()), typeof this.session > "u")
      throw new Error("Signer connection is missing session");
    this.client.request({ topic: this.session.topic, request: t, chainId: r?.chainId }).then((n) => this.events.emit("payload", ys(t.id, n))).catch((n) => this.events.emit("payload", ws(t.id, n.message)));
  }
  async register(t = this.opts) {
    if (typeof this.client < "u")
      return this.client;
    if (this.initializing)
      return new Promise((r, n) => {
        this.events.once("register_error", (a) => {
          n(a);
        }), this.events.once(dr.init, () => {
          if (typeof this.client > "u")
            return n(new Error("Sign Client not initialized"));
          r(this.client);
        });
      });
    if (Ov(t))
      return this.client = t, this.registerEventListeners(), this.client;
    try {
      return this.initializing = !0, this.client = await xs.init(t), this.initializing = !1, this.registerEventListeners(), this.events.emit(dr.init), this.client;
    } catch (r) {
      throw this.events.emit("register_error", r), r;
    }
  }
  onOpen(t) {
    this.pending = !1, t && (this.session = t), this.events.emit("open");
  }
  onClose() {
    this.pending = !1, this.client && (this.client = void 0), this.events.emit("close");
  }
  registerEventListeners() {
    typeof this.client < "u" && (this.client.on("session_event", (t) => {
      var r;
      this.session && ((r = this.session) == null ? void 0 : r.topic) !== t.topic || this.events.emit(dr.event, t.params);
    }), this.client.on("session_update", (t) => {
      var r;
      typeof this.client < "u" && (this.session && ((r = this.session) == null ? void 0 : r.topic) !== t.topic || (this.session = this.client.session.get(t.topic), this.events.emit(dr.updated, this.session)));
    }), this.client.on("session_delete", (t) => {
      var r;
      this.session && (this.session && ((r = this.session) == null ? void 0 : r.topic) !== t.topic || (this.onClose(), this.events.emit(dr.deleted, this.session), this.session = void 0));
    }));
  }
}
class Rv {
  constructor() {
    Ee(this, "accounts", []);
    Ee(this, "eventEmitter", new zt.EventEmitter());
    Ee(this, "updateSession", (t) => {
      if (!this.isValidSession(t))
        throw console.warn(
          "updateSession incompatible session",
          t,
          "for adapter",
          this.formatChainId(this.chainId)
        ), new Error("Invalid session");
      this.session = t;
      const r = pu(t.namespaces, [this.namespace]);
      this.setChainIds(r);
      const n = bu(t.namespaces, [
        this.namespace
      ]);
      this.setAccounts(n);
    });
    Ee(this, "isValidSession", ({
      namespaces: t,
      requiredNamespaces: r
    }) => {
      const n = this.formatChainId(this.chainId);
      return r ? !!r[this.namespace]?.chains.includes(n) : !!t?.[this.namespace]?.accounts.some(
        (a) => a.startsWith(n)
      );
    });
  }
  getRequiredNamespaces() {
    const t = [this.formatChainId(this.chainId)];
    return {
      [this.namespace]: { chains: t, methods: this.methods, events: this.events }
    };
  }
  isCompatibleChainId(t) {
    return typeof t == "string" ? t.startsWith(`${this.namespace}:`) : !1;
  }
  setChainIds(t) {
    const n = t.filter((a) => this.isCompatibleChainId(a)).map((a) => this.parseChainId(a)).filter((a) => a !== this.chainId);
    n.length && (this.chainId = n[0], this.eventEmitter.emit("chainChanged", this.chainId));
  }
  setChainId(t) {
    if (this.isCompatibleChainId(t)) {
      const r = this.parseChainId(t);
      this.chainId = r, this.eventEmitter.emit("chainChanged", this.chainId);
    }
  }
  parseAccountId(t) {
    const [r, n, a] = t.split(":");
    return { chainId: `${r}:${n}`, address: a };
  }
  getSignerConnection(t) {
    return new Nv({
      requiredNamespaces: {
        [this.namespace]: {
          chains: this.rpc.chains,
          methods: this.rpc.methods,
          events: this.rpc.events
        }
      },
      client: t
    });
  }
  registerEventListeners() {
    this.rpcProvider.on("connect", () => {
      const { chains: t, accounts: r } = this.signerConnection;
      t?.length && this.setChainIds(t), r?.length && this.setAccounts(r);
    }), this.signerConnection.on(dr.created, this.updateSession), this.signerConnection.on(dr.updated, this.updateSession), this.signerConnection.on(dr.event, (t) => {
      if (!this.rpc.chains.includes(t.chainId))
        return;
      const { event: r } = t;
      r.name === "accountsChanged" ? (this.accounts = r.data, this.eventEmitter.emit("accountsChanged", this.accounts)) : r.name === "chainChanged" ? this.setChainId(r.data) : this.eventEmitter.emit(r.name, r.data);
    }), this.rpcProvider.on("disconnect", () => {
      this.eventEmitter.emit("disconnect");
    });
  }
}
class Sl extends Tv {
  constructor(t, r, n, a) {
    super(t, r, n), this.wallet = a;
  }
  async execute(t, r = void 0, n = {}) {
    return t = Array.isArray(t) ? t : [t], await this.wallet.starknet_requestAddInvokeTransaction({
      accountAddress: this.address,
      executionRequest: { calls: t, abis: r, invocationDetails: n }
    });
  }
  async declare(t, r) {
    throw new Error("Not supported via Argent Login");
  }
  async deployAccount(t, r) {
    throw new Error("Not supported via Argent Login");
  }
}
class Lv {
  constructor(t) {
    this.wallet = t;
  }
  async getPubKey() {
    throw new Error("Not supported via Argent Login");
  }
  async signMessage(t, r) {
    const { signature: n } = await this.wallet.starknet_signTypedData({
      accountAddress: r,
      typedData: t
    });
    return n;
  }
  async signTransaction(t, r, n) {
    throw new Error("Not supported via Argent Login");
  }
  async signDeployAccountTransaction(t) {
    throw new Error("Not supported via Argent Login");
  }
  async signDeclareTransaction(t) {
    throw new Error("Not supported via Argent Login");
  }
}
const Pv = (e) => e.replace(/^SN_/, "SN"), kv = (e) => e.replace(/^SN/, "SN_");
class Uv extends Rv {
  constructor({ client: r, chainId: n, rpcUrl: a }) {
    super();
    // StarknetWindowObject
    Ee(this, "id", "liftoff");
    Ee(this, "name", "Argent Liftoff");
    Ee(this, "version", "0.1.0");
    Ee(this, "icon", "");
    Ee(this, "provider");
    Ee(this, "signer");
    Ee(this, "account");
    Ee(this, "selectedAddress", "");
    // NamespaceAdapter
    Ee(this, "namespace", "starknet");
    Ee(this, "methods", [
      "starknet_signTypedData",
      "starknet_requestAddInvokeTransaction"
    ]);
    Ee(this, "events", ["chainChanged", "accountsChanged"]);
    Ee(this, "remoteSigner");
    Ee(this, "signerConnection");
    Ee(this, "rpcProvider");
    Ee(this, "chainId");
    Ee(this, "client");
    Ee(this, "session");
    Ee(this, "rpc");
    Ee(this, "walletRpc");
    Ee(this, "on", (r, n) => {
      this.eventEmitter.on(r, n);
    });
    Ee(this, "off", (r, n) => {
      this.eventEmitter.off(r, n);
    });
    if (this.chainId = String(n || "SN_GOERLI"), this.rpc = {
      chains: n ? [this.formatChainId(this.chainId)] : [],
      methods: this.methods,
      events: this.events
    }, this.signerConnection = this.getSignerConnection(r), this.rpcProvider = new Lu(this.signerConnection), this.client = r, this.registerEventListeners(), this.walletRpc = new Proxy({}, {
      get: (i, c) => (s) => this.requestWallet({ method: c, params: s })
    }), this.remoteSigner = new Lv(this.walletRpc), a)
      this.provider = new Ja({ rpc: { nodeUrl: a } });
    else {
      const i = this.getNetworkName(this.chainId);
      this.provider = new Ja({ sequencer: { network: i } });
    }
    this.account = new Sl(
      this.provider,
      "",
      this.remoteSigner,
      this.walletRpc
    );
  }
  getNetworkName(r) {
    if (r === "SN_GOERLI" || r === "SN_GOERLI2" || r === "SN_MAIN")
      return ji.NetworkName.SN_GOERLI;
    throw new Error(`Unknown starknet.js network name for chainId ${r}`);
  }
  // StarknetWindowObject
  async request(r) {
    throw new Error("Not implemented: .request()");
  }
  async enable() {
    return await this.rpcProvider.connect(), this.accounts;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  get isConnected() {
    return this.signerConnection.connected;
  }
  async isPreauthorized() {
    throw new Error("Not implemented: .isPreauthorized()");
  }
  async requestWallet(r) {
    if (!this.session)
      throw new Error("No session");
    try {
      const { topic: n } = this.session, a = this.formatChainId(this.chainId);
      return await this.client.request({ topic: n, chainId: a, request: r });
    } catch (n) {
      throw new Error(n);
    }
  }
  // NamespaceAdapter
  get isConnecting() {
    return this.signerConnection.connecting;
  }
  async disable() {
    await this.rpcProvider.disconnect();
  }
  get isWalletConnect() {
    return !0;
  }
  // NamespaceAdapter private methods
  registerEventListeners() {
    super.registerEventListeners(), this.eventEmitter.on("chainChanged", (r) => {
      throw new Error("Not implemented: chainChanged");
    });
  }
  formatChainId(r) {
    return `${this.namespace}:${Pv(r)}`;
  }
  parseChainId(r) {
    return kv(r.split(":")[1]);
  }
  setAccounts(r) {
    this.accounts = r.filter(
      (i) => this.parseChainId(this.parseAccountId(i).chainId) === this.chainId
    ).map((i) => this.parseAccountId(i).address);
    const { address: n } = this.parseAccountId(r[0]), a = n.startsWith("0x") ? n : `0x${n}`;
    this.account = new Sl(
      this.provider,
      a,
      this.remoteSigner,
      this.walletRpc
    ), this.eventEmitter.emit("accountsChanged", this.accounts);
  }
}
const Yv = async (e) => Dp(e, Uv);
export {
  Yv as getStarknetWindowObject
};
