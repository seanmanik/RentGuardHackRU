var $0 = Object.defineProperty;
var D0 = (e, t, a) => t in e ? $0(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a;
var $r = (e, t, a) => (D0(e, typeof t != "symbol" ? t + "" : t, a), a);
var B0 = typeof global == "object" && global && global.Object === Object && global;
const Z0 = B0;
var j0 = typeof self == "object" && self && self.Object === Object && self, U0 = Z0 || j0 || Function("return this")();
const ys = U0;
var M0 = ys.Symbol;
const ec = M0;
var rf = Object.prototype, H0 = rf.hasOwnProperty, z0 = rf.toString, yn = ec ? ec.toStringTag : void 0;
function F0(e) {
  var t = H0.call(e, yn), a = e[yn];
  try {
    e[yn] = void 0;
    var n = !0;
  } catch {
  }
  var r = z0.call(e);
  return n && (t ? e[yn] = a : delete e[yn]), r;
}
var V0 = Object.prototype, q0 = V0.toString;
function W0(e) {
  return q0.call(e);
}
var K0 = "[object Null]", G0 = "[object Undefined]", No = ec ? ec.toStringTag : void 0;
function Y0(e) {
  return e == null ? e === void 0 ? G0 : K0 : No && No in Object(e) ? F0(e) : W0(e);
}
function cf(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var X0 = "[object AsyncFunction]", J0 = "[object Function]", Q0 = "[object GeneratorFunction]", eb = "[object Proxy]";
function tb(e) {
  if (!cf(e))
    return !1;
  var t = Y0(e);
  return t == J0 || t == Q0 || t == X0 || t == eb;
}
var ab = ys["__core-js_shared__"];
const ei = ab;
var Ro = function() {
  var e = /[^.]+$/.exec(ei && ei.keys && ei.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function nb(e) {
  return !!Ro && Ro in e;
}
var rb = Function.prototype, cb = rb.toString;
function ib(e) {
  if (e != null) {
    try {
      return cb.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var sb = /[\\^$.*+?()[\]{}|]/g, ob = /^\[object .+?Constructor\]$/, db = Function.prototype, fb = Object.prototype, lb = db.toString, ub = fb.hasOwnProperty, bb = RegExp(
  "^" + lb.call(ub).replace(sb, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function hb(e) {
  if (!cf(e) || nb(e))
    return !1;
  var t = tb(e) ? bb : ob;
  return t.test(ib(e));
}
function pb(e, t) {
  return e?.[t];
}
function sf(e, t) {
  var a = pb(e, t);
  return hb(a) ? a : void 0;
}
var mb = sf(Object, "create");
const Dn = mb;
function gb() {
  this.__data__ = Dn ? Dn(null) : {}, this.size = 0;
}
function _b(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var yb = "__lodash_hash_undefined__", wb = Object.prototype, vb = wb.hasOwnProperty;
function xb(e) {
  var t = this.__data__;
  if (Dn) {
    var a = t[e];
    return a === yb ? void 0 : a;
  }
  return vb.call(t, e) ? t[e] : void 0;
}
var Eb = Object.prototype, kb = Eb.hasOwnProperty;
function Tb(e) {
  var t = this.__data__;
  return Dn ? t[e] !== void 0 : kb.call(t, e);
}
var Sb = "__lodash_hash_undefined__";
function Cb(e, t) {
  var a = this.__data__;
  return this.size += this.has(e) ? 0 : 1, a[e] = Dn && t === void 0 ? Sb : t, this;
}
function ha(e) {
  var t = -1, a = e == null ? 0 : e.length;
  for (this.clear(); ++t < a; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
ha.prototype.clear = gb;
ha.prototype.delete = _b;
ha.prototype.get = xb;
ha.prototype.has = Tb;
ha.prototype.set = Cb;
function Ab() {
  this.__data__ = [], this.size = 0;
}
function Ob(e, t) {
  return e === t || e !== e && t !== t;
}
function Ac(e, t) {
  for (var a = e.length; a--; )
    if (Ob(e[a][0], t))
      return a;
  return -1;
}
var Ib = Array.prototype, Nb = Ib.splice;
function Rb(e) {
  var t = this.__data__, a = Ac(t, e);
  if (a < 0)
    return !1;
  var n = t.length - 1;
  return a == n ? t.pop() : Nb.call(t, a, 1), --this.size, !0;
}
function Pb(e) {
  var t = this.__data__, a = Ac(t, e);
  return a < 0 ? void 0 : t[a][1];
}
function Lb(e) {
  return Ac(this.__data__, e) > -1;
}
function $b(e, t) {
  var a = this.__data__, n = Ac(a, e);
  return n < 0 ? (++this.size, a.push([e, t])) : a[n][1] = t, this;
}
function on(e) {
  var t = -1, a = e == null ? 0 : e.length;
  for (this.clear(); ++t < a; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
on.prototype.clear = Ab;
on.prototype.delete = Rb;
on.prototype.get = Pb;
on.prototype.has = Lb;
on.prototype.set = $b;
var Db = sf(ys, "Map");
const Bb = Db;
function Zb() {
  this.size = 0, this.__data__ = {
    hash: new ha(),
    map: new (Bb || on)(),
    string: new ha()
  };
}
function jb(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Oc(e, t) {
  var a = e.__data__;
  return jb(t) ? a[typeof t == "string" ? "string" : "hash"] : a.map;
}
function Ub(e) {
  var t = Oc(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function Mb(e) {
  return Oc(this, e).get(e);
}
function Hb(e) {
  return Oc(this, e).has(e);
}
function zb(e, t) {
  var a = Oc(this, e), n = a.size;
  return a.set(e, t), this.size += a.size == n ? 0 : 1, this;
}
function Ca(e) {
  var t = -1, a = e == null ? 0 : e.length;
  for (this.clear(); ++t < a; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
Ca.prototype.clear = Zb;
Ca.prototype.delete = Ub;
Ca.prototype.get = Mb;
Ca.prototype.has = Hb;
Ca.prototype.set = zb;
var Fb = "Expected a function";
function ws(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(Fb);
  var a = function() {
    var n = arguments, r = t ? t.apply(this, n) : n[0], c = a.cache;
    if (c.has(r))
      return c.get(r);
    var i = e.apply(this, n);
    return a.cache = c.set(r, i) || c, i;
  };
  return a.cache = new (ws.Cache || Ca)(), a;
}
ws.Cache = Ca;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const of = BigInt(0), Ic = BigInt(1), Vb = BigInt(2), Nc = (e) => e instanceof Uint8Array, qb = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Ft(e) {
  if (!Nc(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let a = 0; a < e.length; a++)
    t += qb[e[a]];
  return t;
}
function df(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function Rc(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
function Vt(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (e.length % 2)
    throw new Error("hex string is invalid: unpadded " + e.length);
  const t = new Uint8Array(e.length / 2);
  for (let a = 0; a < t.length; a++) {
    const n = a * 2, r = e.slice(n, n + 2), c = Number.parseInt(r, 16);
    if (Number.isNaN(c) || c < 0)
      throw new Error("invalid byte sequence");
    t[a] = c;
  }
  return t;
}
function Re(e) {
  return Rc(Ft(e));
}
function vs(e) {
  if (!Nc(e))
    throw new Error("Uint8Array expected");
  return Rc(Ft(Uint8Array.from(e).reverse()));
}
const Ha = (e, t) => Vt(e.toString(16).padStart(t * 2, "0")), ff = (e, t) => Ha(e, t).reverse(), xs = (e) => Vt(df(e));
function $e(e, t, a) {
  let n;
  if (typeof t == "string")
    try {
      n = Vt(t);
    } catch (c) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${c}`);
    }
  else if (Nc(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const r = n.length;
  if (typeof a == "number" && r !== a)
    throw new Error(`${e} expected ${a} bytes, got ${r}`);
  return n;
}
function Ga(...e) {
  const t = new Uint8Array(e.reduce((n, r) => n + r.length, 0));
  let a = 0;
  return e.forEach((n) => {
    if (!Nc(n))
      throw new Error("Uint8Array expected");
    t.set(n, a), a += n.length;
  }), t;
}
function Wb(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let a = 0; a < e.length; a++)
    if (e[a] !== t[a])
      return !1;
  return !0;
}
function Kb(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Gb(e) {
  let t;
  for (t = 0; e > of; e >>= Ic, t += 1)
    ;
  return t;
}
const Yb = (e, t) => e >> BigInt(t) & Ic, Xb = (e, t, a) => e | (a ? Ic : of) << BigInt(t), Pc = (e) => (Vb << BigInt(e - 1)) - Ic, ti = (e) => new Uint8Array(e), Po = (e) => Uint8Array.from(e);
function lf(e, t, a) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof a != "function")
    throw new Error("hmacFn must be a function");
  let n = ti(e), r = ti(e), c = 0;
  const i = () => {
    n.fill(1), r.fill(0), c = 0;
  }, s = (...l) => a(r, n, ...l), o = (l = ti()) => {
    r = s(Po([0]), l), n = s(), l.length !== 0 && (r = s(Po([1]), l), n = s());
  }, d = () => {
    if (c++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let l = 0;
    const b = [];
    for (; l < t; ) {
      n = s();
      const u = n.slice();
      b.push(u), l += n.length;
    }
    return Ga(...b);
  };
  return (l, b) => {
    i(), o(l);
    let u;
    for (; !(u = b(d())); )
      o();
    return i(), u;
  };
}
const Jb = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function _r(e, t, a = {}) {
  const n = (r, c, i) => {
    const s = Jb[c];
    if (typeof s != "function")
      throw new Error(`Invalid validator "${c}", expected function`);
    const o = e[r];
    if (!(i && o === void 0) && !s(o, e))
      throw new Error(`Invalid param ${String(r)}=${o} (${typeof o}), expected ${c}`);
  };
  for (const [r, c] of Object.entries(t))
    n(r, c, !1);
  for (const [r, c] of Object.entries(a))
    n(r, c, !0);
  return e;
}
const Qb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: Yb,
  bitLen: Gb,
  bitMask: Pc,
  bitSet: Xb,
  bytesToHex: Ft,
  bytesToNumberBE: Re,
  bytesToNumberLE: vs,
  concatBytes: Ga,
  createHmacDrbg: lf,
  ensureBytes: $e,
  equalBytes: Wb,
  hexToBytes: Vt,
  hexToNumber: Rc,
  numberToBytesBE: Ha,
  numberToBytesLE: ff,
  numberToHexUnpadded: df,
  numberToVarBytesBE: xs,
  utf8ToBytes: Kb,
  validateObject: _r
}, Symbol.toStringTag, { value: "Module" }));
function Li(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function e1(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function uf(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function t1(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Li(e.outputLen), Li(e.blockLen);
}
function a1(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function n1(e, t) {
  uf(e);
  const a = t.outputLen;
  if (e.length < a)
    throw new Error(`digestInto() expects output buffer of length at least ${a}`);
}
const _t = {
  number: Li,
  bool: e1,
  bytes: uf,
  hash: t1,
  exists: a1,
  output: n1
}, Dr = BigInt(2 ** 32 - 1), $i = BigInt(32);
function bf(e, t = !1) {
  return t ? { h: Number(e & Dr), l: Number(e >> $i & Dr) } : { h: Number(e >> $i & Dr) | 0, l: Number(e & Dr) | 0 };
}
function r1(e, t = !1) {
  let a = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let r = 0; r < e.length; r++) {
    const { h: c, l: i } = bf(e[r], t);
    [a[r], n[r]] = [c, i];
  }
  return [a, n];
}
const c1 = (e, t) => BigInt(e >>> 0) << $i | BigInt(t >>> 0), i1 = (e, t, a) => e >>> a, s1 = (e, t, a) => e << 32 - a | t >>> a, o1 = (e, t, a) => e >>> a | t << 32 - a, d1 = (e, t, a) => e << 32 - a | t >>> a, f1 = (e, t, a) => e << 64 - a | t >>> a - 32, l1 = (e, t, a) => e >>> a - 32 | t << 64 - a, u1 = (e, t) => t, b1 = (e, t) => e, h1 = (e, t, a) => e << a | t >>> 32 - a, p1 = (e, t, a) => t << a | e >>> 32 - a, m1 = (e, t, a) => t << a - 32 | e >>> 64 - a, g1 = (e, t, a) => e << a - 32 | t >>> 64 - a;
function _1(e, t, a, n) {
  const r = (t >>> 0) + (n >>> 0);
  return { h: e + a + (r / 2 ** 32 | 0) | 0, l: r | 0 };
}
const y1 = (e, t, a) => (e >>> 0) + (t >>> 0) + (a >>> 0), w1 = (e, t, a, n) => t + a + n + (e / 2 ** 32 | 0) | 0, v1 = (e, t, a, n) => (e >>> 0) + (t >>> 0) + (a >>> 0) + (n >>> 0), x1 = (e, t, a, n, r) => t + a + n + r + (e / 2 ** 32 | 0) | 0, E1 = (e, t, a, n, r) => (e >>> 0) + (t >>> 0) + (a >>> 0) + (n >>> 0) + (r >>> 0), k1 = (e, t, a, n, r, c) => t + a + n + r + c + (e / 2 ** 32 | 0) | 0, Bn = {
  fromBig: bf,
  split: r1,
  toBig: c1,
  shrSH: i1,
  shrSL: s1,
  rotrSH: o1,
  rotrSL: d1,
  rotrBH: f1,
  rotrBL: l1,
  rotr32H: u1,
  rotr32L: b1,
  rotlSH: h1,
  rotlSL: p1,
  rotlBH: m1,
  rotlBL: g1,
  add: _1,
  add3L: y1,
  add3H: w1,
  add4L: v1,
  add4H: x1,
  add5H: k1,
  add5L: E1
};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const T1 = (e) => e instanceof Uint8Array, S1 = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), ai = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Qe = (e, t) => e << 32 - t | e >>> t, C1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!C1)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function hf(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function Lc(e) {
  if (typeof e == "string" && (e = hf(e)), !T1(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
let pf = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function Es(e) {
  const t = (n) => e().update(Lc(n)).digest(), a = e();
  return t.outputLen = a.outputLen, t.blockLen = a.blockLen, t.create = () => e(), t;
}
function A1(e) {
  const t = (n, r) => e(r).update(Lc(n)).digest(), a = e({});
  return t.outputLen = a.outputLen, t.blockLen = a.blockLen, t.create = (n) => e(n), t;
}
const [mf, gf, _f] = [[], [], []], O1 = BigInt(0), wn = BigInt(1), I1 = BigInt(2), N1 = BigInt(7), R1 = BigInt(256), P1 = BigInt(113);
for (let e = 0, t = wn, a = 1, n = 0; e < 24; e++) {
  [a, n] = [n, (2 * a + 3 * n) % 5], mf.push(2 * (5 * n + a)), gf.push((e + 1) * (e + 2) / 2 % 64);
  let r = O1;
  for (let c = 0; c < 7; c++)
    t = (t << wn ^ (t >> N1) * P1) % R1, t & I1 && (r ^= wn << (wn << BigInt(c)) - wn);
  _f.push(r);
}
const [L1, $1] = Bn.split(_f, !0), Lo = (e, t, a) => a > 32 ? Bn.rotlBH(e, t, a) : Bn.rotlSH(e, t, a), $o = (e, t, a) => a > 32 ? Bn.rotlBL(e, t, a) : Bn.rotlSL(e, t, a);
function D1(e, t = 24) {
  const a = new Uint32Array(10);
  for (let n = 24 - t; n < 24; n++) {
    for (let i = 0; i < 10; i++)
      a[i] = e[i] ^ e[i + 10] ^ e[i + 20] ^ e[i + 30] ^ e[i + 40];
    for (let i = 0; i < 10; i += 2) {
      const s = (i + 8) % 10, o = (i + 2) % 10, d = a[o], f = a[o + 1], l = Lo(d, f, 1) ^ a[s], b = $o(d, f, 1) ^ a[s + 1];
      for (let u = 0; u < 50; u += 10)
        e[i + u] ^= l, e[i + u + 1] ^= b;
    }
    let r = e[2], c = e[3];
    for (let i = 0; i < 24; i++) {
      const s = gf[i], o = Lo(r, c, s), d = $o(r, c, s), f = mf[i];
      r = e[f], c = e[f + 1], e[f] = o, e[f + 1] = d;
    }
    for (let i = 0; i < 50; i += 10) {
      for (let s = 0; s < 10; s++)
        a[s] = e[i + s];
      for (let s = 0; s < 10; s++)
        e[i + s] ^= ~a[(s + 2) % 10] & a[(s + 4) % 10];
    }
    e[0] ^= L1[n], e[1] ^= $1[n];
  }
  a.fill(0);
}
class $c extends pf {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, a, n, r = !1, c = 24) {
    if (super(), this.blockLen = t, this.suffix = a, this.outputLen = n, this.enableXOF = r, this.rounds = c, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, _t.number(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = S1(this.state);
  }
  keccak() {
    D1(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    _t.exists(this);
    const { blockLen: a, state: n } = this;
    t = Lc(t);
    const r = t.length;
    for (let c = 0; c < r; ) {
      const i = Math.min(a - this.pos, r - c);
      for (let s = 0; s < i; s++)
        n[this.pos++] ^= t[c++];
      this.pos === a && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: a, pos: n, blockLen: r } = this;
    t[n] ^= a, a & 128 && n === r - 1 && this.keccak(), t[r - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    _t.exists(this, !1), _t.bytes(t), this.finish();
    const a = this.state, { blockLen: n } = this;
    for (let r = 0, c = t.length; r < c; ) {
      this.posOut >= n && this.keccak();
      const i = Math.min(n - this.posOut, c - r);
      t.set(a.subarray(this.posOut, this.posOut + i), r), this.posOut += i, r += i;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return _t.number(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (_t.output(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: a, suffix: n, outputLen: r, rounds: c, enableXOF: i } = this;
    return t || (t = new $c(a, n, r, i, c)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = c, t.suffix = n, t.outputLen = r, t.enableXOF = i, t.destroyed = this.destroyed, t;
  }
}
const Qt = (e, t, a) => Es(() => new $c(t, e, a));
Qt(6, 144, 224 / 8);
Qt(6, 136, 256 / 8);
Qt(6, 104, 384 / 8);
Qt(6, 72, 512 / 8);
Qt(1, 144, 224 / 8);
const B1 = Qt(1, 136, 256 / 8);
Qt(1, 104, 384 / 8);
Qt(1, 72, 512 / 8);
const yf = (e, t, a) => A1((n = {}) => new $c(t, e, n.dkLen === void 0 ? a : n.dkLen, !0));
yf(31, 168, 128 / 8);
yf(31, 136, 256 / 8);
function Z1(e, t, a, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, a, n);
  const r = BigInt(32), c = BigInt(4294967295), i = Number(a >> r & c), s = Number(a & c), o = n ? 4 : 0, d = n ? 0 : 4;
  e.setUint32(t + o, i, n), e.setUint32(t + d, s, n);
}
class j1 extends pf {
  constructor(t, a, n, r) {
    super(), this.blockLen = t, this.outputLen = a, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = ai(this.buffer);
  }
  update(t) {
    _t.exists(this);
    const { view: a, buffer: n, blockLen: r } = this;
    t = Lc(t);
    const c = t.length;
    for (let i = 0; i < c; ) {
      const s = Math.min(r - this.pos, c - i);
      if (s === r) {
        const o = ai(t);
        for (; r <= c - i; i += r)
          this.process(o, i);
        continue;
      }
      n.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === r && (this.process(a, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    _t.exists(this), _t.output(t, this), this.finished = !0;
    const { buffer: a, view: n, blockLen: r, isLE: c } = this;
    let { pos: i } = this;
    a[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > r - i && (this.process(n, 0), i = 0);
    for (let l = i; l < r; l++)
      a[l] = 0;
    Z1(n, r - 8, BigInt(this.length * 8), c), this.process(n, 0);
    const s = ai(t), o = this.outputLen;
    if (o % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const d = o / 4, f = this.get();
    if (d > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < d; l++)
      s.setUint32(4 * l, f[l], c);
  }
  digest() {
    const { buffer: t, outputLen: a } = this;
    this.digestInto(t);
    const n = t.slice(0, a);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: a, buffer: n, length: r, finished: c, destroyed: i, pos: s } = this;
    return t.length = r, t.pos = s, t.finished = c, t.destroyed = i, r % a && t.buffer.set(n), t;
  }
}
const U1 = (e, t, a) => e & t ^ ~e & a, M1 = (e, t, a) => e & t ^ e & a ^ t & a, H1 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Nt = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Rt = new Uint32Array(64);
class wf extends j1 {
  constructor() {
    super(64, 32, 8, !1), this.A = Nt[0] | 0, this.B = Nt[1] | 0, this.C = Nt[2] | 0, this.D = Nt[3] | 0, this.E = Nt[4] | 0, this.F = Nt[5] | 0, this.G = Nt[6] | 0, this.H = Nt[7] | 0;
  }
  get() {
    const { A: t, B: a, C: n, D: r, E: c, F: i, G: s, H: o } = this;
    return [t, a, n, r, c, i, s, o];
  }
  // prettier-ignore
  set(t, a, n, r, c, i, s, o) {
    this.A = t | 0, this.B = a | 0, this.C = n | 0, this.D = r | 0, this.E = c | 0, this.F = i | 0, this.G = s | 0, this.H = o | 0;
  }
  process(t, a) {
    for (let l = 0; l < 16; l++, a += 4)
      Rt[l] = t.getUint32(a, !1);
    for (let l = 16; l < 64; l++) {
      const b = Rt[l - 15], u = Rt[l - 2], h = Qe(b, 7) ^ Qe(b, 18) ^ b >>> 3, p = Qe(u, 17) ^ Qe(u, 19) ^ u >>> 10;
      Rt[l] = p + Rt[l - 7] + h + Rt[l - 16] | 0;
    }
    let { A: n, B: r, C: c, D: i, E: s, F: o, G: d, H: f } = this;
    for (let l = 0; l < 64; l++) {
      const b = Qe(s, 6) ^ Qe(s, 11) ^ Qe(s, 25), u = f + b + U1(s, o, d) + H1[l] + Rt[l] | 0, p = (Qe(n, 2) ^ Qe(n, 13) ^ Qe(n, 22)) + M1(n, r, c) | 0;
      f = d, d = o, o = s, s = i + u | 0, i = c, c = r, r = n, n = u + p | 0;
    }
    n = n + this.A | 0, r = r + this.B | 0, c = c + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, o = o + this.F | 0, d = d + this.G | 0, f = f + this.H | 0, this.set(n, r, c, i, s, o, d, f);
  }
  roundClean() {
    Rt.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class z1 extends wf {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
const ks = Es(() => new wf());
Es(() => new z1());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _e = BigInt(0), de = BigInt(1), ra = BigInt(2), F1 = BigInt(3), Di = BigInt(4), Do = BigInt(5), Bo = BigInt(8);
BigInt(9);
BigInt(16);
function Ee(e, t) {
  const a = e % t;
  return a >= _e ? a : t + a;
}
function V1(e, t, a) {
  if (a <= _e || t < _e)
    throw new Error("Expected power/modulo > 0");
  if (a === de)
    return _e;
  let n = de;
  for (; t > _e; )
    t & de && (n = n * e % a), e = e * e % a, t >>= de;
  return n;
}
function Bi(e, t) {
  if (e === _e || t <= _e)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let a = Ee(e, t), n = t, r = _e, c = de;
  for (; a !== _e; ) {
    const s = n / a, o = n % a, d = r - c * s;
    n = a, a = o, r = c, c = d;
  }
  if (n !== de)
    throw new Error("invert: does not exist");
  return Ee(r, t);
}
function q1(e) {
  const t = (e - de) / ra;
  let a, n, r;
  for (a = e - de, n = 0; a % ra === _e; a /= ra, n++)
    ;
  for (r = ra; r < e && V1(r, t, e) !== e - de; r++)
    ;
  if (n === 1) {
    const i = (e + de) / Di;
    return function(o, d) {
      const f = o.pow(d, i);
      if (!o.eql(o.sqr(f), d))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  const c = (a + de) / ra;
  return function(s, o) {
    if (s.pow(o, t) === s.neg(s.ONE))
      throw new Error("Cannot find square root");
    let d = n, f = s.pow(s.mul(s.ONE, r), a), l = s.pow(o, c), b = s.pow(o, a);
    for (; !s.eql(b, s.ONE); ) {
      if (s.eql(b, s.ZERO))
        return s.ZERO;
      let u = 1;
      for (let p = s.sqr(b); u < d && !s.eql(p, s.ONE); u++)
        p = s.sqr(p);
      const h = s.pow(f, de << BigInt(d - u - 1));
      f = s.sqr(h), l = s.mul(l, h), b = s.mul(b, f), d = u;
    }
    return l;
  };
}
function W1(e) {
  if (e % Di === F1) {
    const t = (e + de) / Di;
    return function(n, r) {
      const c = n.pow(r, t);
      if (!n.eql(n.sqr(c), r))
        throw new Error("Cannot find square root");
      return c;
    };
  }
  if (e % Bo === Do) {
    const t = (e - Do) / Bo;
    return function(n, r) {
      const c = n.mul(r, ra), i = n.pow(c, t), s = n.mul(r, i), o = n.mul(n.mul(s, ra), i), d = n.mul(s, n.sub(o, n.ONE));
      if (!n.eql(n.sqr(d), r))
        throw new Error("Cannot find square root");
      return d;
    };
  }
  return q1(e);
}
const K1 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Dc(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, a = K1.reduce((n, r) => (n[r] = "function", n), t);
  return _r(e, a);
}
function vf(e, t, a) {
  if (a < _e)
    throw new Error("Expected power > 0");
  if (a === _e)
    return e.ONE;
  if (a === de)
    return t;
  let n = e.ONE, r = t;
  for (; a > _e; )
    a & de && (n = e.mul(n, r)), r = e.sqr(r), a >>= de;
  return n;
}
function G1(e, t) {
  const a = new Array(t.length), n = t.reduce((c, i, s) => e.is0(i) ? c : (a[s] = c, e.mul(c, i)), e.ONE), r = e.inv(n);
  return t.reduceRight((c, i, s) => e.is0(i) ? c : (a[s] = e.mul(c, a[s]), e.mul(c, i)), r), a;
}
function Ts(e, t) {
  const a = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(a / 8);
  return { nBitLength: a, nByteLength: n };
}
function Ss(e, t, a = !1, n = {}) {
  if (e <= _e)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: r, nByteLength: c } = Ts(e, t);
  if (c > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const i = W1(e), s = Object.freeze({
    ORDER: e,
    BITS: r,
    BYTES: c,
    MASK: Pc(r),
    ZERO: _e,
    ONE: de,
    create: (o) => Ee(o, e),
    isValid: (o) => {
      if (typeof o != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof o}`);
      return _e <= o && o < e;
    },
    is0: (o) => o === _e,
    isOdd: (o) => (o & de) === de,
    neg: (o) => Ee(-o, e),
    eql: (o, d) => o === d,
    sqr: (o) => Ee(o * o, e),
    add: (o, d) => Ee(o + d, e),
    sub: (o, d) => Ee(o - d, e),
    mul: (o, d) => Ee(o * d, e),
    pow: (o, d) => vf(s, o, d),
    div: (o, d) => Ee(o * Bi(d, e), e),
    // Same as above, but doesn't normalize
    sqrN: (o) => o * o,
    addN: (o, d) => o + d,
    subN: (o, d) => o - d,
    mulN: (o, d) => o * d,
    inv: (o) => Bi(o, e),
    sqrt: n.sqrt || ((o) => i(s, o)),
    invertBatch: (o) => G1(s, o),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (o, d, f) => f ? d : o,
    toBytes: (o) => a ? ff(o, c) : Ha(o, c),
    fromBytes: (o) => {
      if (o.length !== c)
        throw new Error(`Fp.fromBytes: expected ${c}, got ${o.length}`);
      return a ? vs(o) : Re(o);
    }
  });
  return Object.freeze(s);
}
function Y1(e, t, a = !1) {
  e = $e("privateHash", e);
  const n = e.length, r = Ts(t).nByteLength + 8;
  if (r < 24 || n < r || n > 1024)
    throw new Error(`hashToPrivateScalar: expected ${r}-1024 bytes of input, got ${n}`);
  const c = a ? vs(e) : Re(e);
  return Ee(c, t - de) + de;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function xf(e) {
  const { Fp: t } = e;
  Dc(t);
  for (const o of ["t", "roundsFull", "roundsPartial"])
    if (typeof e[o] != "number" || !Number.isSafeInteger(e[o]))
      throw new Error(`Poseidon: invalid param ${o}=${e[o]} (${typeof e[o]})`);
  if (e.reversePartialPowIdx !== void 0 && typeof e.reversePartialPowIdx != "boolean")
    throw new Error(`Poseidon: invalid param reversePartialPowIdx=${e.reversePartialPowIdx}`);
  let a = e.sboxPower;
  if (a === void 0 && (a = 5), typeof a != "number" || !Number.isSafeInteger(a))
    throw new Error(`Poseidon wrong sboxPower=${a}`);
  const n = BigInt(a);
  let r = (o) => vf(t, o, n);
  if (a === 3 ? r = (o) => t.mul(t.sqrN(o), o) : a === 5 && (r = (o) => t.mul(t.sqrN(t.sqrN(o)), o)), e.roundsFull % 2 !== 0)
    throw new Error(`Poseidon roundsFull is not even: ${e.roundsFull}`);
  const c = e.roundsFull + e.roundsPartial;
  if (!Array.isArray(e.roundConstants) || e.roundConstants.length !== c)
    throw new Error("Poseidon: wrong round constants");
  const i = e.roundConstants.map((o) => {
    if (!Array.isArray(o) || o.length !== e.t)
      throw new Error(`Poseidon wrong round constants: ${o}`);
    return o.map((d) => {
      if (typeof d != "bigint" || !t.isValid(d))
        throw new Error(`Poseidon wrong round constant=${d}`);
      return t.create(d);
    });
  });
  if (!Array.isArray(e.mds) || e.mds.length !== e.t)
    throw new Error("Poseidon: wrong MDS matrix");
  const s = e.mds.map((o) => {
    if (!Array.isArray(o) || o.length !== e.t)
      throw new Error(`Poseidon MDS matrix row: ${o}`);
    return o.map((d) => {
      if (typeof d != "bigint")
        throw new Error(`Poseidon MDS matrix value=${d}`);
      return t.create(d);
    });
  });
  return Object.freeze({ ...e, rounds: c, sboxFn: r, roundConstants: i, mds: s });
}
function X1(e, t) {
  if (typeof t != "number")
    throw new Error("poseidonSplitConstants: wrong t");
  if (!Array.isArray(e) || e.length % t)
    throw new Error("poseidonSplitConstants: wrong rc");
  const a = [];
  let n = [];
  for (let r = 0; r < e.length; r++)
    n.push(e[r]), n.length === t && (a.push(n), n = []);
  return a;
}
function Ef(e) {
  const { t, Fp: a, rounds: n, sboxFn: r, reversePartialPowIdx: c } = xf(e), i = Math.floor(e.roundsFull / 2), s = c ? t - 1 : 0, o = (f, l, b) => (f = f.map((u, h) => a.add(u, e.roundConstants[b][h])), l ? f = f.map((u) => r(u)) : f[s] = r(f[s]), f = e.mds.map((u) => u.reduce((h, p, m) => a.add(h, a.mulN(p, f[m])), a.ZERO)), f), d = function(l) {
    if (!Array.isArray(l) || l.length !== t)
      throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);
    l = l.map((u) => {
      if (typeof u != "bigint")
        throw new Error(`Poseidon: wrong value=${u} (${typeof u})`);
      return a.create(u);
    });
    let b = 0;
    for (let u = 0; u < i; u++)
      l = o(l, !0, b++);
    for (let u = 0; u < e.roundsPartial; u++)
      l = o(l, !1, b++);
    for (let u = 0; u < i; u++)
      l = o(l, !0, b++);
    if (b !== n)
      throw new Error(`Poseidon: wrong number of rounds: last round=${b}, total=${n}`);
    return l;
  };
  return d.roundConstants = e.roundConstants, d;
}
const J1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  poseidon: Ef,
  splitConstants: X1,
  validateOpts: xf
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Q1 = BigInt(0), ni = BigInt(1);
function eh(e, t) {
  const a = (r, c) => {
    const i = c.negate();
    return r ? i : c;
  }, n = (r) => {
    const c = Math.ceil(t / r) + 1, i = 2 ** (r - 1);
    return { windows: c, windowSize: i };
  };
  return {
    constTimeNegate: a,
    // non-const time multiplication ladder
    unsafeLadder(r, c) {
      let i = e.ZERO, s = r;
      for (; c > Q1; )
        c & ni && (i = i.add(s)), s = s.double(), c >>= ni;
      return i;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
     * - ùëä is the window size
     * - ùëõ is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(r, c) {
      const { windows: i, windowSize: s } = n(c), o = [];
      let d = r, f = d;
      for (let l = 0; l < i; l++) {
        f = d, o.push(f);
        for (let b = 1; b < s; b++)
          f = f.add(d), o.push(f);
        d = f.double();
      }
      return o;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(r, c, i) {
      const { windows: s, windowSize: o } = n(r);
      let d = e.ZERO, f = e.BASE;
      const l = BigInt(2 ** r - 1), b = 2 ** r, u = BigInt(r);
      for (let h = 0; h < s; h++) {
        const p = h * o;
        let m = Number(i & l);
        i >>= u, m > o && (m -= b, i += ni);
        const g = p, v = p + Math.abs(m) - 1, S = h % 2 !== 0, y = m < 0;
        m === 0 ? f = f.add(a(S, c[g])) : d = d.add(a(y, c[v]));
      }
      return { p: d, f };
    },
    wNAFCached(r, c, i, s) {
      const o = r._WINDOW_SIZE || 1;
      let d = c.get(r);
      return d || (d = this.precomputeWindow(r, o), o !== 1 && c.set(r, s(d))), this.wNAF(o, d, i);
    }
  };
}
function kf(e) {
  return Dc(e.Fp), _r(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...Ts(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function th(e) {
  const t = kf(e);
  _r(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: a, Fp: n, a: r } = t;
  if (a) {
    if (!n.eql(r, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof a != "object" || typeof a.beta != "bigint" || typeof a.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: ah, hexToBytes: nh } = Qb, Bt = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(e) {
    const { Err: t } = Bt;
    if (e.length < 2 || e[0] !== 2)
      throw new t("Invalid signature integer tag");
    const a = e[1], n = e.subarray(2, a + 2);
    if (!a || n.length !== a)
      throw new t("Invalid signature integer: wrong length");
    if (n[0] & 128)
      throw new t("Invalid signature integer: negative");
    if (n[0] === 0 && !(n[1] & 128))
      throw new t("Invalid signature integer: unnecessary leading zero");
    return { d: ah(n), l: e.subarray(a + 2) };
  },
  toSig(e) {
    const { Err: t } = Bt, a = typeof e == "string" ? nh(e) : e;
    if (!(a instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = a.length;
    if (n < 2 || a[0] != 48)
      throw new t("Invalid signature tag");
    if (a[1] !== n - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: r, l: c } = Bt._parseInt(a.subarray(2)), { d: i, l: s } = Bt._parseInt(c);
    if (s.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r, s: i };
  },
  hexFromSig(e) {
    const t = (d) => Number.parseInt(d[0], 16) & 8 ? "00" + d : d, a = (d) => {
      const f = d.toString(16);
      return f.length & 1 ? `0${f}` : f;
    }, n = t(a(e.s)), r = t(a(e.r)), c = n.length / 2, i = r.length / 2, s = a(c), o = a(i);
    return `30${a(i + c + 4)}02${o}${r}02${s}${n}`;
  }
}, ze = BigInt(0), fe = BigInt(1), mt = BigInt(2), tc = BigInt(3), Zo = BigInt(4);
function Tf(e) {
  const t = th(e), { Fp: a } = t, n = t.toBytes || ((h, p, m) => {
    const g = p.toAffine();
    return Ga(Uint8Array.from([4]), a.toBytes(g.x), a.toBytes(g.y));
  }), r = t.fromBytes || ((h) => {
    const p = h.subarray(1), m = a.fromBytes(p.subarray(0, a.BYTES)), g = a.fromBytes(p.subarray(a.BYTES, 2 * a.BYTES));
    return { x: m, y: g };
  });
  function c(h) {
    const { a: p, b: m } = t, g = a.sqr(h), v = a.mul(g, h);
    return a.add(a.add(v, a.mul(h, p)), m);
  }
  if (!a.eql(a.sqr(t.Gy), c(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function i(h) {
    return typeof h == "bigint" && ze < h && h < t.n;
  }
  function s(h) {
    if (!i(h))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function o(h) {
    const { allowedPrivateKeyLengths: p, nByteLength: m, wrapPrivateKey: g, n: v } = t;
    if (p && typeof h != "bigint") {
      if (h instanceof Uint8Array && (h = Ft(h)), typeof h != "string" || !p.includes(h.length))
        throw new Error("Invalid key");
      h = h.padStart(m * 2, "0");
    }
    let S;
    try {
      S = typeof h == "bigint" ? h : Re($e("private key", h, m));
    } catch {
      throw new Error(`private key must be ${m} bytes, hex or bigint, not ${typeof h}`);
    }
    return g && (S = Ee(S, v)), s(S), S;
  }
  const d = /* @__PURE__ */ new Map();
  function f(h) {
    if (!(h instanceof l))
      throw new Error("ProjectivePoint expected");
  }
  class l {
    constructor(p, m, g) {
      if (this.px = p, this.py = m, this.pz = g, p == null || !a.isValid(p))
        throw new Error("x required");
      if (m == null || !a.isValid(m))
        throw new Error("y required");
      if (g == null || !a.isValid(g))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x: m, y: g } = p || {};
      if (!p || !a.isValid(m) || !a.isValid(g))
        throw new Error("invalid affine point");
      if (p instanceof l)
        throw new Error("projective point not allowed");
      const v = (S) => a.eql(S, a.ZERO);
      return v(m) && v(g) ? l.ZERO : new l(m, g, a.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(p) {
      const m = a.invertBatch(p.map((g) => g.pz));
      return p.map((g, v) => g.toAffine(m[v])).map(l.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(p) {
      const m = l.fromAffine(r($e("pointHex", p)));
      return m.assertValidity(), m;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(p) {
      return l.BASE.multiply(o(p));
    }
    // "Private method", don't use it directly
    _setWindowSize(p) {
      this._WINDOW_SIZE = p, d.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: p, y: m } = this.toAffine();
      if (!a.isValid(p) || !a.isValid(m))
        throw new Error("bad point: x or y not FE");
      const g = a.sqr(m), v = c(p);
      if (!a.eql(g, v))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: p } = this.toAffine();
      if (a.isOdd)
        return !a.isOdd(p);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(p) {
      f(p);
      const { px: m, py: g, pz: v } = this, { px: S, py: y, pz: O } = p, E = a.eql(a.mul(m, O), a.mul(S, v)), _ = a.eql(a.mul(g, O), a.mul(y, v));
      return E && _;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new l(this.px, a.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: p, b: m } = t, g = a.mul(m, tc), { px: v, py: S, pz: y } = this;
      let O = a.ZERO, E = a.ZERO, _ = a.ZERO, I = a.mul(v, v), j = a.mul(S, S), C = a.mul(y, y), x = a.mul(v, S);
      return x = a.add(x, x), _ = a.mul(v, y), _ = a.add(_, _), O = a.mul(p, _), E = a.mul(g, C), E = a.add(O, E), O = a.sub(j, E), E = a.add(j, E), E = a.mul(O, E), O = a.mul(x, O), _ = a.mul(g, _), C = a.mul(p, C), x = a.sub(I, C), x = a.mul(p, x), x = a.add(x, _), _ = a.add(I, I), I = a.add(_, I), I = a.add(I, C), I = a.mul(I, x), E = a.add(E, I), C = a.mul(S, y), C = a.add(C, C), I = a.mul(C, x), O = a.sub(O, I), _ = a.mul(C, j), _ = a.add(_, _), _ = a.add(_, _), new l(O, E, _);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(p) {
      f(p);
      const { px: m, py: g, pz: v } = this, { px: S, py: y, pz: O } = p;
      let E = a.ZERO, _ = a.ZERO, I = a.ZERO;
      const j = t.a, C = a.mul(t.b, tc);
      let x = a.mul(m, S), J = a.mul(g, y), ce = a.mul(v, O), B = a.add(m, g), w = a.add(S, y);
      B = a.mul(B, w), w = a.add(x, J), B = a.sub(B, w), w = a.add(m, v);
      let A = a.add(S, O);
      return w = a.mul(w, A), A = a.add(x, ce), w = a.sub(w, A), A = a.add(g, v), E = a.add(y, O), A = a.mul(A, E), E = a.add(J, ce), A = a.sub(A, E), I = a.mul(j, w), E = a.mul(C, ce), I = a.add(E, I), E = a.sub(J, I), I = a.add(J, I), _ = a.mul(E, I), J = a.add(x, x), J = a.add(J, x), ce = a.mul(j, ce), w = a.mul(C, w), J = a.add(J, ce), ce = a.sub(x, ce), ce = a.mul(j, ce), w = a.add(w, ce), x = a.mul(J, w), _ = a.add(_, x), x = a.mul(A, w), E = a.mul(B, E), E = a.sub(E, x), x = a.mul(B, J), I = a.mul(A, I), I = a.add(I, x), new l(E, _, I);
    }
    subtract(p) {
      return this.add(p.negate());
    }
    is0() {
      return this.equals(l.ZERO);
    }
    wNAF(p) {
      return u.wNAFCached(this, d, p, (m) => {
        const g = a.invertBatch(m.map((v) => v.pz));
        return m.map((v, S) => v.toAffine(g[S])).map(l.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(p) {
      const m = l.ZERO;
      if (p === ze)
        return m;
      if (s(p), p === fe)
        return this;
      const { endo: g } = t;
      if (!g)
        return u.unsafeLadder(this, p);
      let { k1neg: v, k1: S, k2neg: y, k2: O } = g.splitScalar(p), E = m, _ = m, I = this;
      for (; S > ze || O > ze; )
        S & fe && (E = E.add(I)), O & fe && (_ = _.add(I)), I = I.double(), S >>= fe, O >>= fe;
      return v && (E = E.negate()), y && (_ = _.negate()), _ = new l(a.mul(_.px, g.beta), _.py, _.pz), E.add(_);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(p) {
      s(p);
      let m = p, g, v;
      const { endo: S } = t;
      if (S) {
        const { k1neg: y, k1: O, k2neg: E, k2: _ } = S.splitScalar(m);
        let { p: I, f: j } = this.wNAF(O), { p: C, f: x } = this.wNAF(_);
        I = u.constTimeNegate(y, I), C = u.constTimeNegate(E, C), C = new l(a.mul(C.px, S.beta), C.py, C.pz), g = I.add(C), v = j.add(x);
      } else {
        const { p: y, f: O } = this.wNAF(m);
        g = y, v = O;
      }
      return l.normalizeZ([g, v])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(p, m, g) {
      const v = l.BASE, S = (O, E) => E === ze || E === fe || !O.equals(v) ? O.multiplyUnsafe(E) : O.multiply(E), y = S(this, m).add(S(p, g));
      return y.is0() ? void 0 : y;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ‚àã (x=x/z, y=y/z)
    toAffine(p) {
      const { px: m, py: g, pz: v } = this, S = this.is0();
      p == null && (p = S ? a.ONE : a.inv(v));
      const y = a.mul(m, p), O = a.mul(g, p), E = a.mul(v, p);
      if (S)
        return { x: a.ZERO, y: a.ZERO };
      if (!a.eql(E, a.ONE))
        throw new Error("invZ was invalid");
      return { x: y, y: O };
    }
    isTorsionFree() {
      const { h: p, isTorsionFree: m } = t;
      if (p === fe)
        return !0;
      if (m)
        return m(l, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: p, clearCofactor: m } = t;
      return p === fe ? this : m ? m(l, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(p = !0) {
      return this.assertValidity(), n(l, this, p);
    }
    toHex(p = !0) {
      return Ft(this.toRawBytes(p));
    }
  }
  l.BASE = new l(t.Gx, t.Gy, a.ONE), l.ZERO = new l(a.ZERO, a.ONE, a.ZERO);
  const b = t.nBitLength, u = eh(l, t.endo ? Math.ceil(b / 2) : b);
  return {
    CURVE: t,
    ProjectivePoint: l,
    normPrivateKeyToScalar: o,
    weierstrassEquation: c,
    isWithinCurveOrder: i
  };
}
function rh(e) {
  const t = kf(e);
  return _r(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function Sf(e) {
  const t = rh(e), { Fp: a, n } = t, r = a.BYTES + 1, c = 2 * a.BYTES + 1;
  function i(w) {
    return ze < w && w < a.ORDER;
  }
  function s(w) {
    return Ee(w, n);
  }
  function o(w) {
    return Bi(w, n);
  }
  const { ProjectivePoint: d, normPrivateKeyToScalar: f, weierstrassEquation: l, isWithinCurveOrder: b } = Tf({
    ...t,
    toBytes(w, A, F) {
      const Q = A.toAffine(), ae = a.toBytes(Q.x), pe = Ga;
      return F ? pe(Uint8Array.from([A.hasEvenY() ? 2 : 3]), ae) : pe(Uint8Array.from([4]), ae, a.toBytes(Q.y));
    },
    fromBytes(w) {
      const A = w.length, F = w[0], Q = w.subarray(1);
      if (A === r && (F === 2 || F === 3)) {
        const ae = Re(Q);
        if (!i(ae))
          throw new Error("Point is not on curve");
        const pe = l(ae);
        let Ze = a.sqrt(pe);
        const Pe = (Ze & fe) === fe;
        return (F & 1) === 1 !== Pe && (Ze = a.neg(Ze)), { x: ae, y: Ze };
      } else if (A === c && F === 4) {
        const ae = a.fromBytes(Q.subarray(0, a.BYTES)), pe = a.fromBytes(Q.subarray(a.BYTES, 2 * a.BYTES));
        return { x: ae, y: pe };
      } else
        throw new Error(`Point of length ${A} was invalid. Expected ${r} compressed bytes or ${c} uncompressed bytes`);
    }
  }), u = (w) => Ft(Ha(w, t.nByteLength));
  function h(w) {
    const A = n >> fe;
    return w > A;
  }
  function p(w) {
    return h(w) ? s(-w) : w;
  }
  const m = (w, A, F) => Re(w.slice(A, F));
  class g {
    constructor(A, F, Q) {
      this.r = A, this.s = F, this.recovery = Q, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(A) {
      const F = t.nByteLength;
      return A = $e("compactSignature", A, F * 2), new g(m(A, 0, F), m(A, F, 2 * F));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(A) {
      const { r: F, s: Q } = Bt.toSig($e("DER", A));
      return new g(F, Q);
    }
    assertValidity() {
      if (!b(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!b(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(A) {
      return new g(this.r, this.s, A);
    }
    recoverPublicKey(A) {
      const { r: F, s: Q, recovery: ae } = this, pe = _($e("msgHash", A));
      if (ae == null || ![0, 1, 2, 3].includes(ae))
        throw new Error("recovery id invalid");
      const Ze = ae === 2 || ae === 3 ? F + t.n : F;
      if (Ze >= a.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Pe = ae & 1 ? "03" : "02", At = d.fromHex(Pe + u(Ze)), Ot = o(Ze), Ia = s(-pe * Ot), _n = s(Q * Ot), It = d.BASE.multiplyAndAddUnsafe(At, Ia, _n);
      if (!It)
        throw new Error("point at infinify");
      return It.assertValidity(), It;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return h(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new g(this.r, s(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Vt(this.toDERHex());
    }
    toDERHex() {
      return Bt.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Vt(this.toCompactHex());
    }
    toCompactHex() {
      return u(this.r) + u(this.s);
    }
  }
  const v = {
    isValidPrivateKey(w) {
      try {
        return f(w), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: f,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const w = t.randomBytes(a.BYTES + 8), A = Y1(w, n);
      return Ha(A, t.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(w = 8, A = d.BASE) {
      return A._setWindowSize(w), A.multiply(BigInt(3)), A;
    }
  };
  function S(w, A = !0) {
    return d.fromPrivateKey(w).toRawBytes(A);
  }
  function y(w) {
    const A = w instanceof Uint8Array, F = typeof w == "string", Q = (A || F) && w.length;
    return A ? Q === r || Q === c : F ? Q === 2 * r || Q === 2 * c : w instanceof d;
  }
  function O(w, A, F = !0) {
    if (y(w))
      throw new Error("first arg must be private key");
    if (!y(A))
      throw new Error("second arg must be public key");
    return d.fromHex(A).multiply(f(w)).toRawBytes(F);
  }
  const E = t.bits2int || function(w) {
    const A = Re(w), F = w.length * 8 - t.nBitLength;
    return F > 0 ? A >> BigInt(F) : A;
  }, _ = t.bits2int_modN || function(w) {
    return s(E(w));
  }, I = Pc(t.nBitLength);
  function j(w) {
    if (typeof w != "bigint")
      throw new Error("bigint expected");
    if (!(ze <= w && w < I))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return Ha(w, t.nByteLength);
  }
  function C(w, A, F = x) {
    if (["recovered", "canonical"].some((aa) => aa in F))
      throw new Error("sign() legacy options not supported");
    const { hash: Q, randomBytes: ae } = t;
    let { lowS: pe, prehash: Ze, extraEntropy: Pe } = F;
    pe == null && (pe = !0), w = $e("msgHash", w), Ze && (w = $e("prehashed msgHash", Q(w)));
    const At = _(w), Ot = f(A), Ia = [j(Ot), j(At)];
    if (Pe != null) {
      const aa = Pe === !0 ? ae(a.BYTES) : Pe;
      Ia.push($e("extraEntropy", aa, a.BYTES));
    }
    const _n = Ga(...Ia), It = At;
    function Qc(aa) {
      const Na = E(aa);
      if (!b(Na))
        return;
      const Ao = o(Na), Je = d.BASE.multiply(Na).toAffine(), Ra = s(Je.x);
      if (Ra === ze)
        return;
      const Lr = s(Ao * s(It + Ra * Ot));
      if (Lr === ze)
        return;
      let Oo = (Je.x === Ra ? 0 : 2) | Number(Je.y & fe), Io = Lr;
      return pe && h(Lr) && (Io = p(Lr), Oo ^= 1), new g(Ra, Io, Oo);
    }
    return { seed: _n, k2sig: Qc };
  }
  const x = { lowS: t.lowS, prehash: !1 }, J = { lowS: t.lowS, prehash: !1 };
  function ce(w, A, F = x) {
    const { seed: Q, k2sig: ae } = C(w, A, F);
    return lf(t.hash.outputLen, t.nByteLength, t.hmac)(Q, ae);
  }
  d.BASE._setWindowSize(8);
  function B(w, A, F, Q = J) {
    const ae = w;
    if (A = $e("msgHash", A), F = $e("publicKey", F), "strict" in Q)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: pe, prehash: Ze } = Q;
    let Pe, At;
    try {
      if (typeof ae == "string" || ae instanceof Uint8Array)
        try {
          Pe = g.fromDER(ae);
        } catch (Je) {
          if (!(Je instanceof Bt.Err))
            throw Je;
          Pe = g.fromCompact(ae);
        }
      else if (typeof ae == "object" && typeof ae.r == "bigint" && typeof ae.s == "bigint") {
        const { r: Je, s: Ra } = ae;
        Pe = new g(Je, Ra);
      } else
        throw new Error("PARSE");
      At = d.fromHex(F);
    } catch (Je) {
      if (Je.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (pe && Pe.hasHighS())
      return !1;
    Ze && (A = t.hash(A));
    const { r: Ot, s: Ia } = Pe, _n = _(A), It = o(Ia), Qc = s(_n * It), aa = s(Ot * It), Na = d.BASE.multiplyAndAddUnsafe(At, Qc, aa)?.toAffine();
    return Na ? s(Na.x) === Ot : !1;
  }
  return {
    CURVE: t,
    getPublicKey: S,
    getSharedSecret: O,
    sign: ce,
    verify: B,
    ProjectivePoint: d,
    Signature: g,
    utils: v
  };
}
function Cf(e, t) {
  const a = e.ORDER;
  let n = ze;
  for (let b = a - fe; b % mt === ze; b /= mt)
    n += fe;
  const r = n, c = (a - fe) / mt ** r, i = (c - fe) / mt, s = mt ** r - fe, o = mt ** (r - fe), d = e.pow(t, c), f = e.pow(t, (c + fe) / mt);
  let l = (b, u) => {
    let h = d, p = e.pow(u, s), m = e.sqr(p);
    m = e.mul(m, u);
    let g = e.mul(b, m);
    g = e.pow(g, i), g = e.mul(g, p), p = e.mul(g, u), m = e.mul(g, b);
    let v = e.mul(m, p);
    g = e.pow(v, o);
    let S = e.eql(g, e.ONE);
    p = e.mul(m, f), g = e.mul(v, h), m = e.cmov(p, m, S), v = e.cmov(g, v, S);
    for (let y = r; y > fe; y--) {
      let O = mt ** (y - mt), E = e.pow(v, O);
      const _ = e.eql(E, e.ONE);
      p = e.mul(m, h), h = e.mul(h, h), E = e.mul(v, h), m = e.cmov(p, m, _), v = e.cmov(E, v, _);
    }
    return { isValid: S, value: m };
  };
  if (e.ORDER % Zo === tc) {
    const b = (e.ORDER - tc) / Zo, u = e.sqrt(e.neg(t));
    l = (h, p) => {
      let m = e.sqr(p);
      const g = e.mul(h, p);
      m = e.mul(m, g);
      let v = e.pow(m, b);
      v = e.mul(v, g);
      const S = e.mul(v, u), y = e.mul(e.sqr(v), p), O = e.eql(y, h);
      let E = e.cmov(S, v, O);
      return { isValid: O, value: E };
    };
  }
  return l;
}
function ch(e, t) {
  if (Dc(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const a = Cf(e, t.Z);
  if (!e.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (n) => {
    let r, c, i, s, o, d, f, l;
    r = e.sqr(n), r = e.mul(r, t.Z), c = e.sqr(r), c = e.add(c, r), i = e.add(c, e.ONE), i = e.mul(i, t.B), s = e.cmov(t.Z, e.neg(c), !e.eql(c, e.ZERO)), s = e.mul(s, t.A), c = e.sqr(i), d = e.sqr(s), o = e.mul(d, t.A), c = e.add(c, o), c = e.mul(c, i), d = e.mul(d, s), o = e.mul(d, t.B), c = e.add(c, o), f = e.mul(r, i);
    const { isValid: b, value: u } = a(c, d);
    l = e.mul(r, n), l = e.mul(l, u), f = e.cmov(f, i, b), l = e.cmov(l, u, b);
    const h = e.isOdd(n) === e.isOdd(l);
    return l = e.cmov(e.neg(l), l, h), f = e.div(f, s), { x: f, y: l };
  };
}
const ih = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DER: Bt,
  SWUFpSqrtRatio: Cf,
  mapToCurveSimpleSWU: ch,
  weierstrass: Sf,
  weierstrassPoints: Tf
}, Symbol.toStringTag, { value: "Module" }));
function Zi(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function sh(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function Af(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function oh(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Zi(e.outputLen), Zi(e.blockLen);
}
function dh(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function fh(e, t) {
  Af(e);
  const a = t.outputLen;
  if (e.length < a)
    throw new Error(`digestInto() expects output buffer of length at least ${a}`);
}
const Br = {
  number: Zi,
  bool: sh,
  bytes: Af,
  hash: oh,
  exists: dh,
  output: fh
}, ri = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const lh = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!lh)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function uh(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function bh(e) {
  if (typeof e == "string" && (e = uh(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
function hh(...e) {
  if (!e.every((n) => n instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (e.length === 1)
    return e[0];
  const t = e.reduce((n, r) => n + r.length, 0), a = new Uint8Array(t);
  for (let n = 0, r = 0; n < e.length; n++) {
    const c = e[n];
    a.set(c, r), r += c.length;
  }
  return a;
}
class ph {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function mh(e = 32) {
  if (ri && typeof ri.getRandomValues == "function")
    return ri.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
class Of extends ph {
  constructor(t, a) {
    super(), this.finished = !1, this.destroyed = !1, Br.hash(t);
    const n = bh(a);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const r = this.blockLen, c = new Uint8Array(r);
    c.set(n.length > r ? t.create().update(n).digest() : n);
    for (let i = 0; i < c.length; i++)
      c[i] ^= 54;
    this.iHash.update(c), this.oHash = t.create();
    for (let i = 0; i < c.length; i++)
      c[i] ^= 106;
    this.oHash.update(c), c.fill(0);
  }
  update(t) {
    return Br.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Br.exists(this), Br.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: a, iHash: n, finished: r, destroyed: c, blockLen: i, outputLen: s } = this;
    return t = t, t.finished = r, t.destroyed = c, t.blockLen = i, t.outputLen = s, t.oHash = a._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const If = (e, t, a) => new Of(e, t).update(a).digest();
If.create = (e, t) => new Of(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function gh(e) {
  return {
    hash: e,
    hmac: (t, ...a) => If(e, t, hh(...a)),
    randomBytes: mh
  };
}
const ac = BigInt("3618502788666131213697322783095070105526743751716087489154079457884512865583"), Nf = 252;
function jo(e) {
  for (; e[0] === 0; )
    e = e.subarray(1);
  const t = e.length * 8 - Nf, a = Re(e);
  return t > 0 ? a >> BigInt(t) : a;
}
function Rf(e) {
  return typeof e == "string" && (e = Os(e), e.length & 1 && (e = "0" + e)), Vt(e);
}
const Aa = Sf({
  a: BigInt(1),
  b: BigInt("3141592653589793238462643383279502884197169399375105820974944592307816406665"),
  Fp: Ss(BigInt("0x800000000000011000000000000000000000000000000000000000000000001")),
  n: ac,
  nBitLength: Nf,
  Gx: BigInt("874739451078007766457464989774322083649278607533249481151382481072868806602"),
  Gy: BigInt("152666792071518830868575557812948353041420400780739481342941381225525861407"),
  h: BigInt(1),
  lowS: !1,
  ...gh(ks),
  bits2int: jo,
  bits2int_modN: (e) => {
    const t = Re(e).toString(16);
    return t.length === 63 && (e = Rf(t + "0")), Ee(jo(e), ac);
  }
}), _h = Aa;
function la(e) {
  return $e("", typeof e == "string" ? Rf(e) : e);
}
function Cs(e) {
  return Ft(la(e)).padStart(64, "0");
}
function Pf(e, t = !1) {
  return Aa.getPublicKey(Cs(e), t);
}
function yh(e, t) {
  return Aa.getSharedSecret(Cs(e), t);
}
function En(e, t, a) {
  return Aa.sign(la(e), Cs(t), a);
}
function wh(e, t, a) {
  const n = e instanceof Lf ? e : la(e);
  return Aa.verify(n, la(t), la(a));
}
const { CURVE: vh, ProjectivePoint: $a, Signature: Lf, utils: As } = Aa;
function $f(e) {
  return `0x${Ft(e.subarray(1)).replace(/^0+/gm, "")}`;
}
function Os(e) {
  return e.replace(/^0x/i, "");
}
function xh(e) {
  return `0x${e.toString(16)}`;
}
function Df(e) {
  const t = la(e), a = 2n ** 256n, n = a - Ee(a, ac);
  for (let r = 0; ; r++) {
    const c = ji(Ga(t, xs(BigInt(r))));
    if (c < n)
      return Ee(c, ac).toString(16);
    if (r === 1e5)
      throw new Error("grindKey is broken: tried 100k vals");
  }
}
function Is(e) {
  return $f(Pf(e, !0));
}
function Eh(e) {
  if (e = Os(e), e.length !== 130)
    throw new Error("Wrong ethereum signature");
  return Df(e.substring(0, 64));
}
const kh = 2n ** 31n - 1n, Zr = (e) => Number(e & kh);
function Th(e, t, a, n) {
  const r = Zr(ji(e)), c = Zr(ji(t)), i = Rc(Os(a));
  return `m/2645'/${r}'/${c}'/${Zr(i)}'/${Zr(i >> 31n)}'/${n}`;
}
const Zn = [
  new $a(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),
  new $a(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),
  new $a(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),
  new $a(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),
  new $a(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)
];
function Bf(e, t) {
  const a = [];
  let n = e;
  for (let r = 0; r < 248; r++)
    a.push(n), n = n.double();
  n = t;
  for (let r = 0; r < 4; r++)
    a.push(n), n = n.double();
  return a;
}
const Sh = Bf(Zn[1], Zn[2]), Ch = Bf(Zn[3], Zn[4]);
function Zf(e) {
  let t;
  if (typeof e == "bigint")
    t = e;
  else if (typeof e == "number") {
    if (!Number.isSafeInteger(e))
      throw new Error(`Invalid pedersenArg: ${e}`);
    t = BigInt(e);
  } else
    t = Re(la(e));
  if (!(0n <= t && t < Aa.CURVE.Fp.ORDER))
    throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${t}`);
  return t;
}
function Uo(e, t, a) {
  let n = Zf(t);
  for (let r = 0; r < 252; r++) {
    const c = a[r];
    if (c.equals(e))
      throw new Error("Same point");
    (n & 1n) !== 0n && (e = e.add(c)), n >>= 1n;
  }
  return e;
}
function dn(e, t) {
  let a = Zn[0];
  return a = Uo(a, e, Sh), a = Uo(a, t, Ch), $f(a.toRawBytes(!0));
}
function Ah(e, t = dn) {
  if (!Array.isArray(e) || e.length < 1)
    throw new Error("data should be array of at least 1 element");
  return e.length === 1 ? xh(Zf(e[0])) : Array.from(e).reverse().reduce((a, n) => t(n, a));
}
const Oh = (e, t = dn) => [0, ...e, e.length].reduce((a, n) => t(a, n)), Ih = Pc(250), yr = (e) => Re(B1(e)) & Ih, ji = (e) => Re(ks(e)), Nh = Ss(BigInt("14474011154664525231415395255581126252639794253786371766033694892385558855681")), jf = Ss(BigInt("3618502788666131213697322783095070105623107215331596699973092056135872020481"));
function Ui(e, t, a) {
  const n = e.fromBytes(ks(hf(`${t}${a}`)));
  return e.create(n);
}
function Uf(e, t, a, n = 0) {
  const r = [], c = [];
  for (let i = 0; i < a; i++)
    r.push(Ui(e, `${t}x`, n * a + i)), c.push(Ui(e, `${t}y`, n * a + i));
  if ((/* @__PURE__ */ new Set([...r, ...c])).size !== 2 * a)
    throw new Error("X and Y values are not distinct");
  return r.map((i) => c.map((s) => e.inv(e.sub(i, s))));
}
const Rh = [
  [3, 1, 1],
  [1, -1, 1],
  [1, 1, -2]
].map((e) => e.map(BigInt));
function Ns(e, t) {
  if (Dc(e.Fp), !Number.isSafeInteger(e.rate) || !Number.isSafeInteger(e.capacity))
    throw new Error(`Wrong poseidon opts: ${e}`);
  const a = e.rate + e.capacity, n = e.roundsFull + e.roundsPartial, r = [];
  for (let i = 0; i < n; i++) {
    const s = [];
    for (let o = 0; o < a; o++)
      s.push(Ui(e.Fp, "Hades", a * i + o));
    r.push(s);
  }
  const c = Ef({
    ...e,
    t: a,
    sboxPower: 3,
    reversePartialPowIdx: !0,
    mds: t,
    roundConstants: r
  });
  return c.m = a, c.rate = e.rate, c.capacity = e.capacity, c;
}
function Ph(e, t = 0) {
  const a = e.rate + e.capacity;
  if (!Number.isSafeInteger(t))
    throw new Error(`Wrong mdsAttempt=${t}`);
  return Ns(e, Uf(e.Fp, "HadesMDS", a, t));
}
const wr = Ns({ Fp: jf, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, Rh);
function Mf(e, t, a = wr) {
  return a([e, t, 2n])[0];
}
function Lh(e, t, a = wr) {
  return xs(Mf(Re(e), Re(t), a));
}
function $h(e, t = wr) {
  return t([e, 0n, 1n])[0];
}
function qt(e, t = wr) {
  const { m: a, rate: n } = t;
  if (!Array.isArray(e))
    throw new Error("bigint array expected in values");
  const r = Array.from(e);
  for (r.push(1n); r.length % n !== 0; )
    r.push(0n);
  let c = new Array(a).fill(0n);
  for (let i = 0; i < r.length; i += n) {
    for (let s = 0; s < n; s++)
      c[s] += r[i + s];
    c = t(c);
  }
  return c[0];
}
const Dh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CURVE: vh,
  Fp251: jf,
  Fp253: Nh,
  ProjectivePoint: $a,
  Signature: Lf,
  _poseidonMDS: Uf,
  _starkCurve: _h,
  computeHashOnElements: Oh,
  ethSigToPrivate: Eh,
  getAccountPath: Th,
  getPublicKey: Pf,
  getSharedSecret: yh,
  getStarkKey: Is,
  grindKey: Df,
  hashChain: Ah,
  keccak: yr,
  pedersen: dn,
  poseidonBasic: Ns,
  poseidonCreate: Ph,
  poseidonHash: Mf,
  poseidonHashFunc: Lh,
  poseidonHashMany: qt,
  poseidonHashSingle: $h,
  poseidonSmall: wr,
  sign: En,
  utils: As,
  verify: wh
}, Symbol.toStringTag, { value: "Module" }));
var kn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Hf(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function zf(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var a = function n() {
      if (this instanceof n) {
        var r = [null];
        r.push.apply(r, arguments);
        var c = Function.bind.apply(t, r);
        return new c();
      }
      return t.apply(this, arguments);
    };
    a.prototype = t.prototype;
  } else
    a = {};
  return Object.defineProperty(a, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var r = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(a, n, r.get ? r : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), a;
}
var we = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof we < "u" && we, Oe = {
  searchParams: "URLSearchParams" in we,
  iterable: "Symbol" in we && "iterator" in Symbol,
  blob: "FileReader" in we && "Blob" in we && function() {
    try {
      return new Blob(), !0;
    } catch {
      return !1;
    }
  }(),
  formData: "FormData" in we,
  arrayBuffer: "ArrayBuffer" in we
};
function Bh(e) {
  return e && DataView.prototype.isPrototypeOf(e);
}
if (Oe.arrayBuffer)
  var Zh = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ], jh = ArrayBuffer.isView || function(e) {
    return e && Zh.indexOf(Object.prototype.toString.call(e)) > -1;
  };
function vr(e) {
  if (typeof e != "string" && (e = String(e)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || e === "")
    throw new TypeError('Invalid character in header field name: "' + e + '"');
  return e.toLowerCase();
}
function Rs(e) {
  return typeof e != "string" && (e = String(e)), e;
}
function Ps(e) {
  var t = {
    next: function() {
      var a = e.shift();
      return { done: a === void 0, value: a };
    }
  };
  return Oe.iterable && (t[Symbol.iterator] = function() {
    return t;
  }), t;
}
function le(e) {
  this.map = {}, e instanceof le ? e.forEach(function(t, a) {
    this.append(a, t);
  }, this) : Array.isArray(e) ? e.forEach(function(t) {
    this.append(t[0], t[1]);
  }, this) : e && Object.getOwnPropertyNames(e).forEach(function(t) {
    this.append(t, e[t]);
  }, this);
}
le.prototype.append = function(e, t) {
  e = vr(e), t = Rs(t);
  var a = this.map[e];
  this.map[e] = a ? a + ", " + t : t;
};
le.prototype.delete = function(e) {
  delete this.map[vr(e)];
};
le.prototype.get = function(e) {
  return e = vr(e), this.has(e) ? this.map[e] : null;
};
le.prototype.has = function(e) {
  return this.map.hasOwnProperty(vr(e));
};
le.prototype.set = function(e, t) {
  this.map[vr(e)] = Rs(t);
};
le.prototype.forEach = function(e, t) {
  for (var a in this.map)
    this.map.hasOwnProperty(a) && e.call(t, this.map[a], a, this);
};
le.prototype.keys = function() {
  var e = [];
  return this.forEach(function(t, a) {
    e.push(a);
  }), Ps(e);
};
le.prototype.values = function() {
  var e = [];
  return this.forEach(function(t) {
    e.push(t);
  }), Ps(e);
};
le.prototype.entries = function() {
  var e = [];
  return this.forEach(function(t, a) {
    e.push([a, t]);
  }), Ps(e);
};
Oe.iterable && (le.prototype[Symbol.iterator] = le.prototype.entries);
function ci(e) {
  if (e.bodyUsed)
    return Promise.reject(new TypeError("Already read"));
  e.bodyUsed = !0;
}
function Ff(e) {
  return new Promise(function(t, a) {
    e.onload = function() {
      t(e.result);
    }, e.onerror = function() {
      a(e.error);
    };
  });
}
function Uh(e) {
  var t = new FileReader(), a = Ff(t);
  return t.readAsArrayBuffer(e), a;
}
function Mh(e) {
  var t = new FileReader(), a = Ff(t);
  return t.readAsText(e), a;
}
function Hh(e) {
  for (var t = new Uint8Array(e), a = new Array(t.length), n = 0; n < t.length; n++)
    a[n] = String.fromCharCode(t[n]);
  return a.join("");
}
function Mo(e) {
  if (e.slice)
    return e.slice(0);
  var t = new Uint8Array(e.byteLength);
  return t.set(new Uint8Array(e)), t.buffer;
}
function Vf() {
  return this.bodyUsed = !1, this._initBody = function(e) {
    this.bodyUsed = this.bodyUsed, this._bodyInit = e, e ? typeof e == "string" ? this._bodyText = e : Oe.blob && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : Oe.formData && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : Oe.searchParams && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : Oe.arrayBuffer && Oe.blob && Bh(e) ? (this._bodyArrayBuffer = Mo(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : Oe.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(e) || jh(e)) ? this._bodyArrayBuffer = Mo(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = "", this.headers.get("content-type") || (typeof e == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : Oe.searchParams && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
  }, Oe.blob && (this.blob = function() {
    var e = ci(this);
    if (e)
      return e;
    if (this._bodyBlob)
      return Promise.resolve(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as blob");
    return Promise.resolve(new Blob([this._bodyText]));
  }, this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var e = ci(this);
      return e || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
        this._bodyArrayBuffer.buffer.slice(
          this._bodyArrayBuffer.byteOffset,
          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
        )
      ) : Promise.resolve(this._bodyArrayBuffer));
    } else
      return this.blob().then(Uh);
  }), this.text = function() {
    var e = ci(this);
    if (e)
      return e;
    if (this._bodyBlob)
      return Mh(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(Hh(this._bodyArrayBuffer));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as text");
    return Promise.resolve(this._bodyText);
  }, Oe.formData && (this.formData = function() {
    return this.text().then(Vh);
  }), this.json = function() {
    return this.text().then(JSON.parse);
  }, this;
}
var zh = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
function Fh(e) {
  var t = e.toUpperCase();
  return zh.indexOf(t) > -1 ? t : e;
}
function pa(e, t) {
  if (!(this instanceof pa))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  t = t || {};
  var a = t.body;
  if (e instanceof pa) {
    if (e.bodyUsed)
      throw new TypeError("Already read");
    this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new le(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, !a && e._bodyInit != null && (a = e._bodyInit, e.bodyUsed = !0);
  } else
    this.url = String(e);
  if (this.credentials = t.credentials || this.credentials || "same-origin", (t.headers || !this.headers) && (this.headers = new le(t.headers)), this.method = Fh(t.method || this.method || "GET"), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && a)
    throw new TypeError("Body not allowed for GET or HEAD requests");
  if (this._initBody(a), (this.method === "GET" || this.method === "HEAD") && (t.cache === "no-store" || t.cache === "no-cache")) {
    var n = /([?&])_=[^&]*/;
    if (n.test(this.url))
      this.url = this.url.replace(n, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
    else {
      var r = /\?/;
      this.url += (r.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
    }
  }
}
pa.prototype.clone = function() {
  return new pa(this, { body: this._bodyInit });
};
function Vh(e) {
  var t = new FormData();
  return e.trim().split("&").forEach(function(a) {
    if (a) {
      var n = a.split("="), r = n.shift().replace(/\+/g, " "), c = n.join("=").replace(/\+/g, " ");
      t.append(decodeURIComponent(r), decodeURIComponent(c));
    }
  }), t;
}
function qh(e) {
  var t = new le(), a = e.replace(/\r?\n[\t ]+/g, " ");
  return a.split("\r").map(function(n) {
    return n.indexOf(`
`) === 0 ? n.substr(1, n.length) : n;
  }).forEach(function(n) {
    var r = n.split(":"), c = r.shift().trim();
    if (c) {
      var i = r.join(":").trim();
      t.append(c, i);
    }
  }), t;
}
Vf.call(pa.prototype);
function ot(e, t) {
  if (!(this instanceof ot))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  t || (t = {}), this.type = "default", this.status = t.status === void 0 ? 200 : t.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = t.statusText === void 0 ? "" : "" + t.statusText, this.headers = new le(t.headers), this.url = t.url || "", this._initBody(e);
}
Vf.call(ot.prototype);
ot.prototype.clone = function() {
  return new ot(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new le(this.headers),
    url: this.url
  });
};
ot.error = function() {
  var e = new ot(null, { status: 0, statusText: "" });
  return e.type = "error", e;
};
var Wh = [301, 302, 303, 307, 308];
ot.redirect = function(e, t) {
  if (Wh.indexOf(t) === -1)
    throw new RangeError("Invalid status code");
  return new ot(null, { status: t, headers: { location: e } });
};
var ca = we.DOMException;
try {
  new ca();
} catch {
  ca = function(t, a) {
    this.message = t, this.name = a;
    var n = Error(t);
    this.stack = n.stack;
  }, ca.prototype = Object.create(Error.prototype), ca.prototype.constructor = ca;
}
function qf(e, t) {
  return new Promise(function(a, n) {
    var r = new pa(e, t);
    if (r.signal && r.signal.aborted)
      return n(new ca("Aborted", "AbortError"));
    var c = new XMLHttpRequest();
    function i() {
      c.abort();
    }
    c.onload = function() {
      var o = {
        status: c.status,
        statusText: c.statusText,
        headers: qh(c.getAllResponseHeaders() || "")
      };
      o.url = "responseURL" in c ? c.responseURL : o.headers.get("X-Request-URL");
      var d = "response" in c ? c.response : c.responseText;
      setTimeout(function() {
        a(new ot(d, o));
      }, 0);
    }, c.onerror = function() {
      setTimeout(function() {
        n(new TypeError("Network request failed"));
      }, 0);
    }, c.ontimeout = function() {
      setTimeout(function() {
        n(new TypeError("Network request failed"));
      }, 0);
    }, c.onabort = function() {
      setTimeout(function() {
        n(new ca("Aborted", "AbortError"));
      }, 0);
    };
    function s(o) {
      try {
        return o === "" && we.location.href ? we.location.href : o;
      } catch {
        return o;
      }
    }
    c.open(r.method, s(r.url), !0), r.credentials === "include" ? c.withCredentials = !0 : r.credentials === "omit" && (c.withCredentials = !1), "responseType" in c && (Oe.blob ? c.responseType = "blob" : Oe.arrayBuffer && r.headers.get("Content-Type") && r.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (c.responseType = "arraybuffer")), t && typeof t.headers == "object" && !(t.headers instanceof le) ? Object.getOwnPropertyNames(t.headers).forEach(function(o) {
      c.setRequestHeader(o, Rs(t.headers[o]));
    }) : r.headers.forEach(function(o, d) {
      c.setRequestHeader(d, o);
    }), r.signal && (r.signal.addEventListener("abort", i), c.onreadystatechange = function() {
      c.readyState === 4 && r.signal.removeEventListener("abort", i);
    }), c.send(typeof r._bodyInit > "u" ? null : r._bodyInit);
  });
}
qf.polyfill = !0;
we.fetch || (we.fetch = qf, we.Headers = le, we.Request = pa, we.Response = ot);
var Kh = self.fetch.bind(self);
const Gh = /* @__PURE__ */ Hf(Kh);
function xr(e) {
  return Yh.test(e);
}
var Yh = /^-?[0-9]+$/;
function Wf(e) {
  return Xh.test(e);
}
var Xh = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
function Jh(e, t) {
  var a = parseFloat(e), n = String(a), r = Ho(e), c = Ho(n);
  if (r === c)
    return !0;
  if (t?.approx === !0) {
    var i = 14;
    if (!xr(e) && c.length >= i && r.startsWith(c.substring(0, i)))
      return !0;
  }
  return !1;
}
var Tn = /* @__PURE__ */ function(e) {
  return e.underflow = "underflow", e.overflow = "overflow", e.truncate_integer = "truncate_integer", e.truncate_float = "truncate_float", e;
}({});
function Qh(e) {
  if (!Jh(e, {
    approx: !1
  })) {
    if (xr(e))
      return Tn.truncate_integer;
    var t = parseFloat(e);
    return isFinite(t) ? t === 0 ? Tn.underflow : Tn.truncate_float : Tn.overflow;
  }
}
function Ho(e) {
  return e.replace(e2, "").replace(a2, "").replace(n2, "").replace(t2, "");
}
var e2 = /[eE][+-]?\d+$/, t2 = /^-?(0*)?/, a2 = /\./, n2 = /0+$/;
function Ya(e) {
  "@babel/helpers - typeof";
  return Ya = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ya(e);
}
function r2(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function zo(e, t) {
  for (var a = 0; a < t.length; a++) {
    var n = t[a];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, Kf(n.key), n);
  }
}
function c2(e, t, a) {
  return t && zo(e.prototype, t), a && zo(e, a), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function i2(e, t, a) {
  return t = Kf(t), t in e ? Object.defineProperty(e, t, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = a, e;
}
function Kf(e) {
  var t = s2(e, "string");
  return Ya(t) === "symbol" ? t : String(t);
}
function s2(e, t) {
  if (Ya(e) !== "object" || e === null)
    return e;
  var a = e[Symbol.toPrimitive];
  if (a !== void 0) {
    var n = a.call(e, t || "default");
    if (Ya(n) !== "object")
      return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var o2 = /* @__PURE__ */ function() {
  function e(t) {
    if (r2(this, e), i2(this, "isLosslessNumber", !0), !Wf(t))
      throw new Error('Invalid number (value: "' + t + '")');
    this.value = t;
  }
  return c2(e, [{
    key: "valueOf",
    value: function() {
      var a = Qh(this.value);
      if (a === void 0 || a === Tn.truncate_float)
        return parseFloat(this.value);
      if (xr(this.value))
        return BigInt(this.value);
      throw new Error("Cannot safely convert to number: " + "the value '".concat(this.value, "' would ").concat(a, " and become ").concat(parseFloat(this.value)));
    }
    /**
     * Get the value of the LosslessNumber as string.
     */
  }, {
    key: "toString",
    value: function() {
      return this.value;
    }
    // Note: we do NOT implement a .toJSON() method, and you should not implement
    // or use that, it cannot safely turn the numeric value in the string into
    // stringified JSON since it has to be parsed into a number first.
  }]), e;
}();
function d2(e) {
  return e && Ya(e) === "object" && e.isLosslessNumber === !0 || !1;
}
function f2(e) {
  return new o2(e);
}
function l2(e) {
  return xr(e) ? BigInt(e) : parseFloat(e);
}
function Mi(e) {
  "@babel/helpers - typeof";
  return Mi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Mi(e);
}
function u2(e, t) {
  return Ls({
    "": e
  }, "", e, t);
}
function Ls(e, t, a, n) {
  return Array.isArray(a) ? n.call(e, t, h2(a, n)) : a && Mi(a) === "object" && !d2(a) ? n.call(e, t, b2(a, n)) : n.call(e, t, a);
}
function b2(e, t) {
  return Object.keys(e).forEach(function(a) {
    var n = Ls(e, a, e[a], t);
    n !== void 0 ? e[a] = n : delete e[a];
  }), e;
}
function h2(e, t) {
  for (var a = 0; a < e.length; a++)
    e[a] = Ls(e, a + "", e[a], t);
  return e;
}
function Hi(e) {
  "@babel/helpers - typeof";
  return Hi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Hi(e);
}
function ii(e) {
  return _2(e) || g2(e) || m2(e) || p2();
}
function p2() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function m2(e, t) {
  if (e) {
    if (typeof e == "string")
      return zi(e, t);
    var a = Object.prototype.toString.call(e).slice(8, -1);
    if (a === "Object" && e.constructor && (a = e.constructor.name), a === "Map" || a === "Set")
      return Array.from(e);
    if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a))
      return zi(e, t);
  }
}
function g2(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function _2(e) {
  if (Array.isArray(e))
    return zi(e);
}
function zi(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var a = 0, n = new Array(t); a < t; a++)
    n[a] = e[a];
  return n;
}
function Gf(e, t) {
  var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : f2, n = 0, r = s();
  return h(r), m(), t ? u2(r, t) : r;
  function c() {
    if (e.charCodeAt(n) === k2) {
      n++, d();
      for (var B = {}, w = !0; n < e.length && e.charCodeAt(n) !== Vo; ) {
        w ? w = !1 : (b(), d());
        var A = n, F = f();
        F === void 0 && S(), d(), u();
        var Q = s();
        Q === void 0 && j(), Object.prototype.hasOwnProperty.call(B, F) && !Fi(Q, B[F]) && y(F, A + 1), B[F] = Q;
      }
      return e.charCodeAt(n) !== Vo && O(), n++, B;
    }
  }
  function i() {
    if (e.charCodeAt(n) === T2) {
      n++, d();
      for (var B = [], w = !0; n < e.length && e.charCodeAt(n) !== qo; ) {
        w ? w = !1 : b();
        var A = s();
        p(A), B.push(A);
      }
      return e.charCodeAt(n) !== qo && E(), n++, B;
    }
  }
  function s() {
    var B, w, A, F, Q, ae;
    d();
    var pe = (B = (w = (A = (F = (Q = (ae = f()) !== null && ae !== void 0 ? ae : l()) !== null && Q !== void 0 ? Q : c()) !== null && F !== void 0 ? F : i()) !== null && A !== void 0 ? A : o("true", !0)) !== null && w !== void 0 ? w : o("false", !1)) !== null && B !== void 0 ? B : o("null", null);
    return d(), pe;
  }
  function o(B, w) {
    if (e.slice(n, n + B.length) === B)
      return n += B.length, w;
  }
  function d() {
    for (; y2(e.charCodeAt(n)); )
      n++;
  }
  function f() {
    if (e.charCodeAt(n) === si) {
      n++;
      for (var B = ""; n < e.length && e.charCodeAt(n) !== si; ) {
        if (e.charCodeAt(n) === E2) {
          var w = e[n + 1], A = x2[w];
          A !== void 0 ? (B += A, n++) : w === "u" ? jr(e.charCodeAt(n + 2)) && jr(e.charCodeAt(n + 3)) && jr(e.charCodeAt(n + 4)) && jr(e.charCodeAt(n + 5)) ? (B += String.fromCharCode(parseInt(e.slice(n + 2, n + 6), 16)), n += 5) : C(n) : I(n);
        } else
          v2(e.charCodeAt(n)) ? B += e[n] : _(e[n]);
        n++;
      }
      return v(), n++, B;
    }
  }
  function l() {
    var B = n;
    if (e.charCodeAt(n) === Wo && (n++, g(B)), e.charCodeAt(n) === $s)
      n++;
    else if (w2(e.charCodeAt(n)))
      for (n++; Ur(e.charCodeAt(n)); )
        n++;
    if (e.charCodeAt(n) === P2)
      for (n++, g(B); Ur(e.charCodeAt(n)); )
        n++;
    if (e.charCodeAt(n) === Z2 || e.charCodeAt(n) === B2)
      for (n++, (e.charCodeAt(n) === Wo || e.charCodeAt(n) === I2) && n++, g(B); Ur(e.charCodeAt(n)); )
        n++;
    if (n > B)
      return a(e.slice(B, n));
  }
  function b() {
    if (e.charCodeAt(n) !== R2)
      throw new SyntaxError("Comma ',' expected after value ".concat(ce()));
    n++;
  }
  function u() {
    if (e.charCodeAt(n) !== L2)
      throw new SyntaxError("Colon ':' expected after property name ".concat(ce()));
    n++;
  }
  function h(B) {
    if (B === void 0)
      throw new SyntaxError("JSON value expected ".concat(ce()));
  }
  function p(B) {
    if (B === void 0)
      throw new SyntaxError("Array item expected ".concat(ce()));
  }
  function m() {
    if (n < e.length)
      throw new SyntaxError("Expected end of input ".concat(ce()));
  }
  function g(B) {
    if (!Ur(e.charCodeAt(n))) {
      var w = e.slice(B, n);
      throw new SyntaxError("Invalid number '".concat(w, "', expecting a digit ").concat(ce()));
    }
  }
  function v() {
    if (e.charCodeAt(n) !== si)
      throw new SyntaxError(`End of string '"' expected `.concat(ce()));
  }
  function S() {
    throw new SyntaxError("Quoted object key expected ".concat(ce()));
  }
  function y(B, w) {
    throw new SyntaxError("Duplicate key '".concat(B, "' encountered at position ").concat(w));
  }
  function O() {
    throw new SyntaxError("Quoted object key or end of object '}' expected ".concat(ce()));
  }
  function E() {
    throw new SyntaxError("Array item or end of array ']' expected ".concat(ce()));
  }
  function _(B) {
    throw new SyntaxError("Invalid character '".concat(B, "' ").concat(x()));
  }
  function I(B) {
    var w = e.slice(B, B + 2);
    throw new SyntaxError("Invalid escape character '".concat(w, "' ").concat(x()));
  }
  function j() {
    throw new SyntaxError("Object value expected after ':' ".concat(x()));
  }
  function C(B) {
    for (var w = B + 2; /\w/.test(e[w]); )
      w++;
    var A = e.slice(B, w);
    throw new SyntaxError("Invalid unicode character '".concat(A, "' ").concat(x()));
  }
  function x() {
    return "at position ".concat(n);
  }
  function J() {
    return n < e.length ? "but got '".concat(e[n], "'") : "but reached end of input";
  }
  function ce() {
    return J() + " " + x();
  }
}
function y2(e) {
  return e === S2 || e === C2 || e === A2 || e === O2;
}
function jr(e) {
  return e >= $s && e <= Ds || e >= $2 && e <= j2 || e >= D2 && e <= U2;
}
function Ur(e) {
  return e >= $s && e <= Ds;
}
function w2(e) {
  return e >= N2 && e <= Ds;
}
function v2(e) {
  return e >= 32 && e <= 1114111;
}
function Fi(e, t) {
  if (e === t)
    return !0;
  if (Array.isArray(e) && Array.isArray(t))
    return e.length === t.length && e.every(function(n, r) {
      return Fi(n, t[r]);
    });
  if (Fo(e) && Fo(t)) {
    var a = ii(new Set([].concat(ii(Object.keys(e)), ii(Object.keys(t)))));
    return a.every(function(n) {
      return Fi(e[n], t[n]);
    });
  }
  return !1;
}
function Fo(e) {
  return Hi(e) === "object" && e !== null;
}
var x2 = {
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: `
`,
  r: "\r",
  t: "	"
  // note that \u is handled separately in parseString()
}, E2 = 92, k2 = 123, Vo = 125, T2 = 91, qo = 93, S2 = 32, C2 = 10, A2 = 9, O2 = 13, si = 34, I2 = 43, Wo = 45, $s = 48, N2 = 49, Ds = 57, R2 = 44, P2 = 46, L2 = 58, $2 = 65, D2 = 97, B2 = 69, Z2 = 101, j2 = 70, U2 = 102;
function nc(e) {
  "@babel/helpers - typeof";
  return nc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, nc(e);
}
function Yf(e, t, a, n) {
  var r = M2(a), c = typeof t == "function" ? t.call({
    "": e
  }, "", e) : e;
  return i(c, "");
  function i(f, l) {
    if (Array.isArray(n)) {
      var b = n.find(function(h) {
        return h.test(f);
      });
      if (b) {
        var u = b.stringify(f);
        if (typeof u != "string" || !Wf(u))
          throw new Error("Invalid JSON number: output of a number stringifier must be a string containing a JSON number " + "(output: ".concat(u, ")"));
        return u;
      }
    }
    if (typeof f == "boolean" || typeof f == "number" || typeof f == "string" || f === null || f instanceof Date || f instanceof Boolean || f instanceof Number || f instanceof String)
      return JSON.stringify(f);
    if (f && f.isLosslessNumber || typeof f == "bigint")
      return f.toString();
    if (Array.isArray(f))
      return s(f, l);
    if (f && nc(f) === "object")
      return o(f, l);
  }
  function s(f, l) {
    if (f.length === 0)
      return "[]";
    for (var b = r ? l + r : void 0, u = r ? `[
` : "[", h = 0; h < f.length; h++) {
      var p = typeof t == "function" ? t.call(f, String(h), f[h]) : f[h];
      r && (u += b), typeof p < "u" && typeof p != "function" ? u += i(p, b) : u += "null", h < f.length - 1 && (u += r ? `,
` : ",");
    }
    return u += r ? `
` + l + "]" : "]", u;
  }
  function o(f, l) {
    if (typeof f.toJSON == "function")
      return Yf(f.toJSON(), t, a, void 0);
    var b = Array.isArray(t) ? t.map(String) : Object.keys(f);
    if (b.length === 0)
      return "{}";
    var u = r ? l + r : void 0, h = !0, p = r ? `{
` : "{";
    return b.forEach(function(m) {
      var g = typeof t == "function" ? t.call(f, m, f[m]) : f[m];
      if (d(m, g)) {
        h ? h = !1 : p += r ? `,
` : ",";
        var v = JSON.stringify(m);
        p += r ? u + v + ": " : v + ":", p += i(g, u);
      }
    }), p += r ? `
` + l + "}" : "}", p;
  }
  function d(f, l) {
    return typeof l < "u" && typeof l != "function" && nc(l) !== "symbol";
  }
}
function M2(e) {
  if (typeof e == "number")
    return " ".repeat(e);
  if (typeof e == "string" && e !== "")
    return e;
}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const H2 = 4, Ko = 0, Go = 1, z2 = 2;
function fn(e) {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}
const F2 = 0, Xf = 1, V2 = 2, q2 = 3, W2 = 258, Bs = 29, Er = 256, jn = Er + 1 + Bs, za = 30, Zs = 19, Jf = 2 * jn + 1, oa = 15, oi = 16, K2 = 7, js = 256, Qf = 16, el = 17, tl = 18, Vi = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), Wr = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), G2 = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), al = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Y2 = 512, yt = new Array((jn + 2) * 2);
fn(yt);
const An = new Array(za * 2);
fn(An);
const Un = new Array(Y2);
fn(Un);
const Mn = new Array(W2 - q2 + 1);
fn(Mn);
const Us = new Array(Bs);
fn(Us);
const rc = new Array(za);
fn(rc);
function di(e, t, a, n, r) {
  this.static_tree = e, this.extra_bits = t, this.extra_base = a, this.elems = n, this.max_length = r, this.has_stree = e && e.length;
}
let nl, rl, cl;
function fi(e, t) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
}
const il = (e) => e < 256 ? Un[e] : Un[256 + (e >>> 7)], Hn = (e, t) => {
  e.pending_buf[e.pending++] = t & 255, e.pending_buf[e.pending++] = t >>> 8 & 255;
}, Ne = (e, t, a) => {
  e.bi_valid > oi - a ? (e.bi_buf |= t << e.bi_valid & 65535, Hn(e, e.bi_buf), e.bi_buf = t >> oi - e.bi_valid, e.bi_valid += a - oi) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += a);
}, at = (e, t, a) => {
  Ne(
    e,
    a[t * 2],
    a[t * 2 + 1]
    /*.Len*/
  );
}, sl = (e, t) => {
  let a = 0;
  do
    a |= e & 1, e >>>= 1, a <<= 1;
  while (--t > 0);
  return a >>> 1;
}, X2 = (e) => {
  e.bi_valid === 16 ? (Hn(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, J2 = (e, t) => {
  const a = t.dyn_tree, n = t.max_code, r = t.stat_desc.static_tree, c = t.stat_desc.has_stree, i = t.stat_desc.extra_bits, s = t.stat_desc.extra_base, o = t.stat_desc.max_length;
  let d, f, l, b, u, h, p = 0;
  for (b = 0; b <= oa; b++)
    e.bl_count[b] = 0;
  for (a[e.heap[e.heap_max] * 2 + 1] = 0, d = e.heap_max + 1; d < Jf; d++)
    f = e.heap[d], b = a[a[f * 2 + 1] * 2 + 1] + 1, b > o && (b = o, p++), a[f * 2 + 1] = b, !(f > n) && (e.bl_count[b]++, u = 0, f >= s && (u = i[f - s]), h = a[f * 2], e.opt_len += h * (b + u), c && (e.static_len += h * (r[f * 2 + 1] + u)));
  if (p !== 0) {
    do {
      for (b = o - 1; e.bl_count[b] === 0; )
        b--;
      e.bl_count[b]--, e.bl_count[b + 1] += 2, e.bl_count[o]--, p -= 2;
    } while (p > 0);
    for (b = o; b !== 0; b--)
      for (f = e.bl_count[b]; f !== 0; )
        l = e.heap[--d], !(l > n) && (a[l * 2 + 1] !== b && (e.opt_len += (b - a[l * 2 + 1]) * a[l * 2], a[l * 2 + 1] = b), f--);
  }
}, ol = (e, t, a) => {
  const n = new Array(oa + 1);
  let r = 0, c, i;
  for (c = 1; c <= oa; c++)
    r = r + a[c - 1] << 1, n[c] = r;
  for (i = 0; i <= t; i++) {
    let s = e[i * 2 + 1];
    s !== 0 && (e[i * 2] = sl(n[s]++, s));
  }
}, Q2 = () => {
  let e, t, a, n, r;
  const c = new Array(oa + 1);
  for (a = 0, n = 0; n < Bs - 1; n++)
    for (Us[n] = a, e = 0; e < 1 << Vi[n]; e++)
      Mn[a++] = n;
  for (Mn[a - 1] = n, r = 0, n = 0; n < 16; n++)
    for (rc[n] = r, e = 0; e < 1 << Wr[n]; e++)
      Un[r++] = n;
  for (r >>= 7; n < za; n++)
    for (rc[n] = r << 7, e = 0; e < 1 << Wr[n] - 7; e++)
      Un[256 + r++] = n;
  for (t = 0; t <= oa; t++)
    c[t] = 0;
  for (e = 0; e <= 143; )
    yt[e * 2 + 1] = 8, e++, c[8]++;
  for (; e <= 255; )
    yt[e * 2 + 1] = 9, e++, c[9]++;
  for (; e <= 279; )
    yt[e * 2 + 1] = 7, e++, c[7]++;
  for (; e <= 287; )
    yt[e * 2 + 1] = 8, e++, c[8]++;
  for (ol(yt, jn + 1, c), e = 0; e < za; e++)
    An[e * 2 + 1] = 5, An[e * 2] = sl(e, 5);
  nl = new di(yt, Vi, Er + 1, jn, oa), rl = new di(An, Wr, 0, za, oa), cl = new di(new Array(0), G2, 0, Zs, K2);
}, dl = (e) => {
  let t;
  for (t = 0; t < jn; t++)
    e.dyn_ltree[t * 2] = 0;
  for (t = 0; t < za; t++)
    e.dyn_dtree[t * 2] = 0;
  for (t = 0; t < Zs; t++)
    e.bl_tree[t * 2] = 0;
  e.dyn_ltree[js * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
}, fl = (e) => {
  e.bi_valid > 8 ? Hn(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, Yo = (e, t, a, n) => {
  const r = t * 2, c = a * 2;
  return e[r] < e[c] || e[r] === e[c] && n[t] <= n[a];
}, li = (e, t, a) => {
  const n = e.heap[a];
  let r = a << 1;
  for (; r <= e.heap_len && (r < e.heap_len && Yo(t, e.heap[r + 1], e.heap[r], e.depth) && r++, !Yo(t, n, e.heap[r], e.depth)); )
    e.heap[a] = e.heap[r], a = r, r <<= 1;
  e.heap[a] = n;
}, Xo = (e, t, a) => {
  let n, r, c = 0, i, s;
  if (e.sym_next !== 0)
    do
      n = e.pending_buf[e.sym_buf + c++] & 255, n += (e.pending_buf[e.sym_buf + c++] & 255) << 8, r = e.pending_buf[e.sym_buf + c++], n === 0 ? at(e, r, t) : (i = Mn[r], at(e, i + Er + 1, t), s = Vi[i], s !== 0 && (r -= Us[i], Ne(e, r, s)), n--, i = il(n), at(e, i, a), s = Wr[i], s !== 0 && (n -= rc[i], Ne(e, n, s)));
    while (c < e.sym_next);
  at(e, js, t);
}, qi = (e, t) => {
  const a = t.dyn_tree, n = t.stat_desc.static_tree, r = t.stat_desc.has_stree, c = t.stat_desc.elems;
  let i, s, o = -1, d;
  for (e.heap_len = 0, e.heap_max = Jf, i = 0; i < c; i++)
    a[i * 2] !== 0 ? (e.heap[++e.heap_len] = o = i, e.depth[i] = 0) : a[i * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    d = e.heap[++e.heap_len] = o < 2 ? ++o : 0, a[d * 2] = 1, e.depth[d] = 0, e.opt_len--, r && (e.static_len -= n[d * 2 + 1]);
  for (t.max_code = o, i = e.heap_len >> 1; i >= 1; i--)
    li(e, a, i);
  d = c;
  do
    i = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], li(
      e,
      a,
      1
      /*SMALLEST*/
    ), s = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = i, e.heap[--e.heap_max] = s, a[d * 2] = a[i * 2] + a[s * 2], e.depth[d] = (e.depth[i] >= e.depth[s] ? e.depth[i] : e.depth[s]) + 1, a[i * 2 + 1] = a[s * 2 + 1] = d, e.heap[
      1
      /*SMALLEST*/
    ] = d++, li(
      e,
      a,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], J2(e, t), ol(a, o, e.bl_count);
}, Jo = (e, t, a) => {
  let n, r = -1, c, i = t[0 * 2 + 1], s = 0, o = 7, d = 4;
  for (i === 0 && (o = 138, d = 3), t[(a + 1) * 2 + 1] = 65535, n = 0; n <= a; n++)
    c = i, i = t[(n + 1) * 2 + 1], !(++s < o && c === i) && (s < d ? e.bl_tree[c * 2] += s : c !== 0 ? (c !== r && e.bl_tree[c * 2]++, e.bl_tree[Qf * 2]++) : s <= 10 ? e.bl_tree[el * 2]++ : e.bl_tree[tl * 2]++, s = 0, r = c, i === 0 ? (o = 138, d = 3) : c === i ? (o = 6, d = 3) : (o = 7, d = 4));
}, Qo = (e, t, a) => {
  let n, r = -1, c, i = t[0 * 2 + 1], s = 0, o = 7, d = 4;
  for (i === 0 && (o = 138, d = 3), n = 0; n <= a; n++)
    if (c = i, i = t[(n + 1) * 2 + 1], !(++s < o && c === i)) {
      if (s < d)
        do
          at(e, c, e.bl_tree);
        while (--s !== 0);
      else
        c !== 0 ? (c !== r && (at(e, c, e.bl_tree), s--), at(e, Qf, e.bl_tree), Ne(e, s - 3, 2)) : s <= 10 ? (at(e, el, e.bl_tree), Ne(e, s - 3, 3)) : (at(e, tl, e.bl_tree), Ne(e, s - 11, 7));
      s = 0, r = c, i === 0 ? (o = 138, d = 3) : c === i ? (o = 6, d = 3) : (o = 7, d = 4);
    }
}, e6 = (e) => {
  let t;
  for (Jo(e, e.dyn_ltree, e.l_desc.max_code), Jo(e, e.dyn_dtree, e.d_desc.max_code), qi(e, e.bl_desc), t = Zs - 1; t >= 3 && e.bl_tree[al[t] * 2 + 1] === 0; t--)
    ;
  return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}, t6 = (e, t, a, n) => {
  let r;
  for (Ne(e, t - 257, 5), Ne(e, a - 1, 5), Ne(e, n - 4, 4), r = 0; r < n; r++)
    Ne(e, e.bl_tree[al[r] * 2 + 1], 3);
  Qo(e, e.dyn_ltree, t - 1), Qo(e, e.dyn_dtree, a - 1);
}, a6 = (e) => {
  let t = 4093624447, a;
  for (a = 0; a <= 31; a++, t >>>= 1)
    if (t & 1 && e.dyn_ltree[a * 2] !== 0)
      return Ko;
  if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0)
    return Go;
  for (a = 32; a < Er; a++)
    if (e.dyn_ltree[a * 2] !== 0)
      return Go;
  return Ko;
};
let ed = !1;
const n6 = (e) => {
  ed || (Q2(), ed = !0), e.l_desc = new fi(e.dyn_ltree, nl), e.d_desc = new fi(e.dyn_dtree, rl), e.bl_desc = new fi(e.bl_tree, cl), e.bi_buf = 0, e.bi_valid = 0, dl(e);
}, ll = (e, t, a, n) => {
  Ne(e, (F2 << 1) + (n ? 1 : 0), 3), fl(e), Hn(e, a), Hn(e, ~a), a && e.pending_buf.set(e.window.subarray(t, t + a), e.pending), e.pending += a;
}, r6 = (e) => {
  Ne(e, Xf << 1, 3), at(e, js, yt), X2(e);
}, c6 = (e, t, a, n) => {
  let r, c, i = 0;
  e.level > 0 ? (e.strm.data_type === z2 && (e.strm.data_type = a6(e)), qi(e, e.l_desc), qi(e, e.d_desc), i = e6(e), r = e.opt_len + 3 + 7 >>> 3, c = e.static_len + 3 + 7 >>> 3, c <= r && (r = c)) : r = c = a + 5, a + 4 <= r && t !== -1 ? ll(e, t, a, n) : e.strategy === H2 || c === r ? (Ne(e, (Xf << 1) + (n ? 1 : 0), 3), Xo(e, yt, An)) : (Ne(e, (V2 << 1) + (n ? 1 : 0), 3), t6(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, i + 1), Xo(e, e.dyn_ltree, e.dyn_dtree)), dl(e), n && fl(e);
}, i6 = (e, t, a) => (e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = a, t === 0 ? e.dyn_ltree[a * 2]++ : (e.matches++, t--, e.dyn_ltree[(Mn[a] + Er + 1) * 2]++, e.dyn_dtree[il(t) * 2]++), e.sym_next === e.sym_end);
var s6 = n6, o6 = ll, d6 = c6, f6 = i6, l6 = r6, u6 = {
  _tr_init: s6,
  _tr_stored_block: o6,
  _tr_flush_block: d6,
  _tr_tally: f6,
  _tr_align: l6
};
const b6 = (e, t, a, n) => {
  let r = e & 65535 | 0, c = e >>> 16 & 65535 | 0, i = 0;
  for (; a !== 0; ) {
    i = a > 2e3 ? 2e3 : a, a -= i;
    do
      r = r + t[n++] | 0, c = c + r | 0;
    while (--i);
    r %= 65521, c %= 65521;
  }
  return r | c << 16 | 0;
};
var zn = b6;
const h6 = () => {
  let e, t = [];
  for (var a = 0; a < 256; a++) {
    e = a;
    for (var n = 0; n < 8; n++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[a] = e;
  }
  return t;
}, p6 = new Uint32Array(h6()), m6 = (e, t, a, n) => {
  const r = p6, c = n + a;
  e ^= -1;
  for (let i = n; i < c; i++)
    e = e >>> 8 ^ r[(e ^ t[i]) & 255];
  return e ^ -1;
};
var ue = m6, Xa = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, kr = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: g6, _tr_stored_block: Wi, _tr_flush_block: _6, _tr_tally: Ut, _tr_align: y6 } = u6, {
  Z_NO_FLUSH: Mt,
  Z_PARTIAL_FLUSH: w6,
  Z_FULL_FLUSH: v6,
  Z_FINISH: je,
  Z_BLOCK: td,
  Z_OK: ge,
  Z_STREAM_END: ad,
  Z_STREAM_ERROR: ct,
  Z_DATA_ERROR: x6,
  Z_BUF_ERROR: ui,
  Z_DEFAULT_COMPRESSION: E6,
  Z_FILTERED: k6,
  Z_HUFFMAN_ONLY: Mr,
  Z_RLE: T6,
  Z_FIXED: S6,
  Z_DEFAULT_STRATEGY: C6,
  Z_UNKNOWN: A6,
  Z_DEFLATED: Bc
} = kr, O6 = 9, I6 = 15, N6 = 8, R6 = 29, P6 = 256, Ki = P6 + 1 + R6, L6 = 30, $6 = 19, D6 = 2 * Ki + 1, B6 = 15, X = 3, Zt = 258, it = Zt + X + 1, Z6 = 32, Ja = 42, Ms = 57, Gi = 69, Yi = 73, Xi = 91, Ji = 103, da = 113, Sn = 666, Te = 1, ln = 2, ma = 3, un = 4, j6 = 3, fa = (e, t) => (e.msg = Xa[t], t), nd = (e) => e * 2 - (e > 4 ? 9 : 0), Lt = (e) => {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}, U6 = (e) => {
  let t, a, n, r = e.w_size;
  t = e.hash_size, n = t;
  do
    a = e.head[--n], e.head[n] = a >= r ? a - r : 0;
  while (--t);
  t = r, n = t;
  do
    a = e.prev[--n], e.prev[n] = a >= r ? a - r : 0;
  while (--t);
};
let M6 = (e, t, a) => (t << e.hash_shift ^ a) & e.hash_mask, Ht = M6;
const Le = (e) => {
  const t = e.state;
  let a = t.pending;
  a > e.avail_out && (a = e.avail_out), a !== 0 && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + a), e.next_out), e.next_out += a, t.pending_out += a, e.total_out += a, e.avail_out -= a, t.pending -= a, t.pending === 0 && (t.pending_out = 0));
}, De = (e, t) => {
  _6(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, Le(e.strm);
}, ne = (e, t) => {
  e.pending_buf[e.pending++] = t;
}, vn = (e, t) => {
  e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = t & 255;
}, Qi = (e, t, a, n) => {
  let r = e.avail_in;
  return r > n && (r = n), r === 0 ? 0 : (e.avail_in -= r, t.set(e.input.subarray(e.next_in, e.next_in + r), a), e.state.wrap === 1 ? e.adler = zn(e.adler, t, r, a) : e.state.wrap === 2 && (e.adler = ue(e.adler, t, r, a)), e.next_in += r, e.total_in += r, r);
}, ul = (e, t) => {
  let a = e.max_chain_length, n = e.strstart, r, c, i = e.prev_length, s = e.nice_match;
  const o = e.strstart > e.w_size - it ? e.strstart - (e.w_size - it) : 0, d = e.window, f = e.w_mask, l = e.prev, b = e.strstart + Zt;
  let u = d[n + i - 1], h = d[n + i];
  e.prev_length >= e.good_match && (a >>= 2), s > e.lookahead && (s = e.lookahead);
  do
    if (r = t, !(d[r + i] !== h || d[r + i - 1] !== u || d[r] !== d[n] || d[++r] !== d[n + 1])) {
      n += 2, r++;
      do
        ;
      while (d[++n] === d[++r] && d[++n] === d[++r] && d[++n] === d[++r] && d[++n] === d[++r] && d[++n] === d[++r] && d[++n] === d[++r] && d[++n] === d[++r] && d[++n] === d[++r] && n < b);
      if (c = Zt - (b - n), n = b - Zt, c > i) {
        if (e.match_start = t, i = c, c >= s)
          break;
        u = d[n + i - 1], h = d[n + i];
      }
    }
  while ((t = l[t & f]) > o && --a !== 0);
  return i <= e.lookahead ? i : e.lookahead;
}, Qa = (e) => {
  const t = e.w_size;
  let a, n, r;
  do {
    if (n = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - it) && (e.window.set(e.window.subarray(t, t + t - n), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, e.insert > e.strstart && (e.insert = e.strstart), U6(e), n += t), e.strm.avail_in === 0)
      break;
    if (a = Qi(e.strm, e.window, e.strstart + e.lookahead, n), e.lookahead += a, e.lookahead + e.insert >= X)
      for (r = e.strstart - e.insert, e.ins_h = e.window[r], e.ins_h = Ht(e, e.ins_h, e.window[r + 1]); e.insert && (e.ins_h = Ht(e, e.ins_h, e.window[r + X - 1]), e.prev[r & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = r, r++, e.insert--, !(e.lookahead + e.insert < X)); )
        ;
  } while (e.lookahead < it && e.strm.avail_in !== 0);
}, bl = (e, t) => {
  let a = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, n, r, c, i = 0, s = e.strm.avail_in;
  do {
    if (n = 65535, c = e.bi_valid + 42 >> 3, e.strm.avail_out < c || (c = e.strm.avail_out - c, r = e.strstart - e.block_start, n > r + e.strm.avail_in && (n = r + e.strm.avail_in), n > c && (n = c), n < a && (n === 0 && t !== je || t === Mt || n !== r + e.strm.avail_in)))
      break;
    i = t === je && n === r + e.strm.avail_in ? 1 : 0, Wi(e, 0, 0, i), e.pending_buf[e.pending - 4] = n, e.pending_buf[e.pending - 3] = n >> 8, e.pending_buf[e.pending - 2] = ~n, e.pending_buf[e.pending - 1] = ~n >> 8, Le(e.strm), r && (r > n && (r = n), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + r), e.strm.next_out), e.strm.next_out += r, e.strm.avail_out -= r, e.strm.total_out += r, e.block_start += r, n -= r), n && (Qi(e.strm, e.strm.output, e.strm.next_out, n), e.strm.next_out += n, e.strm.avail_out -= n, e.strm.total_out += n);
  } while (i === 0);
  return s -= e.strm.avail_in, s && (s >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= s && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - s, e.strm.next_in), e.strstart), e.strstart += s, e.insert += s > e.w_size - e.insert ? e.w_size - e.insert : s), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), i ? un : t !== Mt && t !== je && e.strm.avail_in === 0 && e.strstart === e.block_start ? ln : (c = e.window_size - e.strstart, e.strm.avail_in > c && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, c += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), c > e.strm.avail_in && (c = e.strm.avail_in), c && (Qi(e.strm, e.window, e.strstart, c), e.strstart += c, e.insert += c > e.w_size - e.insert ? e.w_size - e.insert : c), e.high_water < e.strstart && (e.high_water = e.strstart), c = e.bi_valid + 42 >> 3, c = e.pending_buf_size - c > 65535 ? 65535 : e.pending_buf_size - c, a = c > e.w_size ? e.w_size : c, r = e.strstart - e.block_start, (r >= a || (r || t === je) && t !== Mt && e.strm.avail_in === 0 && r <= c) && (n = r > c ? c : r, i = t === je && e.strm.avail_in === 0 && n === r ? 1 : 0, Wi(e, e.block_start, n, i), e.block_start += n, Le(e.strm)), i ? ma : Te);
}, bi = (e, t) => {
  let a, n;
  for (; ; ) {
    if (e.lookahead < it) {
      if (Qa(e), e.lookahead < it && t === Mt)
        return Te;
      if (e.lookahead === 0)
        break;
    }
    if (a = 0, e.lookahead >= X && (e.ins_h = Ht(e, e.ins_h, e.window[e.strstart + X - 1]), a = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), a !== 0 && e.strstart - a <= e.w_size - it && (e.match_length = ul(e, a)), e.match_length >= X)
      if (n = Ut(e, e.strstart - e.match_start, e.match_length - X), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= X) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = Ht(e, e.ins_h, e.window[e.strstart + X - 1]), a = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = Ht(e, e.ins_h, e.window[e.strstart + 1]);
    else
      n = Ut(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (n && (De(e, !1), e.strm.avail_out === 0))
      return Te;
  }
  return e.insert = e.strstart < X - 1 ? e.strstart : X - 1, t === je ? (De(e, !0), e.strm.avail_out === 0 ? ma : un) : e.sym_next && (De(e, !1), e.strm.avail_out === 0) ? Te : ln;
}, Pa = (e, t) => {
  let a, n, r;
  for (; ; ) {
    if (e.lookahead < it) {
      if (Qa(e), e.lookahead < it && t === Mt)
        return Te;
      if (e.lookahead === 0)
        break;
    }
    if (a = 0, e.lookahead >= X && (e.ins_h = Ht(e, e.ins_h, e.window[e.strstart + X - 1]), a = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = X - 1, a !== 0 && e.prev_length < e.max_lazy_match && e.strstart - a <= e.w_size - it && (e.match_length = ul(e, a), e.match_length <= 5 && (e.strategy === k6 || e.match_length === X && e.strstart - e.match_start > 4096) && (e.match_length = X - 1)), e.prev_length >= X && e.match_length <= e.prev_length) {
      r = e.strstart + e.lookahead - X, n = Ut(e, e.strstart - 1 - e.prev_match, e.prev_length - X), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= r && (e.ins_h = Ht(e, e.ins_h, e.window[e.strstart + X - 1]), a = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = X - 1, e.strstart++, n && (De(e, !1), e.strm.avail_out === 0))
        return Te;
    } else if (e.match_available) {
      if (n = Ut(e, 0, e.window[e.strstart - 1]), n && De(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return Te;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (n = Ut(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < X - 1 ? e.strstart : X - 1, t === je ? (De(e, !0), e.strm.avail_out === 0 ? ma : un) : e.sym_next && (De(e, !1), e.strm.avail_out === 0) ? Te : ln;
}, H6 = (e, t) => {
  let a, n, r, c;
  const i = e.window;
  for (; ; ) {
    if (e.lookahead <= Zt) {
      if (Qa(e), e.lookahead <= Zt && t === Mt)
        return Te;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= X && e.strstart > 0 && (r = e.strstart - 1, n = i[r], n === i[++r] && n === i[++r] && n === i[++r])) {
      c = e.strstart + Zt;
      do
        ;
      while (n === i[++r] && n === i[++r] && n === i[++r] && n === i[++r] && n === i[++r] && n === i[++r] && n === i[++r] && n === i[++r] && r < c);
      e.match_length = Zt - (c - r), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= X ? (a = Ut(e, 1, e.match_length - X), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (a = Ut(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), a && (De(e, !1), e.strm.avail_out === 0))
      return Te;
  }
  return e.insert = 0, t === je ? (De(e, !0), e.strm.avail_out === 0 ? ma : un) : e.sym_next && (De(e, !1), e.strm.avail_out === 0) ? Te : ln;
}, z6 = (e, t) => {
  let a;
  for (; ; ) {
    if (e.lookahead === 0 && (Qa(e), e.lookahead === 0)) {
      if (t === Mt)
        return Te;
      break;
    }
    if (e.match_length = 0, a = Ut(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, a && (De(e, !1), e.strm.avail_out === 0))
      return Te;
  }
  return e.insert = 0, t === je ? (De(e, !0), e.strm.avail_out === 0 ? ma : un) : e.sym_next && (De(e, !1), e.strm.avail_out === 0) ? Te : ln;
};
function et(e, t, a, n, r) {
  this.good_length = e, this.max_lazy = t, this.nice_length = a, this.max_chain = n, this.func = r;
}
const Cn = [
  /*      good lazy nice chain */
  new et(0, 0, 0, 0, bl),
  /* 0 store only */
  new et(4, 4, 8, 4, bi),
  /* 1 max speed, no lazy matches */
  new et(4, 5, 16, 8, bi),
  /* 2 */
  new et(4, 6, 32, 32, bi),
  /* 3 */
  new et(4, 4, 16, 16, Pa),
  /* 4 lazy matches */
  new et(8, 16, 32, 32, Pa),
  /* 5 */
  new et(8, 16, 128, 128, Pa),
  /* 6 */
  new et(8, 32, 128, 256, Pa),
  /* 7 */
  new et(32, 128, 258, 1024, Pa),
  /* 8 */
  new et(32, 258, 258, 4096, Pa)
  /* 9 max compression */
], F6 = (e) => {
  e.window_size = 2 * e.w_size, Lt(e.head), e.max_lazy_match = Cn[e.level].max_lazy, e.good_match = Cn[e.level].good_length, e.nice_match = Cn[e.level].nice_length, e.max_chain_length = Cn[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = X - 1, e.match_available = 0, e.ins_h = 0;
};
function V6() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Bc, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(D6 * 2), this.dyn_dtree = new Uint16Array((2 * L6 + 1) * 2), this.bl_tree = new Uint16Array((2 * $6 + 1) * 2), Lt(this.dyn_ltree), Lt(this.dyn_dtree), Lt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(B6 + 1), this.heap = new Uint16Array(2 * Ki + 1), Lt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * Ki + 1), Lt(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const Tr = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.status !== Ja && //#ifdef GZIP
  t.status !== Ms && //#endif
  t.status !== Gi && t.status !== Yi && t.status !== Xi && t.status !== Ji && t.status !== da && t.status !== Sn ? 1 : 0;
}, hl = (e) => {
  if (Tr(e))
    return fa(e, ct);
  e.total_in = e.total_out = 0, e.data_type = A6;
  const t = e.state;
  return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = //#ifdef GZIP
  t.wrap === 2 ? Ms : (
    //#endif
    t.wrap ? Ja : da
  ), e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, g6(t), ge;
}, pl = (e) => {
  const t = hl(e);
  return t === ge && F6(e.state), t;
}, q6 = (e, t) => Tr(e) || e.state.wrap !== 2 ? ct : (e.state.gzhead = t, ge), ml = (e, t, a, n, r, c) => {
  if (!e)
    return ct;
  let i = 1;
  if (t === E6 && (t = 6), n < 0 ? (i = 0, n = -n) : n > 15 && (i = 2, n -= 16), r < 1 || r > O6 || a !== Bc || n < 8 || n > 15 || t < 0 || t > 9 || c < 0 || c > S6 || n === 8 && i !== 1)
    return fa(e, ct);
  n === 8 && (n = 9);
  const s = new V6();
  return e.state = s, s.strm = e, s.status = Ja, s.wrap = i, s.gzhead = null, s.w_bits = n, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = r + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + X - 1) / X), s.window = new Uint8Array(s.w_size * 2), s.head = new Uint16Array(s.hash_size), s.prev = new Uint16Array(s.w_size), s.lit_bufsize = 1 << r + 6, s.pending_buf_size = s.lit_bufsize * 4, s.pending_buf = new Uint8Array(s.pending_buf_size), s.sym_buf = s.lit_bufsize, s.sym_end = (s.lit_bufsize - 1) * 3, s.level = t, s.strategy = c, s.method = a, pl(e);
}, W6 = (e, t) => ml(e, t, Bc, I6, N6, C6), K6 = (e, t) => {
  if (Tr(e) || t > td || t < 0)
    return e ? fa(e, ct) : ct;
  const a = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || a.status === Sn && t !== je)
    return fa(e, e.avail_out === 0 ? ui : ct);
  const n = a.last_flush;
  if (a.last_flush = t, a.pending !== 0) {
    if (Le(e), e.avail_out === 0)
      return a.last_flush = -1, ge;
  } else if (e.avail_in === 0 && nd(t) <= nd(n) && t !== je)
    return fa(e, ui);
  if (a.status === Sn && e.avail_in !== 0)
    return fa(e, ui);
  if (a.status === Ja && a.wrap === 0 && (a.status = da), a.status === Ja) {
    let r = Bc + (a.w_bits - 8 << 4) << 8, c = -1;
    if (a.strategy >= Mr || a.level < 2 ? c = 0 : a.level < 6 ? c = 1 : a.level === 6 ? c = 2 : c = 3, r |= c << 6, a.strstart !== 0 && (r |= Z6), r += 31 - r % 31, vn(a, r), a.strstart !== 0 && (vn(a, e.adler >>> 16), vn(a, e.adler & 65535)), e.adler = 1, a.status = da, Le(e), a.pending !== 0)
      return a.last_flush = -1, ge;
  }
  if (a.status === Ms) {
    if (e.adler = 0, ne(a, 31), ne(a, 139), ne(a, 8), a.gzhead)
      ne(
        a,
        (a.gzhead.text ? 1 : 0) + (a.gzhead.hcrc ? 2 : 0) + (a.gzhead.extra ? 4 : 0) + (a.gzhead.name ? 8 : 0) + (a.gzhead.comment ? 16 : 0)
      ), ne(a, a.gzhead.time & 255), ne(a, a.gzhead.time >> 8 & 255), ne(a, a.gzhead.time >> 16 & 255), ne(a, a.gzhead.time >> 24 & 255), ne(a, a.level === 9 ? 2 : a.strategy >= Mr || a.level < 2 ? 4 : 0), ne(a, a.gzhead.os & 255), a.gzhead.extra && a.gzhead.extra.length && (ne(a, a.gzhead.extra.length & 255), ne(a, a.gzhead.extra.length >> 8 & 255)), a.gzhead.hcrc && (e.adler = ue(e.adler, a.pending_buf, a.pending, 0)), a.gzindex = 0, a.status = Gi;
    else if (ne(a, 0), ne(a, 0), ne(a, 0), ne(a, 0), ne(a, 0), ne(a, a.level === 9 ? 2 : a.strategy >= Mr || a.level < 2 ? 4 : 0), ne(a, j6), a.status = da, Le(e), a.pending !== 0)
      return a.last_flush = -1, ge;
  }
  if (a.status === Gi) {
    if (a.gzhead.extra) {
      let r = a.pending, c = (a.gzhead.extra.length & 65535) - a.gzindex;
      for (; a.pending + c > a.pending_buf_size; ) {
        let s = a.pending_buf_size - a.pending;
        if (a.pending_buf.set(a.gzhead.extra.subarray(a.gzindex, a.gzindex + s), a.pending), a.pending = a.pending_buf_size, a.gzhead.hcrc && a.pending > r && (e.adler = ue(e.adler, a.pending_buf, a.pending - r, r)), a.gzindex += s, Le(e), a.pending !== 0)
          return a.last_flush = -1, ge;
        r = 0, c -= s;
      }
      let i = new Uint8Array(a.gzhead.extra);
      a.pending_buf.set(i.subarray(a.gzindex, a.gzindex + c), a.pending), a.pending += c, a.gzhead.hcrc && a.pending > r && (e.adler = ue(e.adler, a.pending_buf, a.pending - r, r)), a.gzindex = 0;
    }
    a.status = Yi;
  }
  if (a.status === Yi) {
    if (a.gzhead.name) {
      let r = a.pending, c;
      do {
        if (a.pending === a.pending_buf_size) {
          if (a.gzhead.hcrc && a.pending > r && (e.adler = ue(e.adler, a.pending_buf, a.pending - r, r)), Le(e), a.pending !== 0)
            return a.last_flush = -1, ge;
          r = 0;
        }
        a.gzindex < a.gzhead.name.length ? c = a.gzhead.name.charCodeAt(a.gzindex++) & 255 : c = 0, ne(a, c);
      } while (c !== 0);
      a.gzhead.hcrc && a.pending > r && (e.adler = ue(e.adler, a.pending_buf, a.pending - r, r)), a.gzindex = 0;
    }
    a.status = Xi;
  }
  if (a.status === Xi) {
    if (a.gzhead.comment) {
      let r = a.pending, c;
      do {
        if (a.pending === a.pending_buf_size) {
          if (a.gzhead.hcrc && a.pending > r && (e.adler = ue(e.adler, a.pending_buf, a.pending - r, r)), Le(e), a.pending !== 0)
            return a.last_flush = -1, ge;
          r = 0;
        }
        a.gzindex < a.gzhead.comment.length ? c = a.gzhead.comment.charCodeAt(a.gzindex++) & 255 : c = 0, ne(a, c);
      } while (c !== 0);
      a.gzhead.hcrc && a.pending > r && (e.adler = ue(e.adler, a.pending_buf, a.pending - r, r));
    }
    a.status = Ji;
  }
  if (a.status === Ji) {
    if (a.gzhead.hcrc) {
      if (a.pending + 2 > a.pending_buf_size && (Le(e), a.pending !== 0))
        return a.last_flush = -1, ge;
      ne(a, e.adler & 255), ne(a, e.adler >> 8 & 255), e.adler = 0;
    }
    if (a.status = da, Le(e), a.pending !== 0)
      return a.last_flush = -1, ge;
  }
  if (e.avail_in !== 0 || a.lookahead !== 0 || t !== Mt && a.status !== Sn) {
    let r = a.level === 0 ? bl(a, t) : a.strategy === Mr ? z6(a, t) : a.strategy === T6 ? H6(a, t) : Cn[a.level].func(a, t);
    if ((r === ma || r === un) && (a.status = Sn), r === Te || r === ma)
      return e.avail_out === 0 && (a.last_flush = -1), ge;
    if (r === ln && (t === w6 ? y6(a) : t !== td && (Wi(a, 0, 0, !1), t === v6 && (Lt(a.head), a.lookahead === 0 && (a.strstart = 0, a.block_start = 0, a.insert = 0))), Le(e), e.avail_out === 0))
      return a.last_flush = -1, ge;
  }
  return t !== je ? ge : a.wrap <= 0 ? ad : (a.wrap === 2 ? (ne(a, e.adler & 255), ne(a, e.adler >> 8 & 255), ne(a, e.adler >> 16 & 255), ne(a, e.adler >> 24 & 255), ne(a, e.total_in & 255), ne(a, e.total_in >> 8 & 255), ne(a, e.total_in >> 16 & 255), ne(a, e.total_in >> 24 & 255)) : (vn(a, e.adler >>> 16), vn(a, e.adler & 65535)), Le(e), a.wrap > 0 && (a.wrap = -a.wrap), a.pending !== 0 ? ge : ad);
}, G6 = (e) => {
  if (Tr(e))
    return ct;
  const t = e.state.status;
  return e.state = null, t === da ? fa(e, x6) : ge;
}, Y6 = (e, t) => {
  let a = t.length;
  if (Tr(e))
    return ct;
  const n = e.state, r = n.wrap;
  if (r === 2 || r === 1 && n.status !== Ja || n.lookahead)
    return ct;
  if (r === 1 && (e.adler = zn(e.adler, t, a, 0)), n.wrap = 0, a >= n.w_size) {
    r === 0 && (Lt(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
    let o = new Uint8Array(n.w_size);
    o.set(t.subarray(a - n.w_size, a), 0), t = o, a = n.w_size;
  }
  const c = e.avail_in, i = e.next_in, s = e.input;
  for (e.avail_in = a, e.next_in = 0, e.input = t, Qa(n); n.lookahead >= X; ) {
    let o = n.strstart, d = n.lookahead - (X - 1);
    do
      n.ins_h = Ht(n, n.ins_h, n.window[o + X - 1]), n.prev[o & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = o, o++;
    while (--d);
    n.strstart = o, n.lookahead = X - 1, Qa(n);
  }
  return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = X - 1, n.match_available = 0, e.next_in = i, e.input = s, e.avail_in = c, n.wrap = r, ge;
};
var X6 = W6, J6 = ml, Q6 = pl, e3 = hl, t3 = q6, a3 = K6, n3 = G6, r3 = Y6, c3 = "pako deflate (from Nodeca project)", On = {
  deflateInit: X6,
  deflateInit2: J6,
  deflateReset: Q6,
  deflateResetKeep: e3,
  deflateSetHeader: t3,
  deflate: a3,
  deflateEnd: n3,
  deflateSetDictionary: r3,
  deflateInfo: c3
};
const i3 = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var s3 = function(e) {
  const t = Array.prototype.slice.call(arguments, 1);
  for (; t.length; ) {
    const a = t.shift();
    if (a) {
      if (typeof a != "object")
        throw new TypeError(a + "must be non-object");
      for (const n in a)
        i3(a, n) && (e[n] = a[n]);
    }
  }
  return e;
}, o3 = (e) => {
  let t = 0;
  for (let n = 0, r = e.length; n < r; n++)
    t += e[n].length;
  const a = new Uint8Array(t);
  for (let n = 0, r = 0, c = e.length; n < c; n++) {
    let i = e[n];
    a.set(i, r), r += i.length;
  }
  return a;
}, Zc = {
  assign: s3,
  flattenChunks: o3
};
let gl = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  gl = !1;
}
const Fn = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  Fn[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
Fn[254] = Fn[254] = 1;
var d3 = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let t, a, n, r, c, i = e.length, s = 0;
  for (r = 0; r < i; r++)
    a = e.charCodeAt(r), (a & 64512) === 55296 && r + 1 < i && (n = e.charCodeAt(r + 1), (n & 64512) === 56320 && (a = 65536 + (a - 55296 << 10) + (n - 56320), r++)), s += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
  for (t = new Uint8Array(s), c = 0, r = 0; c < s; r++)
    a = e.charCodeAt(r), (a & 64512) === 55296 && r + 1 < i && (n = e.charCodeAt(r + 1), (n & 64512) === 56320 && (a = 65536 + (a - 55296 << 10) + (n - 56320), r++)), a < 128 ? t[c++] = a : a < 2048 ? (t[c++] = 192 | a >>> 6, t[c++] = 128 | a & 63) : a < 65536 ? (t[c++] = 224 | a >>> 12, t[c++] = 128 | a >>> 6 & 63, t[c++] = 128 | a & 63) : (t[c++] = 240 | a >>> 18, t[c++] = 128 | a >>> 12 & 63, t[c++] = 128 | a >>> 6 & 63, t[c++] = 128 | a & 63);
  return t;
};
const f3 = (e, t) => {
  if (t < 65534 && e.subarray && gl)
    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
  let a = "";
  for (let n = 0; n < t; n++)
    a += String.fromCharCode(e[n]);
  return a;
};
var l3 = (e, t) => {
  const a = t || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, t));
  let n, r;
  const c = new Array(a * 2);
  for (r = 0, n = 0; n < a; ) {
    let i = e[n++];
    if (i < 128) {
      c[r++] = i;
      continue;
    }
    let s = Fn[i];
    if (s > 4) {
      c[r++] = 65533, n += s - 1;
      continue;
    }
    for (i &= s === 2 ? 31 : s === 3 ? 15 : 7; s > 1 && n < a; )
      i = i << 6 | e[n++] & 63, s--;
    if (s > 1) {
      c[r++] = 65533;
      continue;
    }
    i < 65536 ? c[r++] = i : (i -= 65536, c[r++] = 55296 | i >> 10 & 1023, c[r++] = 56320 | i & 1023);
  }
  return f3(c, r);
}, u3 = (e, t) => {
  t = t || e.length, t > e.length && (t = e.length);
  let a = t - 1;
  for (; a >= 0 && (e[a] & 192) === 128; )
    a--;
  return a < 0 || a === 0 ? t : a + Fn[e[a]] > t ? a : t;
}, Vn = {
  string2buf: d3,
  buf2string: l3,
  utf8border: u3
};
function b3() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var _l = b3;
const yl = Object.prototype.toString, {
  Z_NO_FLUSH: h3,
  Z_SYNC_FLUSH: p3,
  Z_FULL_FLUSH: m3,
  Z_FINISH: g3,
  Z_OK: cc,
  Z_STREAM_END: _3,
  Z_DEFAULT_COMPRESSION: y3,
  Z_DEFAULT_STRATEGY: w3,
  Z_DEFLATED: v3
} = kr;
function Sr(e) {
  this.options = Zc.assign({
    level: y3,
    method: v3,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: w3
  }, e || {});
  let t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new _l(), this.strm.avail_out = 0;
  let a = On.deflateInit2(
    this.strm,
    t.level,
    t.method,
    t.windowBits,
    t.memLevel,
    t.strategy
  );
  if (a !== cc)
    throw new Error(Xa[a]);
  if (t.header && On.deflateSetHeader(this.strm, t.header), t.dictionary) {
    let n;
    if (typeof t.dictionary == "string" ? n = Vn.string2buf(t.dictionary) : yl.call(t.dictionary) === "[object ArrayBuffer]" ? n = new Uint8Array(t.dictionary) : n = t.dictionary, a = On.deflateSetDictionary(this.strm, n), a !== cc)
      throw new Error(Xa[a]);
    this._dict_set = !0;
  }
}
Sr.prototype.push = function(e, t) {
  const a = this.strm, n = this.options.chunkSize;
  let r, c;
  if (this.ended)
    return !1;
  for (t === ~~t ? c = t : c = t === !0 ? g3 : h3, typeof e == "string" ? a.input = Vn.string2buf(e) : yl.call(e) === "[object ArrayBuffer]" ? a.input = new Uint8Array(e) : a.input = e, a.next_in = 0, a.avail_in = a.input.length; ; ) {
    if (a.avail_out === 0 && (a.output = new Uint8Array(n), a.next_out = 0, a.avail_out = n), (c === p3 || c === m3) && a.avail_out <= 6) {
      this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0;
      continue;
    }
    if (r = On.deflate(a, c), r === _3)
      return a.next_out > 0 && this.onData(a.output.subarray(0, a.next_out)), r = On.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === cc;
    if (a.avail_out === 0) {
      this.onData(a.output);
      continue;
    }
    if (c > 0 && a.next_out > 0) {
      this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0;
      continue;
    }
    if (a.avail_in === 0)
      break;
  }
  return !0;
};
Sr.prototype.onData = function(e) {
  this.chunks.push(e);
};
Sr.prototype.onEnd = function(e) {
  e === cc && (this.result = Zc.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function Hs(e, t) {
  const a = new Sr(t);
  if (a.push(e, !0), a.err)
    throw a.msg || Xa[a.err];
  return a.result;
}
function x3(e, t) {
  return t = t || {}, t.raw = !0, Hs(e, t);
}
function E3(e, t) {
  return t = t || {}, t.gzip = !0, Hs(e, t);
}
var k3 = Sr, T3 = Hs, S3 = x3, C3 = E3, A3 = kr, O3 = {
  Deflate: k3,
  deflate: T3,
  deflateRaw: S3,
  gzip: C3,
  constants: A3
};
const Hr = 16209, I3 = 16191;
var N3 = function(t, a) {
  let n, r, c, i, s, o, d, f, l, b, u, h, p, m, g, v, S, y, O, E, _, I, j, C;
  const x = t.state;
  n = t.next_in, j = t.input, r = n + (t.avail_in - 5), c = t.next_out, C = t.output, i = c - (a - t.avail_out), s = c + (t.avail_out - 257), o = x.dmax, d = x.wsize, f = x.whave, l = x.wnext, b = x.window, u = x.hold, h = x.bits, p = x.lencode, m = x.distcode, g = (1 << x.lenbits) - 1, v = (1 << x.distbits) - 1;
  e:
    do {
      h < 15 && (u += j[n++] << h, h += 8, u += j[n++] << h, h += 8), S = p[u & g];
      t:
        for (; ; ) {
          if (y = S >>> 24, u >>>= y, h -= y, y = S >>> 16 & 255, y === 0)
            C[c++] = S & 65535;
          else if (y & 16) {
            O = S & 65535, y &= 15, y && (h < y && (u += j[n++] << h, h += 8), O += u & (1 << y) - 1, u >>>= y, h -= y), h < 15 && (u += j[n++] << h, h += 8, u += j[n++] << h, h += 8), S = m[u & v];
            a:
              for (; ; ) {
                if (y = S >>> 24, u >>>= y, h -= y, y = S >>> 16 & 255, y & 16) {
                  if (E = S & 65535, y &= 15, h < y && (u += j[n++] << h, h += 8, h < y && (u += j[n++] << h, h += 8)), E += u & (1 << y) - 1, E > o) {
                    t.msg = "invalid distance too far back", x.mode = Hr;
                    break e;
                  }
                  if (u >>>= y, h -= y, y = c - i, E > y) {
                    if (y = E - y, y > f && x.sane) {
                      t.msg = "invalid distance too far back", x.mode = Hr;
                      break e;
                    }
                    if (_ = 0, I = b, l === 0) {
                      if (_ += d - y, y < O) {
                        O -= y;
                        do
                          C[c++] = b[_++];
                        while (--y);
                        _ = c - E, I = C;
                      }
                    } else if (l < y) {
                      if (_ += d + l - y, y -= l, y < O) {
                        O -= y;
                        do
                          C[c++] = b[_++];
                        while (--y);
                        if (_ = 0, l < O) {
                          y = l, O -= y;
                          do
                            C[c++] = b[_++];
                          while (--y);
                          _ = c - E, I = C;
                        }
                      }
                    } else if (_ += l - y, y < O) {
                      O -= y;
                      do
                        C[c++] = b[_++];
                      while (--y);
                      _ = c - E, I = C;
                    }
                    for (; O > 2; )
                      C[c++] = I[_++], C[c++] = I[_++], C[c++] = I[_++], O -= 3;
                    O && (C[c++] = I[_++], O > 1 && (C[c++] = I[_++]));
                  } else {
                    _ = c - E;
                    do
                      C[c++] = C[_++], C[c++] = C[_++], C[c++] = C[_++], O -= 3;
                    while (O > 2);
                    O && (C[c++] = C[_++], O > 1 && (C[c++] = C[_++]));
                  }
                } else if (y & 64) {
                  t.msg = "invalid distance code", x.mode = Hr;
                  break e;
                } else {
                  S = m[(S & 65535) + (u & (1 << y) - 1)];
                  continue a;
                }
                break;
              }
          } else if (y & 64)
            if (y & 32) {
              x.mode = I3;
              break e;
            } else {
              t.msg = "invalid literal/length code", x.mode = Hr;
              break e;
            }
          else {
            S = p[(S & 65535) + (u & (1 << y) - 1)];
            continue t;
          }
          break;
        }
    } while (n < r && c < s);
  O = h >> 3, n -= O, h -= O << 3, u &= (1 << h) - 1, t.next_in = n, t.next_out = c, t.avail_in = n < r ? 5 + (r - n) : 5 - (n - r), t.avail_out = c < s ? 257 + (s - c) : 257 - (c - s), x.hold = u, x.bits = h;
};
const La = 15, rd = 852, cd = 592, id = 0, hi = 1, sd = 2, R3 = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), P3 = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), L3 = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), $3 = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), D3 = (e, t, a, n, r, c, i, s) => {
  const o = s.bits;
  let d = 0, f = 0, l = 0, b = 0, u = 0, h = 0, p = 0, m = 0, g = 0, v = 0, S, y, O, E, _, I = null, j;
  const C = new Uint16Array(La + 1), x = new Uint16Array(La + 1);
  let J = null, ce, B, w;
  for (d = 0; d <= La; d++)
    C[d] = 0;
  for (f = 0; f < n; f++)
    C[t[a + f]]++;
  for (u = o, b = La; b >= 1 && C[b] === 0; b--)
    ;
  if (u > b && (u = b), b === 0)
    return r[c++] = 1 << 24 | 64 << 16 | 0, r[c++] = 1 << 24 | 64 << 16 | 0, s.bits = 1, 0;
  for (l = 1; l < b && C[l] === 0; l++)
    ;
  for (u < l && (u = l), m = 1, d = 1; d <= La; d++)
    if (m <<= 1, m -= C[d], m < 0)
      return -1;
  if (m > 0 && (e === id || b !== 1))
    return -1;
  for (x[1] = 0, d = 1; d < La; d++)
    x[d + 1] = x[d] + C[d];
  for (f = 0; f < n; f++)
    t[a + f] !== 0 && (i[x[t[a + f]]++] = f);
  if (e === id ? (I = J = i, j = 20) : e === hi ? (I = R3, J = P3, j = 257) : (I = L3, J = $3, j = 0), v = 0, f = 0, d = l, _ = c, h = u, p = 0, O = -1, g = 1 << u, E = g - 1, e === hi && g > rd || e === sd && g > cd)
    return 1;
  for (; ; ) {
    ce = d - p, i[f] + 1 < j ? (B = 0, w = i[f]) : i[f] >= j ? (B = J[i[f] - j], w = I[i[f] - j]) : (B = 32 + 64, w = 0), S = 1 << d - p, y = 1 << h, l = y;
    do
      y -= S, r[_ + (v >> p) + y] = ce << 24 | B << 16 | w | 0;
    while (y !== 0);
    for (S = 1 << d - 1; v & S; )
      S >>= 1;
    if (S !== 0 ? (v &= S - 1, v += S) : v = 0, f++, --C[d] === 0) {
      if (d === b)
        break;
      d = t[a + i[f]];
    }
    if (d > u && (v & E) !== O) {
      for (p === 0 && (p = u), _ += l, h = d - p, m = 1 << h; h + p < b && (m -= C[h + p], !(m <= 0)); )
        h++, m <<= 1;
      if (g += 1 << h, e === hi && g > rd || e === sd && g > cd)
        return 1;
      O = v & E, r[O] = u << 24 | h << 16 | _ - c | 0;
    }
  }
  return v !== 0 && (r[_ + v] = d - p << 24 | 64 << 16 | 0), s.bits = u, 0;
};
var In = D3;
const B3 = 0, wl = 1, vl = 2, {
  Z_FINISH: od,
  Z_BLOCK: Z3,
  Z_TREES: zr,
  Z_OK: ga,
  Z_STREAM_END: j3,
  Z_NEED_DICT: U3,
  Z_STREAM_ERROR: Me,
  Z_DATA_ERROR: xl,
  Z_MEM_ERROR: El,
  Z_BUF_ERROR: M3,
  Z_DEFLATED: dd
} = kr, jc = 16180, fd = 16181, ld = 16182, ud = 16183, bd = 16184, hd = 16185, pd = 16186, md = 16187, gd = 16188, _d = 16189, ic = 16190, gt = 16191, pi = 16192, yd = 16193, mi = 16194, wd = 16195, vd = 16196, xd = 16197, Ed = 16198, Fr = 16199, Vr = 16200, kd = 16201, Td = 16202, Sd = 16203, Cd = 16204, Ad = 16205, gi = 16206, Od = 16207, Id = 16208, ie = 16209, kl = 16210, Tl = 16211, H3 = 852, z3 = 592, F3 = 15, V3 = F3, Nd = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function q3() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const Oa = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.mode < jc || t.mode > Tl ? 1 : 0;
}, Sl = (e) => {
  if (Oa(e))
    return Me;
  const t = e.state;
  return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = t.wrap & 1), t.mode = jc, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(H3), t.distcode = t.distdyn = new Int32Array(z3), t.sane = 1, t.back = -1, ga;
}, Cl = (e) => {
  if (Oa(e))
    return Me;
  const t = e.state;
  return t.wsize = 0, t.whave = 0, t.wnext = 0, Sl(e);
}, Al = (e, t) => {
  let a;
  if (Oa(e))
    return Me;
  const n = e.state;
  return t < 0 ? (a = 0, t = -t) : (a = (t >> 4) + 5, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Me : (n.window !== null && n.wbits !== t && (n.window = null), n.wrap = a, n.wbits = t, Cl(e));
}, Ol = (e, t) => {
  if (!e)
    return Me;
  const a = new q3();
  e.state = a, a.strm = e, a.window = null, a.mode = jc;
  const n = Al(e, t);
  return n !== ga && (e.state = null), n;
}, W3 = (e) => Ol(e, V3);
let Rd = !0, _i, yi;
const K3 = (e) => {
  if (Rd) {
    _i = new Int32Array(512), yi = new Int32Array(32);
    let t = 0;
    for (; t < 144; )
      e.lens[t++] = 8;
    for (; t < 256; )
      e.lens[t++] = 9;
    for (; t < 280; )
      e.lens[t++] = 7;
    for (; t < 288; )
      e.lens[t++] = 8;
    for (In(wl, e.lens, 0, 288, _i, 0, e.work, { bits: 9 }), t = 0; t < 32; )
      e.lens[t++] = 5;
    In(vl, e.lens, 0, 32, yi, 0, e.work, { bits: 5 }), Rd = !1;
  }
  e.lencode = _i, e.lenbits = 9, e.distcode = yi, e.distbits = 5;
}, Il = (e, t, a, n) => {
  let r;
  const c = e.state;
  return c.window === null && (c.wsize = 1 << c.wbits, c.wnext = 0, c.whave = 0, c.window = new Uint8Array(c.wsize)), n >= c.wsize ? (c.window.set(t.subarray(a - c.wsize, a), 0), c.wnext = 0, c.whave = c.wsize) : (r = c.wsize - c.wnext, r > n && (r = n), c.window.set(t.subarray(a - n, a - n + r), c.wnext), n -= r, n ? (c.window.set(t.subarray(a - n, a), 0), c.wnext = n, c.whave = c.wsize) : (c.wnext += r, c.wnext === c.wsize && (c.wnext = 0), c.whave < c.wsize && (c.whave += r))), 0;
}, G3 = (e, t) => {
  let a, n, r, c, i, s, o, d, f, l, b, u, h, p, m = 0, g, v, S, y, O, E, _, I;
  const j = new Uint8Array(4);
  let C, x;
  const J = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (Oa(e) || !e.output || !e.input && e.avail_in !== 0)
    return Me;
  a = e.state, a.mode === gt && (a.mode = pi), i = e.next_out, r = e.output, o = e.avail_out, c = e.next_in, n = e.input, s = e.avail_in, d = a.hold, f = a.bits, l = s, b = o, I = ga;
  e:
    for (; ; )
      switch (a.mode) {
        case jc:
          if (a.wrap === 0) {
            a.mode = pi;
            break;
          }
          for (; f < 16; ) {
            if (s === 0)
              break e;
            s--, d += n[c++] << f, f += 8;
          }
          if (a.wrap & 2 && d === 35615) {
            a.wbits === 0 && (a.wbits = 15), a.check = 0, j[0] = d & 255, j[1] = d >>> 8 & 255, a.check = ue(a.check, j, 2, 0), d = 0, f = 0, a.mode = fd;
            break;
          }
          if (a.head && (a.head.done = !1), !(a.wrap & 1) || /* check if zlib header allowed */
          (((d & 255) << 8) + (d >> 8)) % 31) {
            e.msg = "incorrect header check", a.mode = ie;
            break;
          }
          if ((d & 15) !== dd) {
            e.msg = "unknown compression method", a.mode = ie;
            break;
          }
          if (d >>>= 4, f -= 4, _ = (d & 15) + 8, a.wbits === 0 && (a.wbits = _), _ > 15 || _ > a.wbits) {
            e.msg = "invalid window size", a.mode = ie;
            break;
          }
          a.dmax = 1 << a.wbits, a.flags = 0, e.adler = a.check = 1, a.mode = d & 512 ? _d : gt, d = 0, f = 0;
          break;
        case fd:
          for (; f < 16; ) {
            if (s === 0)
              break e;
            s--, d += n[c++] << f, f += 8;
          }
          if (a.flags = d, (a.flags & 255) !== dd) {
            e.msg = "unknown compression method", a.mode = ie;
            break;
          }
          if (a.flags & 57344) {
            e.msg = "unknown header flags set", a.mode = ie;
            break;
          }
          a.head && (a.head.text = d >> 8 & 1), a.flags & 512 && a.wrap & 4 && (j[0] = d & 255, j[1] = d >>> 8 & 255, a.check = ue(a.check, j, 2, 0)), d = 0, f = 0, a.mode = ld;
        case ld:
          for (; f < 32; ) {
            if (s === 0)
              break e;
            s--, d += n[c++] << f, f += 8;
          }
          a.head && (a.head.time = d), a.flags & 512 && a.wrap & 4 && (j[0] = d & 255, j[1] = d >>> 8 & 255, j[2] = d >>> 16 & 255, j[3] = d >>> 24 & 255, a.check = ue(a.check, j, 4, 0)), d = 0, f = 0, a.mode = ud;
        case ud:
          for (; f < 16; ) {
            if (s === 0)
              break e;
            s--, d += n[c++] << f, f += 8;
          }
          a.head && (a.head.xflags = d & 255, a.head.os = d >> 8), a.flags & 512 && a.wrap & 4 && (j[0] = d & 255, j[1] = d >>> 8 & 255, a.check = ue(a.check, j, 2, 0)), d = 0, f = 0, a.mode = bd;
        case bd:
          if (a.flags & 1024) {
            for (; f < 16; ) {
              if (s === 0)
                break e;
              s--, d += n[c++] << f, f += 8;
            }
            a.length = d, a.head && (a.head.extra_len = d), a.flags & 512 && a.wrap & 4 && (j[0] = d & 255, j[1] = d >>> 8 & 255, a.check = ue(a.check, j, 2, 0)), d = 0, f = 0;
          } else
            a.head && (a.head.extra = null);
          a.mode = hd;
        case hd:
          if (a.flags & 1024 && (u = a.length, u > s && (u = s), u && (a.head && (_ = a.head.extra_len - a.length, a.head.extra || (a.head.extra = new Uint8Array(a.head.extra_len)), a.head.extra.set(
            n.subarray(
              c,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              c + u
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            _
          )), a.flags & 512 && a.wrap & 4 && (a.check = ue(a.check, n, u, c)), s -= u, c += u, a.length -= u), a.length))
            break e;
          a.length = 0, a.mode = pd;
        case pd:
          if (a.flags & 2048) {
            if (s === 0)
              break e;
            u = 0;
            do
              _ = n[c + u++], a.head && _ && a.length < 65536 && (a.head.name += String.fromCharCode(_));
            while (_ && u < s);
            if (a.flags & 512 && a.wrap & 4 && (a.check = ue(a.check, n, u, c)), s -= u, c += u, _)
              break e;
          } else
            a.head && (a.head.name = null);
          a.length = 0, a.mode = md;
        case md:
          if (a.flags & 4096) {
            if (s === 0)
              break e;
            u = 0;
            do
              _ = n[c + u++], a.head && _ && a.length < 65536 && (a.head.comment += String.fromCharCode(_));
            while (_ && u < s);
            if (a.flags & 512 && a.wrap & 4 && (a.check = ue(a.check, n, u, c)), s -= u, c += u, _)
              break e;
          } else
            a.head && (a.head.comment = null);
          a.mode = gd;
        case gd:
          if (a.flags & 512) {
            for (; f < 16; ) {
              if (s === 0)
                break e;
              s--, d += n[c++] << f, f += 8;
            }
            if (a.wrap & 4 && d !== (a.check & 65535)) {
              e.msg = "header crc mismatch", a.mode = ie;
              break;
            }
            d = 0, f = 0;
          }
          a.head && (a.head.hcrc = a.flags >> 9 & 1, a.head.done = !0), e.adler = a.check = 0, a.mode = gt;
          break;
        case _d:
          for (; f < 32; ) {
            if (s === 0)
              break e;
            s--, d += n[c++] << f, f += 8;
          }
          e.adler = a.check = Nd(d), d = 0, f = 0, a.mode = ic;
        case ic:
          if (a.havedict === 0)
            return e.next_out = i, e.avail_out = o, e.next_in = c, e.avail_in = s, a.hold = d, a.bits = f, U3;
          e.adler = a.check = 1, a.mode = gt;
        case gt:
          if (t === Z3 || t === zr)
            break e;
        case pi:
          if (a.last) {
            d >>>= f & 7, f -= f & 7, a.mode = gi;
            break;
          }
          for (; f < 3; ) {
            if (s === 0)
              break e;
            s--, d += n[c++] << f, f += 8;
          }
          switch (a.last = d & 1, d >>>= 1, f -= 1, d & 3) {
            case 0:
              a.mode = yd;
              break;
            case 1:
              if (K3(a), a.mode = Fr, t === zr) {
                d >>>= 2, f -= 2;
                break e;
              }
              break;
            case 2:
              a.mode = vd;
              break;
            case 3:
              e.msg = "invalid block type", a.mode = ie;
          }
          d >>>= 2, f -= 2;
          break;
        case yd:
          for (d >>>= f & 7, f -= f & 7; f < 32; ) {
            if (s === 0)
              break e;
            s--, d += n[c++] << f, f += 8;
          }
          if ((d & 65535) !== (d >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", a.mode = ie;
            break;
          }
          if (a.length = d & 65535, d = 0, f = 0, a.mode = mi, t === zr)
            break e;
        case mi:
          a.mode = wd;
        case wd:
          if (u = a.length, u) {
            if (u > s && (u = s), u > o && (u = o), u === 0)
              break e;
            r.set(n.subarray(c, c + u), i), s -= u, c += u, o -= u, i += u, a.length -= u;
            break;
          }
          a.mode = gt;
          break;
        case vd:
          for (; f < 14; ) {
            if (s === 0)
              break e;
            s--, d += n[c++] << f, f += 8;
          }
          if (a.nlen = (d & 31) + 257, d >>>= 5, f -= 5, a.ndist = (d & 31) + 1, d >>>= 5, f -= 5, a.ncode = (d & 15) + 4, d >>>= 4, f -= 4, a.nlen > 286 || a.ndist > 30) {
            e.msg = "too many length or distance symbols", a.mode = ie;
            break;
          }
          a.have = 0, a.mode = xd;
        case xd:
          for (; a.have < a.ncode; ) {
            for (; f < 3; ) {
              if (s === 0)
                break e;
              s--, d += n[c++] << f, f += 8;
            }
            a.lens[J[a.have++]] = d & 7, d >>>= 3, f -= 3;
          }
          for (; a.have < 19; )
            a.lens[J[a.have++]] = 0;
          if (a.lencode = a.lendyn, a.lenbits = 7, C = { bits: a.lenbits }, I = In(B3, a.lens, 0, 19, a.lencode, 0, a.work, C), a.lenbits = C.bits, I) {
            e.msg = "invalid code lengths set", a.mode = ie;
            break;
          }
          a.have = 0, a.mode = Ed;
        case Ed:
          for (; a.have < a.nlen + a.ndist; ) {
            for (; m = a.lencode[d & (1 << a.lenbits) - 1], g = m >>> 24, v = m >>> 16 & 255, S = m & 65535, !(g <= f); ) {
              if (s === 0)
                break e;
              s--, d += n[c++] << f, f += 8;
            }
            if (S < 16)
              d >>>= g, f -= g, a.lens[a.have++] = S;
            else {
              if (S === 16) {
                for (x = g + 2; f < x; ) {
                  if (s === 0)
                    break e;
                  s--, d += n[c++] << f, f += 8;
                }
                if (d >>>= g, f -= g, a.have === 0) {
                  e.msg = "invalid bit length repeat", a.mode = ie;
                  break;
                }
                _ = a.lens[a.have - 1], u = 3 + (d & 3), d >>>= 2, f -= 2;
              } else if (S === 17) {
                for (x = g + 3; f < x; ) {
                  if (s === 0)
                    break e;
                  s--, d += n[c++] << f, f += 8;
                }
                d >>>= g, f -= g, _ = 0, u = 3 + (d & 7), d >>>= 3, f -= 3;
              } else {
                for (x = g + 7; f < x; ) {
                  if (s === 0)
                    break e;
                  s--, d += n[c++] << f, f += 8;
                }
                d >>>= g, f -= g, _ = 0, u = 11 + (d & 127), d >>>= 7, f -= 7;
              }
              if (a.have + u > a.nlen + a.ndist) {
                e.msg = "invalid bit length repeat", a.mode = ie;
                break;
              }
              for (; u--; )
                a.lens[a.have++] = _;
            }
          }
          if (a.mode === ie)
            break;
          if (a.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", a.mode = ie;
            break;
          }
          if (a.lenbits = 9, C = { bits: a.lenbits }, I = In(wl, a.lens, 0, a.nlen, a.lencode, 0, a.work, C), a.lenbits = C.bits, I) {
            e.msg = "invalid literal/lengths set", a.mode = ie;
            break;
          }
          if (a.distbits = 6, a.distcode = a.distdyn, C = { bits: a.distbits }, I = In(vl, a.lens, a.nlen, a.ndist, a.distcode, 0, a.work, C), a.distbits = C.bits, I) {
            e.msg = "invalid distances set", a.mode = ie;
            break;
          }
          if (a.mode = Fr, t === zr)
            break e;
        case Fr:
          a.mode = Vr;
        case Vr:
          if (s >= 6 && o >= 258) {
            e.next_out = i, e.avail_out = o, e.next_in = c, e.avail_in = s, a.hold = d, a.bits = f, N3(e, b), i = e.next_out, r = e.output, o = e.avail_out, c = e.next_in, n = e.input, s = e.avail_in, d = a.hold, f = a.bits, a.mode === gt && (a.back = -1);
            break;
          }
          for (a.back = 0; m = a.lencode[d & (1 << a.lenbits) - 1], g = m >>> 24, v = m >>> 16 & 255, S = m & 65535, !(g <= f); ) {
            if (s === 0)
              break e;
            s--, d += n[c++] << f, f += 8;
          }
          if (v && !(v & 240)) {
            for (y = g, O = v, E = S; m = a.lencode[E + ((d & (1 << y + O) - 1) >> y)], g = m >>> 24, v = m >>> 16 & 255, S = m & 65535, !(y + g <= f); ) {
              if (s === 0)
                break e;
              s--, d += n[c++] << f, f += 8;
            }
            d >>>= y, f -= y, a.back += y;
          }
          if (d >>>= g, f -= g, a.back += g, a.length = S, v === 0) {
            a.mode = Ad;
            break;
          }
          if (v & 32) {
            a.back = -1, a.mode = gt;
            break;
          }
          if (v & 64) {
            e.msg = "invalid literal/length code", a.mode = ie;
            break;
          }
          a.extra = v & 15, a.mode = kd;
        case kd:
          if (a.extra) {
            for (x = a.extra; f < x; ) {
              if (s === 0)
                break e;
              s--, d += n[c++] << f, f += 8;
            }
            a.length += d & (1 << a.extra) - 1, d >>>= a.extra, f -= a.extra, a.back += a.extra;
          }
          a.was = a.length, a.mode = Td;
        case Td:
          for (; m = a.distcode[d & (1 << a.distbits) - 1], g = m >>> 24, v = m >>> 16 & 255, S = m & 65535, !(g <= f); ) {
            if (s === 0)
              break e;
            s--, d += n[c++] << f, f += 8;
          }
          if (!(v & 240)) {
            for (y = g, O = v, E = S; m = a.distcode[E + ((d & (1 << y + O) - 1) >> y)], g = m >>> 24, v = m >>> 16 & 255, S = m & 65535, !(y + g <= f); ) {
              if (s === 0)
                break e;
              s--, d += n[c++] << f, f += 8;
            }
            d >>>= y, f -= y, a.back += y;
          }
          if (d >>>= g, f -= g, a.back += g, v & 64) {
            e.msg = "invalid distance code", a.mode = ie;
            break;
          }
          a.offset = S, a.extra = v & 15, a.mode = Sd;
        case Sd:
          if (a.extra) {
            for (x = a.extra; f < x; ) {
              if (s === 0)
                break e;
              s--, d += n[c++] << f, f += 8;
            }
            a.offset += d & (1 << a.extra) - 1, d >>>= a.extra, f -= a.extra, a.back += a.extra;
          }
          if (a.offset > a.dmax) {
            e.msg = "invalid distance too far back", a.mode = ie;
            break;
          }
          a.mode = Cd;
        case Cd:
          if (o === 0)
            break e;
          if (u = b - o, a.offset > u) {
            if (u = a.offset - u, u > a.whave && a.sane) {
              e.msg = "invalid distance too far back", a.mode = ie;
              break;
            }
            u > a.wnext ? (u -= a.wnext, h = a.wsize - u) : h = a.wnext - u, u > a.length && (u = a.length), p = a.window;
          } else
            p = r, h = i - a.offset, u = a.length;
          u > o && (u = o), o -= u, a.length -= u;
          do
            r[i++] = p[h++];
          while (--u);
          a.length === 0 && (a.mode = Vr);
          break;
        case Ad:
          if (o === 0)
            break e;
          r[i++] = a.length, o--, a.mode = Vr;
          break;
        case gi:
          if (a.wrap) {
            for (; f < 32; ) {
              if (s === 0)
                break e;
              s--, d |= n[c++] << f, f += 8;
            }
            if (b -= o, e.total_out += b, a.total += b, a.wrap & 4 && b && (e.adler = a.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            a.flags ? ue(a.check, r, b, i - b) : zn(a.check, r, b, i - b)), b = o, a.wrap & 4 && (a.flags ? d : Nd(d)) !== a.check) {
              e.msg = "incorrect data check", a.mode = ie;
              break;
            }
            d = 0, f = 0;
          }
          a.mode = Od;
        case Od:
          if (a.wrap && a.flags) {
            for (; f < 32; ) {
              if (s === 0)
                break e;
              s--, d += n[c++] << f, f += 8;
            }
            if (a.wrap & 4 && d !== (a.total & 4294967295)) {
              e.msg = "incorrect length check", a.mode = ie;
              break;
            }
            d = 0, f = 0;
          }
          a.mode = Id;
        case Id:
          I = j3;
          break e;
        case ie:
          I = xl;
          break e;
        case kl:
          return El;
        case Tl:
        default:
          return Me;
      }
  return e.next_out = i, e.avail_out = o, e.next_in = c, e.avail_in = s, a.hold = d, a.bits = f, (a.wsize || b !== e.avail_out && a.mode < ie && (a.mode < gi || t !== od)) && Il(e, e.output, e.next_out, b - e.avail_out), l -= e.avail_in, b -= e.avail_out, e.total_in += l, e.total_out += b, a.total += b, a.wrap & 4 && b && (e.adler = a.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  a.flags ? ue(a.check, r, b, e.next_out - b) : zn(a.check, r, b, e.next_out - b)), e.data_type = a.bits + (a.last ? 64 : 0) + (a.mode === gt ? 128 : 0) + (a.mode === Fr || a.mode === mi ? 256 : 0), (l === 0 && b === 0 || t === od) && I === ga && (I = M3), I;
}, Y3 = (e) => {
  if (Oa(e))
    return Me;
  let t = e.state;
  return t.window && (t.window = null), e.state = null, ga;
}, X3 = (e, t) => {
  if (Oa(e))
    return Me;
  const a = e.state;
  return a.wrap & 2 ? (a.head = t, t.done = !1, ga) : Me;
}, J3 = (e, t) => {
  const a = t.length;
  let n, r, c;
  return Oa(e) || (n = e.state, n.wrap !== 0 && n.mode !== ic) ? Me : n.mode === ic && (r = 1, r = zn(r, t, a, 0), r !== n.check) ? xl : (c = Il(e, t, a, a), c ? (n.mode = kl, El) : (n.havedict = 1, ga));
};
var Q3 = Cl, e4 = Al, t4 = Sl, a4 = W3, n4 = Ol, r4 = G3, c4 = Y3, i4 = X3, s4 = J3, o4 = "pako inflate (from Nodeca project)", wt = {
  inflateReset: Q3,
  inflateReset2: e4,
  inflateResetKeep: t4,
  inflateInit: a4,
  inflateInit2: n4,
  inflate: r4,
  inflateEnd: c4,
  inflateGetHeader: i4,
  inflateSetDictionary: s4,
  inflateInfo: o4
};
function d4() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var f4 = d4;
const Nl = Object.prototype.toString, {
  Z_NO_FLUSH: l4,
  Z_FINISH: u4,
  Z_OK: qn,
  Z_STREAM_END: wi,
  Z_NEED_DICT: vi,
  Z_STREAM_ERROR: b4,
  Z_DATA_ERROR: Pd,
  Z_MEM_ERROR: h4
} = kr;
function zs(e) {
  this.options = Zc.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(e && e.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15 || (t.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new _l(), this.strm.avail_out = 0;
  let a = wt.inflateInit2(
    this.strm,
    t.windowBits
  );
  if (a !== qn)
    throw new Error(Xa[a]);
  if (this.header = new f4(), wt.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = Vn.string2buf(t.dictionary) : Nl.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (a = wt.inflateSetDictionary(this.strm, t.dictionary), a !== qn)))
    throw new Error(Xa[a]);
}
zs.prototype.push = function(e, t) {
  const a = this.strm, n = this.options.chunkSize, r = this.options.dictionary;
  let c, i, s;
  if (this.ended)
    return !1;
  for (t === ~~t ? i = t : i = t === !0 ? u4 : l4, Nl.call(e) === "[object ArrayBuffer]" ? a.input = new Uint8Array(e) : a.input = e, a.next_in = 0, a.avail_in = a.input.length; ; ) {
    for (a.avail_out === 0 && (a.output = new Uint8Array(n), a.next_out = 0, a.avail_out = n), c = wt.inflate(a, i), c === vi && r && (c = wt.inflateSetDictionary(a, r), c === qn ? c = wt.inflate(a, i) : c === Pd && (c = vi)); a.avail_in > 0 && c === wi && a.state.wrap > 0 && e[a.next_in] !== 0; )
      wt.inflateReset(a), c = wt.inflate(a, i);
    switch (c) {
      case b4:
      case Pd:
      case vi:
      case h4:
        return this.onEnd(c), this.ended = !0, !1;
    }
    if (s = a.avail_out, a.next_out && (a.avail_out === 0 || c === wi))
      if (this.options.to === "string") {
        let o = Vn.utf8border(a.output, a.next_out), d = a.next_out - o, f = Vn.buf2string(a.output, o);
        a.next_out = d, a.avail_out = n - d, d && a.output.set(a.output.subarray(o, o + d), 0), this.onData(f);
      } else
        this.onData(a.output.length === a.next_out ? a.output : a.output.subarray(0, a.next_out));
    if (!(c === qn && s === 0)) {
      if (c === wi)
        return c = wt.inflateEnd(this.strm), this.onEnd(c), this.ended = !0, !0;
      if (a.avail_in === 0)
        break;
    }
  }
  return !0;
};
zs.prototype.onData = function(e) {
  this.chunks.push(e);
};
zs.prototype.onEnd = function(e) {
  e === qn && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = Zc.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
const { Deflate: Dp, deflate: Bp, deflateRaw: Zp, gzip: p4 } = O3;
var m4 = p4, Rl = { exports: {} };
(function(e) {
  (function(t, a, n) {
    e.exports ? e.exports = n() : a[t] = n();
  })("urljoin", kn, function() {
    function t(a) {
      var n = [];
      if (a.length === 0)
        return "";
      if (typeof a[0] != "string")
        throw new TypeError("Url must be a string. Received " + a[0]);
      if (a[0].match(/^[^/:]+:\/*$/) && a.length > 1) {
        var r = a.shift();
        a[0] = r + a[0];
      }
      a[0].match(/^file:\/\/\//) ? a[0] = a[0].replace(/^([^/:]+):\/*/, "$1:///") : a[0] = a[0].replace(/^([^/:]+):\/*/, "$1://");
      for (var c = 0; c < a.length; c++) {
        var i = a[c];
        if (typeof i != "string")
          throw new TypeError("Url must be a string. Received " + i);
        i !== "" && (c > 0 && (i = i.replace(/^[\/]+/, "")), c < a.length - 1 ? i = i.replace(/[\/]+$/, "") : i = i.replace(/[\/]+$/, "/"), n.push(i));
      }
      var s = n.join("/");
      s = s.replace(/\/(\?|&|#[^!])/g, "$1");
      var o = s.split("?");
      return s = o.shift() + (o.length > 0 ? "?" : "") + o.join("&"), s;
    }
    return function() {
      var a;
      return typeof arguments[0] == "object" ? a = arguments[0] : a = [].slice.call(arguments), t(a);
    };
  });
})(Rl);
var g4 = Rl.exports;
const Pl = /* @__PURE__ */ Hf(g4);
var _4 = Object.defineProperty, Ae = (e, t) => {
  for (var a in t)
    _4(e, a, { get: t[a], enumerable: !0 });
}, Ll = {};
Ae(Ll, {
  ALPHA: () => C4,
  API_VERSION: () => Hl,
  BETA: () => A4,
  BaseUrl: () => zl,
  CONSTANT_POINTS: () => I4,
  EC_ORDER: () => S4,
  FIELD_GEN: () => k4,
  FIELD_PRIME: () => E4,
  FIELD_SIZE: () => T4,
  IS_BROWSER: () => Fs,
  MASK_250: () => Ml,
  MASK_251: () => x4,
  MAX_ECDSA_VAL: () => O4,
  NetworkName: () => Fl,
  StarknetChainId: () => Vl,
  TransactionHashPrefix: () => ql,
  UDC: () => ia,
  ZERO: () => Ie
});
var y4 = {};
Ae(y4, {
  IS_BROWSER: () => Fs,
  addHexPrefix: () => Be,
  arrayBufferToString: () => $l,
  btoaUniversal: () => Dl,
  buf2hex: () => Bl,
  calcByteLength: () => jl,
  padLeft: () => Zl,
  removeHexPrefix: () => bn,
  sanitizeBytes: () => Ul,
  sanitizeHex: () => v4,
  utf8ToArray: () => Uc
});
var Fs = typeof window < "u", Vs = "0";
function $l(e) {
  return new Uint8Array(e).reduce((t, a) => t + String.fromCharCode(a), "");
}
function Dl(e) {
  return Fs ? btoa($l(e)) : Buffer.from(e).toString("base64");
}
function Bl(e) {
  return [...e].map((t) => t.toString(16).padStart(2, "0")).join("");
}
function bn(e) {
  return e.replace(/^0x/i, "");
}
function Be(e) {
  return `0x${bn(e)}`;
}
function w4(e, t, a, n = Vs) {
  const r = t - e.length;
  let c = e;
  if (r > 0) {
    const i = n.repeat(r);
    c = a ? i + e : e + i;
  }
  return c;
}
function Zl(e, t, a = Vs) {
  return w4(e, t, !0, a);
}
function jl(e, t = 8) {
  const a = e % t;
  return a ? (e - a) / t * t + t : e;
}
function Ul(e, t = 8, a = Vs) {
  return Zl(e, jl(e.length, t), a);
}
function v4(e) {
  return e = bn(e), e = Ul(e, 2), e && (e = Be(e)), e;
}
function Uc(e) {
  return new TextEncoder().encode(e);
}
var Ie = 0n, Ml = 2n ** 250n - 1n, x4 = 2n ** 251n, Hl = Ie, zl = /* @__PURE__ */ ((e) => (e.SN_MAIN = "https://alpha-mainnet.starknet.io", e.SN_GOERLI = "https://alpha4.starknet.io", e.SN_GOERLI2 = "https://alpha4-2.starknet.io", e))(zl || {}), Fl = /* @__PURE__ */ ((e) => (e.SN_MAIN = "SN_MAIN", e.SN_GOERLI = "SN_GOERLI", e.SN_GOERLI2 = "SN_GOERLI2", e))(Fl || {}), Vl = /* @__PURE__ */ ((e) => (e.SN_MAIN = "0x534e5f4d41494e", e.SN_GOERLI = "0x534e5f474f45524c49", e.SN_GOERLI2 = "0x534e5f474f45524c4932", e))(Vl || {}), ql = /* @__PURE__ */ ((e) => (e.DECLARE = "0x6465636c617265", e.DEPLOY = "0x6465706c6f79", e.DEPLOY_ACCOUNT = "0x6465706c6f795f6163636f756e74", e.INVOKE = "0x696e766f6b65", e.L1_HANDLER = "0x6c315f68616e646c6572", e))(ql || {}), ia = {
  ADDRESS: "0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf",
  ENTRYPOINT: "deployContract"
}, E4 = "800000000000011000000000000000000000000000000000000000000000001", k4 = "3", T4 = 251, S4 = "800000000000010FFFFFFFFFFFFFFFFB781126DCAE7B2321E66A241ADC64D2F", C4 = "1", A4 = "6F21413EFBE40DE150E596D72F7A8C5609AD26C15C915C1F4CDFCB99CEE9E89", O4 = "800000000000000000000000000000000000000000000000000000000000000", I4 = [
  [
    "49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804",
    "3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a"
  ],
  [
    "1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca",
    "5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f"
  ],
  [
    "234287dcbaffe7f969c748655fca9e58fa8120b6d56eb0c1080d17957ebe47b",
    "3b056f100f96fb21e889527d41f4e39940135dd7a6c94cc6ed0268ee89e5615"
  ],
  [
    "3909690e1123c80678a7ba0fde0e8447f6f02b3f6b960034d1e93524f8b476",
    "7122e9063d239d89d4e336753845b76f2b33ca0d7f0c1acd4b9fe974994cc19"
  ],
  [
    "40fd002e38ea01a01b2702eb7c643e9decc2894cbf31765922e281939ab542c",
    "109f720a79e2a41471f054ca885efd90c8cfbbec37991d1b6343991e0a3e740"
  ],
  [
    "2f52066635c139fc2f64eb0bd5e3fd7a705f576854ec4f00aa60361fddb981b",
    "6d78a24d8a5f97fc600318ce16b3c840315979c3273078ec1a285f217ee6a26"
  ],
  [
    "6a0767a1fd60d5b9027a35af1b68e57a1c366ebcde2006cdd07af27043ef674",
    "606b72c0ca0498b8c1817ed7922d550894c324f5efdfc85a19a1ae382411ca2"
  ],
  [
    "7fa463ee2a2d6a585d5c3358918270f6c28c66df1f86803374d1edf3819cc62",
    "a996edf01598832e644e1cae9a37288865ad80e2787f9bf958aceccc99afae"
  ],
  [
    "3d4da70d1540da597dbae1651d28487604a4e66a4a1823b97e8e9639393dbec",
    "45cdef70c35d3b6f0a2273a9886ccb6306d813e8204bdfd30b4efee63c8a3f9"
  ],
  [
    "1e448fdbcd9896c6fbf5f36cb7e7fcb77a751ff2d942593cae023363cc7750e",
    "30c81da0f3a8cb64468eaa491c7ae7b4842b62cb4148820da211afc4caffb3a"
  ],
  [
    "6531acf1a7cb90a4eb27de0b7f915e387a3b0fd063ba6e1289b91f48411be26",
    "31330f5daa091889981a3ea782ae997f5f171336ed0487a03f051551a2cafa2"
  ],
  [
    "54be016394d5662d67d7e82f5e889ed2f97ccf95d911f57dd2362c4040ed4f4",
    "c6cb184053f054d6a59c1bf0986d17090d25089b3fdcdaf185edc87ef113e5"
  ],
  [
    "35b9ecd0499ca1d5d42dcbb0c6b4042b3733c64b607ca711e706e786ef2afc6",
    "5624b476a5b21c3a544f0712d4817b06ad380a5a6529d323bf64da8ef862d8d"
  ],
  [
    "4ce0378e3ee8f77ed58f2ddbd8bb7676c8a38bfb1d3694c275254bd8ca38e23",
    "5a16fcbff0769c9cf2b02c31621878ec819fff4b8231bff82c6183db2746820"
  ],
  [
    "648d5c6f98680a1b926bfeb01c00224c56fdcf751b251c4449c8a94f425cfcf",
    "72c05ac793cd1620a833fbe2214d36900ebe446e095c62fcb740937f98cca8c"
  ],
  [
    "bd09be3e4e1af8a14189977e334f097c18e4a8bf42577ef5aafa0f807bd89b",
    "6e0e72ed7eb65c86cee29c411fb4761122558ee81013344ba8509c49de9f9b6"
  ],
  [
    "35ea4e339b44ae7724419bdfbe07022253137a4afb7cbaffad341ea61249357",
    "3665d676a026a174f367bb4417780e53a7803cb02d0db32eb4545c267c42f14"
  ],
  [
    "36457bc744f42e697b825c2d1afd8f4029d696a4514710f81da52d88e178643",
    "7c93715896735492a68c7969a024b3a8fd538bffc1521538107de1a5f13ce9c"
  ],
  [
    "5b3a08ebcf9c109cc9082f70d9df2b9c11b5428ee23917b4e790c4c10f6e661",
    "9d7b42ab0c20f5510df7ea5e196eec99342739077e9a168198c89da859753"
  ],
  [
    "21883ef8580fc06e59481955d52ece3aca6e82c8c9fc58e216dcf46f96990c6",
    "51a6423543e6e8a43e71da34cd90f5b520b8d33b67c4bf857573ab9e301aa4c"
  ],
  [
    "19e86b77f9b581e81092b305c852faf53940a8f15f0a6990c414f04c0fa7ef9",
    "515630e35d4398c9c79fc4ee08e1023fa47d8e03c6e7819c6d2ccef45398fa"
  ],
  [
    "888ab8eb4c31bb2ac5b54aa320dbe1a69c96b864e8a5f54d89c1d1a6b86c24",
    "730e148467f6a55ce22c5296f5380df88f38de76ef0b2de844cd3094aaaf3ea"
  ],
  [
    "75e79ff13a894e7120dac17b7429c0c32ce7828f726c9973728c0977a5f5977",
    "4960526e59c1c736561a201bc56f7d762641b39f609d273cc996f5d9197cfb8"
  ],
  [
    "640fe009249115d7254f72ecafb3006139e4bed7e9041af51458c737282d1d5",
    "3cc6c978a575246e2ce4f7ef1fcc7f63085db9ff98a1b1f3fe374087c0332c"
  ],
  [
    "6d6fd09ccab7c26de9b3906191235deb5c34685580c488275356a05e209ca96",
    "7157f81a34213dd8f91dea4f6df1bcfabc4ee091a3049eeeb3b7923d39b8645"
  ],
  [
    "5531ca1d00f151d71da820918f74caf2985b24dca20e124721fff507b5a5876",
    "518529643d3f25e47f72c322223ba60a63d6bfe78cf3f612215d9c19bf29200"
  ],
  [
    "6192d454e4f8fe212bdfccd5b15dd5056d7622ffe456c6c67e5a7265aea49c4",
    "2377a45dc630017ae863cb968ddb38333a70c7946d8684e6d7a6213f634b7bc"
  ],
  [
    "542fb44b4ef3640a64fdb22a2560fb26668065c069cf31d1df424819a39ff18",
    "5dbae9b0948e0361aea443503840341c322aa1a1366ce5390e71bf161f78f8c"
  ],
  [
    "299ff3e3412a7eb4cb4a3051b07b1be2e7b1c4b789f39ffb52cba3d048b71de",
    "1951d3175c02761b291d86b6c0a08387ad5e2a2130ccc33c852530572cb3958"
  ],
  [
    "628ce3f5367dadc1411133e55eb25e2e3c2880d6e28754a5cb1c5d109627e73",
    "ae3e9b7d50964e28bd15380400b7659b87affdef5d2586cbefcd9be7d67c0d"
  ],
  [
    "6ea54aff064895eccf9db2283225d62044ae67621192b3346338948382f5933",
    "6431507e51aadacfaf39f102a8ff387756e9b5e1bc8323d44acae55130d93db"
  ],
  [
    "28097d50d175a6235320fe8cfe138dd9e46895d189582e472c38ad7a67d923a",
    "7f9eab4133d7d09a7ff63368d6135c26262b62336eca1b5ca33f2096ce388ba"
  ],
  [
    "619fd09cdd6ff4323973f256c2cbdcb224f7f25b8aef623af2d4a0105e62e02",
    "2c95f0ae11d47eeae1bc7f1350f75f9185c5bc840382ceb38a797cae9c40308"
  ],
  [
    "641c18982ced304512a3f2395942a38add0d6a7156229c2a7c8b8dfbe9beb96",
    "6f6288c9c659b6af5ac975f4180deffe53d516399b2cc62f31732e9d4ba9837"
  ],
  [
    "58ab546e51fe49fc5a382e4064a2bd6cfc268904412f86c26de14f28a71d0f2",
    "124b7217943e7e328408e8afdfa7da00dcbc94a2bb85fd8e01fb162d2c2c0a9"
  ],
  [
    "a82c2fdedbb26c3c762a12f7e86b0e01e65320e0a25a8399d665f6e266bf74",
    "1a1de28e253f3e10f44d0111e8074f882d7f42e5900780ccbdc31da372d3fd8"
  ],
  [
    "744c725a7455a992e3cf5bd007bc234dd4668dba285f553f38350ad94c1615b",
    "7f721a87f48798bdc4a9c0eb88559e2ad7a74112fd901e70ea159e67a9c33f"
  ],
  [
    "434df142ddaa60f7881b6348d91687de40457de7ccfb07f0304b9e820705d0c",
    "7fae425e3b53f97dd1f5b20e49ed9fe24ff1efc341ba5e017ac89cf8df0cc39"
  ],
  [
    "7a1e2b809dff46277021cbc376f79c37e1b683bbd6bca5317014f0dc0e1ae73",
    "56790278a231912c334eff05281e08af1558e85516b4411ef64647c13bea431"
  ],
  [
    "4931b7990348d41cf8907be79f45bb7991fd18f8a57868351c92fa7a34cbcd7",
    "ca35091815cdf0837d396e25aad6052ad32d497a33b123256cffdc008bc50e"
  ],
  [
    "250b815d352fd89f8210b624b147ea7d0a4f47bcac49f3ac9b777840da93ebe",
    "1173f10e9691948b7da7632f328520455aadcba46e017f891e0a1d7da2bef04"
  ],
  [
    "2223b85032fa67292f6e1f822628e6756e5c3cc08fc252ab88d63d624e4dfb2",
    "55619ba96a7dcec77832fcb22cd5c21c7dcebc0280d730cba0002b67e0a8c63"
  ],
  [
    "249b131e04de73af9820d3e22492d9ec51bdc0c4c4f34d95352fa44dd61f245",
    "7576d3b5d136368ff01170a77d8286d0d1c7c40688862fb40813b4af3c6065e"
  ],
  [
    "6777915d9b4769027eb7e04733f8a2d669c84fe06080f55e8a55674dfbf9efb",
    "640d0ff384c9635e1af364760f104e058e3c86209fa9d2320aeac887b2e02d8"
  ],
  [
    "2abe3f237681052f002414399111cf07f8421535af41251edc427a36b5b19c9",
    "636ce4deaf468a503ab20ccb2f7e5bdc98551656ebf53e9c7786b11dd9090be"
  ],
  [
    "4d5cc5414758ea1be55be779bd7da296c7e11f1564d9e8797ceea347c16f8ea",
    "1a680c4c410cf5ddc74e95ff2897c193edaaecce5b2cde4e96bbae5c0054eff"
  ],
  [
    "46c375c684b30adf4d51de81e92afee52b1a3847e177403372c82109373edca",
    "1eaadc5783c90a0261306423d52009e991126b3f620e9cb6cffca41ca096f4f"
  ],
  [
    "2ddfb71f51205888118cbabba8fd07d460a810289bfdeeb7118707e310cb152",
    "1fd905d07b3933be886f2518246bdafa6f33259a174668808223cd7c28183c7"
  ],
  [
    "386f3879960713d41fdb3b1e41bbebf26b1c0e27a9a75bb1adcc1a0d3e8547b",
    "2b21498c0f34ec6f17c720334dc0f36021c2f87afbbbc8847d0bd536eb265e5"
  ],
  [
    "407eae62c6c4de3b942195afec3f45efec71ddb5e6edee3d427631bcdbf9b90",
    "436e7f2d78268ef62c4172d2ff1469028bad1f1d0f97ab007064418e61caa8f"
  ],
  [
    "1b881175e21201d17e095e9b3966b354f47de8c1acee5177f5909e0fd72328f",
    "69954b1a9b8bfccf8ec384d32924518a935758f3d3662ef754bcc88f1f6f3ec"
  ],
  [
    "7d545a82bff003b8115be32a0c437f7c0a98f776bcf7fddb0392822844f3c5e",
    "34b6e53a9565a7daa010711f5bf72254a4e61da3e6a562210a9abc9e8b66d69"
  ],
  [
    "299b9fcd4fadfc4b6141457a3036aaa68501c23df579de26df69d4def89b913",
    "b95bf2c2bb303c38bb396382edc798ca6a4847e573ce19b7b08533d1912675"
  ],
  [
    "551f5a4dae4a341a3e20336a7d2f365ddd45849351ec6dd4fcbedfe4806d5d5",
    "5865c977a0ecf13ce85ae14c5c316872080bd36f0f614f56b6dfc7ece83792e"
  ],
  [
    "7a1d69c08e68c80ad8b310736e6247a53bcba0183b9b8798833bc696a0fb6e2",
    "3ce803a20ebb3b120d5eaf0ad64bed0522fad1a0f2ce39a5c5cbae98c4438f6"
  ],
  [
    "28acacc0bc41d84e83663f02b36981a2c8272ecd72d3901164be2affb09c504",
    "7a5aee0b160eaff5b5968ab1a0304ce58c3d5ae0148d9191c39e87668229e5b"
  ],
  [
    "1f78cfdbcc767b68e69a224a077468cdfcb0afd6952b85bccbdb96d1fb8500b",
    "4772ba173c6b583284eb001cfc2a124104833f464ff9df096443e10ef3e9dd4"
  ],
  [
    "2774108962ca9897e7f22c064d2ccedac4fef5fc9569331c27cdc336c95774b",
    "9e13d79b68e8dc8091c019618f5b07283a710ddf1733dc674a99fc32c12911"
  ],
  [
    "770d116415cd2c4ace0d8b721dd77e4a2ef766591f9ec9fa0b61304548994ed",
    "42165d93c82f687635aa2b68492b3adffd516beb4baa94520efa11467a209fd"
  ],
  [
    "5e6e4ece6621e2275415e1fda1e7c4f496de498b77c0b913073c6a6099394b9",
    "3d92ce044fc77fa227adc31f6fc17ef8b4ec1c5aafc44630c0d9195075bf56d"
  ],
  [
    "6e69c717b5d98807ff1e404a5187a9ceaf0110b83aa15a84f930928b1171825",
    "1ee7cfc3a9744d7fa380ba28604af9df33ac077724374c04588bd71fa16b177"
  ],
  [
    "404318f2d2ceb44f549c80f9d7de9879d8f7da4b81e7350c00e974ebf2daef1",
    "3934831b5af70d17a3f1da9d2931bd757e6acf2893236264fc7e0d92ff1a1cb"
  ],
  [
    "20dcb6f394fea6d549b2e75748f61b7ec03b6e52319cb14163373a9c22bb9dc",
    "106a8c96cfb95a331618b7416d1498554730499e194a58fbf63019890480fc7"
  ],
  [
    "119000f277ccee013e6bb121194ec1ab5460fb6a96eb702a14079865f4170aa",
    "1737a32f5415e8720a5606ec1dd4756f02e7c6817e3723b453d091f2d192773"
  ],
  [
    "45d0fb5cd95db76d05dec3faa12e467a308eabaad363a062353db3cd2d9b749",
    "ae08691b5b0cdd19ec499132421638f470f493320e4003d123ab1da761b965"
  ],
  [
    "1257b3e65cdfb6367c6d0942327e799bc66eb221e70c6573a9862889eb51c38",
    "593309fd45755dd2cc4afd2b9316bc4638b0c5ddb3009694fcb7b250d0c8a2f"
  ],
  [
    "186dcf9950f72e868014a8accf14aa36e82a7a2a29f86ba37f6632da4189db3",
    "55684c9f7a043fc523ed78f756f834b4db823d5e4161bd79602c17d55a5cd8c"
  ],
  [
    "58791d5569f282f5c3b01ecdc9388df7ba3ca223a2dc1eed5edaf2a1d302fb9",
    "6298d7dd51561a045bb4089deda9f40b2865589ed433e56d54554f8b45e79f0"
  ],
  [
    "13fd87144aa5aa4b24d5a7bf907d8280d15937fed262d41084898cb688fc28b",
    "3fa54367770cc4479a857411ddcabe86627b405ce1cd14ad3b2863bde13abe4"
  ],
  [
    "48118139445415f0c1879224e2dee744ed35280ff00537260402a1741ec3676",
    "4dfa39dadaabecfc54ecb7a25319444f8e952782d863790e42a9887064fc0c1"
  ],
  [
    "4ad031bb9eda84f2fe5d354c7948d41558ca657a04508654721810ee72ef158",
    "620ebd5d0086b92c6009a42777b946a351c2c7ba852b57d3c9905fc337459ef"
  ],
  [
    "4a34abb016ad8cb4575ea5bd28385d2348e5bcc0cbba90059f90f9c71f86e8b",
    "4f781829ad83f9ed1e1b6de0e5f4ac60dfdfe7f23cb4411e815817e705e52c8"
  ],
  [
    "7fc632d7512aab5356b7915dca854c8b12b369ab54f524fbce352f00eb9b9f9",
    "2ce80b944fc9158005f630b34385d50c3ad84450a9e1e529925b3211dd2a1de"
  ],
  [
    "65ed10347503cbc0216ca03f7536cca16b6abd18d332a9258685907f2e5c23f",
    "3be1a18c6bfa6f2f4898ebefad5a8e844c74626d5baa04a820d407fe28bbca6"
  ],
  [
    "1a8abba1be2e276cdd1f28c912280833a5ede1ec121738fcca47dc070dcc71d",
    "21b724378bc029a5199799df005922590d4e59cae52976f8e437bf6693eec4a"
  ],
  [
    "3a99c22dafcfe9004ebb674805736a26aeed7ed5d465ae37226dcbe270a972b",
    "5bf67552af08e1e6e2a24bf562c23225e89869cab9bef8becb3669175a3c94f"
  ],
  [
    "4a6a5e4b3501f2b7bbdd8da73ea81ffca347170bdfb6776a037cdd74c560fb4",
    "5af167ebb259c2da88740ec559ee04052bb66480b836cadd0e2590c32d7111b"
  ],
  [
    "6890d95308525f0bac9dc25cc1189eb92d29d4b3fe61bc8aee1c716ac17b1e8",
    "e6f23f78e882026b53ea4fac6950e56e3da461e52339eb43d2fdb2dade7ca9"
  ],
  [
    "748f4cf4f027efdeaed7c7f91ef3730ff2f2bb0bfc2db8f27aadde947f7d4d5",
    "3a1cbc550699411052c76293b8c41a3a8a1ecf12cbbc029a1b2b6ea986fca93"
  ],
  [
    "7321f3f581690922cd0dec40c9c352aae412ec2ccdf718f137f7786ab452cd3",
    "5be5130c9277cdb76d7409452438ec15d246b211dd1e276ee58e82a81c98fd4"
  ],
  [
    "6c4d6cb7e7ae70955224b8a912ff57ca218635a2436b36cee25dce8a5cdf51f",
    "32f8c03c6db3246946e432e4148e69f5628b200c6d7d72449df6eeac0998039"
  ],
  [
    "1dad5f2e795ea6fa5177f110989516eacf8fb37bd6a091c7c93f1d73a2fe309",
    "56b2298c538180e99dea3e171dbb5c6fba0bd0a9ed40537277c0c2373a8e2c4"
  ],
  [
    "1610605baacc9bc62c4cc923dc943347cfece7ae241e746fbe6c2c878221dbd",
    "431a82d657e0d109d00dea88cf3fa9b999845221b7b5590a20c40fc71368c1c"
  ],
  [
    "6a4f5c787fb09a5be2b04d2eafa1e6f3d3c863ee22960eb0b64f6eaf6659162",
    "14dbc3eaea6146ee7eaace5a91ed9430dad3a47e9ca2f68b455171f8fe6a7b3"
  ],
  [
    "738415b73e55412b0e582e45ff0d7bf4b1bf2922db581783fdcc75559f40e",
    "33825aeb3fd8459999eb418d15102ba5864b069c6ea517f0c6e9eab8d9aca47"
  ],
  [
    "2603e72ce53985c70782774057a17944f7b4ce224a809be4e2b5af3606aa1d8",
    "92822921809c42318f42dac4d773325f41c43069e990adac7818a45e2554dc"
  ],
  [
    "181cd967ab4615357cc96c82eae9152ce7598c1a1dfdd91a458bddb016ae9fe",
    "5d562fdaeb0e12647e230e50eaf216bed52fa73c6b7378821a3bfc4cd66d4ff"
  ],
  [
    "1121726069b9ef5954ba6490100b226e0be53fef3e071b7c58a1286174b789a",
    "4b25594cf4e9eb2d14b3f52f2661a9992234fc222c0a0d44517cb77deb9c16f"
  ],
  [
    "e543663969b915337f105f80995a77b356f1a51d8b4a4fb12d44364130e873",
    "34b2e3c009fdab4cb7349a580df2e64c0098a123280078e5da6623a9ec6b44f"
  ],
  [
    "4e2f8909bb62de5ef65600e61bbf969293815296b6e23702875e049b3ce5c45",
    "3cb81f2c21f22a7add26fa38a9ce5d9cce1bb251bd2698f90c34ff0a84f7af"
  ],
  [
    "37b546e403a1ba970c17b67c2f1361ab9c803f8d2b5cd93803014faa08861ed",
    "37079184ea46272f5809b523d060686633f7995167897a153be1772fd6566f6"
  ],
  [
    "27bddca77f7bd7f66b3693567a4238f2e6751d95b0bcb409f6b24d08f84798c",
    "6417a85cbfd6fc02df560d3963a241a986baacdfa423f65d7227ce49a96c57d"
  ],
  [
    "2de71a39aa043057d1bc66e45f804542acddf18f7a6d88c0d7fb0ca240debdf",
    "306c1ce39ab46300f7cca0f3a2fbfa77296a27e24bc66b0b8044968ec0ee413"
  ],
  [
    "307c877154364c0c03534e7327d5a88e1380ceef6481567ade37a14ee7c1a72",
    "3404bc7dbfb33b95d922d0693aaf9358f77888d7d95e773c38d83dbe2e5f995"
  ],
  [
    "79f09ff7c60850e5f5ea020722659a1ed27db4c95dca131f99552f785c8afbc",
    "40429528c099349b426ddbf129497176951a64a53db5f9d8bd2be0252cb22b2"
  ],
  [
    "4027dc6b56d446e5972f35464eeac85c5254ef377c902d9fe37aea841bb5292",
    "7c3ea37689ef679fa2f5c7e031a78e23d484a8317990fd34d44d95cc1db3717"
  ],
  [
    "645dbf78a3c228c4b7151450b5e65edb58e71f37e1e4bc5f471e0f1abd6d9c2",
    "15cfe7850f327b256e23b00627451560c5c6ab60db78d45b7ab286afb6f13ab"
  ],
  [
    "1503ca373757677ad1d911a2b599d01c46eb879d1ce21ae171c7e439846a85f",
    "583eb269b7030da6a0c324026919de3f9489d2ff6ae0e6320c36f05469ad66c"
  ],
  [
    "66e1819ba3ec4ad4ae9f7d7588d23baa004e29d3aad2393d52af204a81626ca",
    "505249980cbe6273b82ad5038fe04a981896f4117345ac1abcc67e2525c0ee4"
  ],
  [
    "5ec20dbb290254545f9292c0a8e4fbbfb80ad9aab0a0e0e9e9923f784d70ed1",
    "bdb1ca3a859227cf5d00eaae1f22584e826ed83b7ccdb65483ed5213dc4323"
  ],
  [
    "a5c1a5011f4b81c5c01ef0b07c0fbf0a166de77280f0ae241f2db6cba15194",
    "4444521fb9b33d7dfeb1247d0ee1a2b854ad166cb663d9dd2e686909362a689"
  ],
  [
    "1f35335de40e00c62642dac2fda8b30f071986ce4f11db849df11bc45ad4e0c",
    "7801a2c761b90fd4477ba0be9a775003d5dfcd959b1ed198b4681f15e7acbf"
  ],
  [
    "48db4798cf6821c1ffb8178b1d3bb6020e04186c96aaf4670972d367f4ed5f",
    "781019494df95b888f1578f1b4a3f8e125ea60eca47ef9207a10630671217a3"
  ],
  [
    "17f653d904210148a8e74d8e719a3061683c164aa6d79c902a19f185ab437bd",
    "6780e97985932c3860d810af1e065d454b1cb4be0e7ffe2d8cea7d52526e223"
  ],
  [
    "5c4d0c7432f9b0070436240f9855adae1467cdc9826952ae01b68cd52a3ad89",
    "1c5747f968ed91261b7ae9bf1023c999da9816e37de602d6a1a50d397752bff"
  ],
  [
    "6fedd7639fdaa2f7bad4ca0b391710f6f8a7e890250ae8ae4252bb8b39a1e58",
    "436a215f655a3fd3778b2335ffdc9aca6b98474e43d764c1f8362830b084f0e"
  ],
  [
    "7fbd45a889c5e9d127bb4f8474d6be7cb9796bbfff923b75e42a1ad4cae37d6",
    "484bd12622a6ba81cd53049c550d9ed682a8e765b656b1cbff9bbea637bd1f4"
  ],
  [
    "17d984d47937263f7966a3e7b1eea04071e678494bd749c9e02b48b3234f06d",
    "7b341ff08722c4e161005d0037204a7a2001fdda7af2cc1a0b04a027f115a0f"
  ],
  [
    "7f1822045db45ea07e1519c3ee1f7705915f35fe4dd8db1e8921b5d1c740edf",
    "33d41e06b93320ad1b3d9580380ec797a05dac3f1cc8008899110ebefde2f78"
  ],
  [
    "7b19453ecb74b7d0e2a66b9890ff73bfbbcd61a266abd6d82dbe665bf32f34d",
    "6dba2355420dac582b1f349609ea1c89b89bba2d1a68a0642f1dd12d86e73cb"
  ],
  [
    "273e82a15f395ddf2489a95685bec8bac62c4b459d1b28987d3cb27e4bc9128",
    "653375b48a4cf5d5b101c9ef533039bedce5dbeef3f59e8f168bdc99b06ca5f"
  ],
  [
    "3006c9e7fc6a553d8eb4e8a47ce9f10d1a39576ac255ae9e0a4ce3869e76212",
    "65fe9e2ef2aae608be309332d464f57e28f1df5de1a6a519751b056971f932e"
  ],
  [
    "5e8f384c8a4607fbe9789fcc52d54249d304d698562597d114c1d81452d3dee",
    "3c8bc78066b5d947dc1e405e326ee55ea606c7988f666748d259850fa259a22"
  ],
  [
    "7841b2102e9aa103fb53a642b3e167b21113ea44751ab38e0b5ef8312654db9",
    "71bf5c8308fcf9c4a7847494cd9bdd946fddf7d3a37e8bb0b201ff2343deb8e"
  ],
  [
    "40f68027420c11e3ade9aae041978dc18081c4f94943463aac92d887f922a62",
    "499c6062594a6c7e21a3cb91ea451813393bff365a27a08f1a515439b83cf42"
  ],
  [
    "6ce77a50d038b222634e87948df0590b79d66087b01e42b9b6d8fa30ebb1465",
    "35f5c46bb1be8555a93f155a174d54ec048c2ac8676e7c743054ddc52709d37"
  ],
  [
    "604f8b9f2dacb13d569262864063c2d4bb2b2cd716db6eeb2b1eeabc57746f6",
    "68c6799e24f3b44eec3049973445174727a66970f1614a782efa2b91ab1e457"
  ],
  [
    "73d620f3bfe77f672943d448d7dc05327adf64b8e7af50039c469d7f7c994c4",
    "4859deb36eaf0c802f0d1514602368143a33ec6ce8fd55248b59025debc6afb"
  ],
  [
    "3fd2bcd1c89d706a3647fbd354097f09c76636e93ae504973f944d8fc3bcc1",
    "677ef842cf5eb2444941f527abec567725e469469192354ad509a26ebb3d0e0"
  ],
  [
    "39222ea924ac17b533c72ffb2c47ffdc11d6a7f7c70fbde3a10fb0b8f35eb2f",
    "20dc4bd1089019bc1d7379b4feb3eae6eb5af59e9f253845da9fd633057e952"
  ],
  [
    "326f58994e1347f62e4102183215b5db956378d2f61f14aba4dec94577f53c",
    "7a03284c296003bbe05178a1d82efdb7b8125511d63e20e50aed789c2e52e1"
  ],
  [
    "53aa8939c74d4ee58f03bc88bace5a45c7bfcf27466201da05dc6723a5f5632",
    "2e32535ca7732904a048183247b04b426ecf9b39fc393a9cebe92fb1dc7a7f1"
  ],
  [
    "6cee1a03145e93b3e826e6067005f09c06099c98198c91c222407ba5c8c132e",
    "beaecad1274e7c6e5476a100c271aa1a6f86ee5a9fa5c2f26124d5886fa63"
  ],
  [
    "3ec659b8175e1be1bd5a252108714776b813e330393f587814f5f1f32a73332",
    "529a5cf9f8c237ae69a94217d173c8d19c156952041f5c980da557990863fa7"
  ],
  [
    "3d66ec5963d0c534d4139c8cef2e1ac48b3e7965fafabf58be26f903318af4e",
    "3d3f2de7a95f59b683725ee6283cbaf31f97c4b600df9a4621413223a468740"
  ],
  [
    "7fb38ace8e0932fac2ea0d3eb676db8d684db1817e2e4d59da7996ce398b4a",
    "68f92bd5768cdd4710249f9d49ef1d5654e497b9a4ba10bd2971366d83fb400"
  ],
  [
    "1c4a49314d6b4969cdd142c76ceb7682bfb868ace7f7568b0fc8635bda5a9fb",
    "5fc0519f1f4cc10b5771312458748c036313b87707ed0540026ac64a5955aa9"
  ],
  [
    "3073c95d08d3b97caea5f0be16b2789bee766f76b7e5499f8ce8f96abb0f344",
    "52a8974b4eb9a1f6a0ae2c83cb4715bf18d73f057255fcb3f63b74f7e78f590"
  ],
  [
    "44485b16d597a5de3604df6f7ed7e00b8aeef9e7e8dea8688255153b8bb16aa",
    "6cccb0ba170123266f24b5d93a744397dc2c44820edc4f8f5b9a0f5c9b3b940"
  ],
  [
    "7618f77b7b32d512688dd62e0b48231d9574c6361e8be353a7dc04f7c3a115e",
    "78ffcd16d80636381ca231aae70d99c9e20298b4f5388fd823ea9fa2b8ddfd9"
  ],
  [
    "7dc82fee1ef95cf5b3720fcc07f63246654bfe39762627839da40e51c75654d",
    "4c0ccdd70955da74558de20c88352df8a02aa97e4d5971c500e884740a8cb62"
  ],
  [
    "7fa5d460dc10cbb418b444d9bde97e92c70a99a222b99f244dccee7e62cc04c",
    "636163901baa5b7576c38c43407af578b8c4607e01e86011ae2dde587a89f84"
  ],
  [
    "758930d46006623a756c89bd0cc378f6a3c1f43c9a0edbb42274c35e75c16d2",
    "1d74dd9f81c2fec811b8cbd6168a745b0a111932b2a345265ef2853b50b6245"
  ],
  [
    "7332ee0626b044d664ef228f8cb84df7c643e52f6a2591ae1c9007ad61ec16e",
    "229bd8e630572cbdee54283234cf3e9f060e6382f99943bf234119d47b54470"
  ],
  [
    "78a16ef803aa20a075bb2f66c61bb2dae5698bebb94a0995fa74c3d53de1614",
    "246d588b68edb6fed96c128349908c42dcd64c46341b205e79f4aed9b5d3675"
  ],
  [
    "6e1933939bd03b67bba753cc0cbe7d2f25bad68c993887ef8c9e2fcd59b0647",
    "599413f7c204a11a5ce315eab11299ab7326603412bb00bc1c59ff75a37d6b4"
  ],
  [
    "4a79957a5a1888ad063b51c69565a2b48e8eb917183e220a1c8d3374526d30e",
    "1f092de0e069bba7fc5386e2e9a114c1618f88c4b95e220cd35ffe96f99fcad"
  ],
  [
    "3148aa3df9ece39aca84f59489f2710522216f14be6055ee0027529d1d55e2d",
    "617e9a52a92975db0ba1977f71116f7058a0d31b869ac7f3ee2fd80b0c5100c"
  ],
  [
    "5c1188e72384160ae39d07328346cda4f6c12d227448e6236f04dc971625287",
    "1643006eb3a3bc6aafd5f685cf054f2a572e6ca58c0118bcec0b833741f116d"
  ],
  [
    "3f72efc93c9b71adc4c51d8fc69d3940b20d08733af2b7d05140fdb1d1c1004",
    "7399259987c8f4ebfab46e522380707e58427d3962ee0c2a91760813f76d232"
  ],
  [
    "3129b34c03c51aa8f611e91d5cfcc9bd3ef108ee66e6d3ee35a0e0e50055bb",
    "563b18b5650085efb4cf179a029e6afff27b1d3091cd28eaa68d24fa1f801c6"
  ],
  [
    "16eac0f9fb4c67cf89a7fa4ee615bbe731d8edcb709a1b9b50c7d873a530f52",
    "7ff8288b6e199ca8f316192881424a37fb080c29daa76b1f0edaccaf580a80e"
  ],
  [
    "75f6b6028c43ce832f65d7e8e620d43b16cba215b4b94df5b60fc24e9655ee4",
    "35e9ccfaed2293a8b94b28de03bcb13eb64a26c831e26cc61a39b97969a2ff0"
  ],
  [
    "3c6152fe093bd6316897917ec56a218640ec1b2148f21db9b14fc7a5ff362e8",
    "6eef2df27ae7d63a28856b07b73e7aad7ca94f317201a1e675ffc6f9a1710dd"
  ],
  [
    "54e01b5fe4fd96052aad55b3f26b1d254dfc7e2525fffb9ae0a77eb8cc5579",
    "7c3d39232ab333675b219abc766ed9b4782c840e6b046614dedb8a619696eb0"
  ],
  [
    "d1e63f8ea8a76429cf254a6d3b668761f0dc572d4bfac4fd56d9eaf58fb6c0",
    "2bd0a84d3908a63085824c9329a0983913006ba155b56a58eb3f9becab29c45"
  ],
  [
    "2d6122f2a702edd4da7385b1580796a71d13bd72be94cfb3fec01149c006c2d",
    "70eb282fae992efa6f5915e578b640653549f23385ef3a29ab29b1b9b8ad63b"
  ],
  [
    "752fec14beaadb5ddbba6b3a17fcb86579fa588ef407fad0ea07dbb22a640d3",
    "3feb6728eca21a1e84e8f9f23010387a53a96a1cb62d86fb37996150a1299ef"
  ],
  [
    "63f94a92f27acde8f5ed949b459506f51d70c85bcc61a34d647264ecc53c65e",
    "37e5dce0646ee66f4fdb93b82d54d83a054948fa7d7fa74ab6b36246fc7383e"
  ],
  [
    "d6aa909287a2f05b9528690c741702c4c5f4d486c19a46c38215f52ef79c7b",
    "5ebe1128dd81093df4aca0df365d58adab848d1be1a94b95eeb649afd66a018"
  ],
  [
    "12866812b3053e2f7a9572bdaf5ef2b48c6fb62a0eed9ff0356df50e7d05557",
    "6785f7eb2cd1c120e4c7167b46861d10117040a2e9f2ca86a71e9d67df90613"
  ],
  [
    "46a730d05330b1b13673cb8a1b8f45460035e4a9f1a1751cfba099c4355c1c",
    "76fb0ec6cd16a8141cdcd875c8b2de9fce42d296072643d148ac7e7fa7472df"
  ],
  [
    "4bd4380a22900bd34835e0a908eacf4b6edb61eda0cf483f9212453b37e7516",
    "5e9551cd20d8d7ddbf4366880b7d5267385afa1966ff30da4baaf273b009d29"
  ],
  [
    "71f1994ad40baa2922424ae222663a64f93d8b67929e9a10f9e4c1ab19f3833",
    "85320fe68ec0d37cc19fdfd03589d66906ffa4046c80e1b094a85f27676346"
  ],
  [
    "5a63b1bf5232f28f808765c6be7ce1f81c52145b39f01c879fae0f4303bee61",
    "3bc5d6df68bb6d0577bf9ae2ae59ec0e9b2dc7dd56ea179fb38a41e853db950"
  ],
  [
    "161ded55ff1087032381e6c1449704f63ad2d88df82dfc44a71890fa09b3941",
    "78a52e0013842037274ea75daaf8eb4afc04ccc4b07bfaf3f5ee47d165e01b"
  ],
  [
    "1bfce5229c5fbff5c0f452a22317fcfcd9262f23df41840f84fe7d44cfba1a1",
    "66b387872c00e63c73006a955d42cf49c46c5708fc9d1579b9ae38341b24a3d"
  ],
  [
    "56d47dadc9cbd1dcb2ee3efcd5d4af5e6aea71df10815c68b54a14e81d11b44",
    "47e966ba54df48e9b612a903685e0060a67e4725402e8cb4cf654e54e813a3e"
  ],
  [
    "4b1c44438afd4ddf20a2cf612df2ee494ce84c7274c5529e857693e73018491",
    "430403bd31d8f0677e06abff7159384560f27b9622943fea1a3192f14bf40d4"
  ],
  [
    "7f7281728fc2214aa1dbf13176a4624b53814734abd570eb6ef7c7e32379606",
    "312da47be347fb3fa2c9089b38df372560dcace2effeeacab4d96ab11567295"
  ],
  [
    "16a28884a1be8183e0d3fc0db84a9afbf47126fd3be548c2a584aaafbfa7dfe",
    "7c3f57b3b895564ba562c1cd80b71fda6d2e611665c6ab87744f5390858fe24"
  ],
  [
    "323339f37b327a731232a9580e79952063c7c232bd1380146d8a83c285f4b8b",
    "4f16be1d983c7232f92cce6b9690695978d42cecc8eeb8c206e125d1098a265"
  ],
  [
    "624d26cbaa197e104eb83cebf2adeed09a5cdad359993fe5e3529d4d0def21d",
    "261b7da3cfb55c788977e0d8d640e3e93ae5a325d962ce85c816d7d32cfc430"
  ],
  [
    "f24ecb7ee83a3e28dab54a330dc93d0429a7aea36412e922dce8fbff40d60d",
    "b043e36a258d1df1d21b0cc7be9c4dcae1bd4ed326c110e668ac23d86805a6"
  ],
  [
    "686cea46b710bde1231483bfdbc700cfa3da6ecd5841c0e0c782f9ea24328ec",
    "7eb7407aa58edd6911c7c7e8d1e03bb52ead4a2415a0c33325872ff3a521dd6"
  ],
  [
    "3866ee1186264549df3dfcdf8705c0380c9372eef6d4081c2454d3aded1720e",
    "634c6d3e8eb8af652a4be73e3b613452c2213104ca875b66b4b15ee5b1716af"
  ],
  [
    "484c687cd2969a1d20a58cdfb9a60f280a473284503b1ecff5de514aaf8206b",
    "34d44d26b7427e51a646d1b924084762f5b461685450f21d6a472de565bebd8"
  ],
  [
    "203561333771fa0fe22c4033349f7b877d15b0542a5598e81e067968768247a",
    "2b6a533aff6e2163a36a2a89cb7415848bef48db40f952ffd380f47676707c2"
  ],
  [
    "2ffa6cca6233695760251206fc5e34c8d3692498589478cdd3d5b09f0b7c05d",
    "6c57d605478fa9626c4ed769554d075daa53e1a1d0bd4d94174d3bfeeb11ad6"
  ],
  [
    "5dccf0fa46a5571f204d0b033b45f299cbb3d9f80fded57253ea4f1c64faaef",
    "30a38e131ee8756ee5ea2a3e16618a5dbc28b5b9311308bf037ecc2039dfc7d"
  ],
  [
    "57b0a2eaebeafd950221facdd24790d7d1ab8883e5c5d55635f0d14a1ee4741",
    "7b41cc478fa6be38417271db8ed12efc0da6982552c1496025d2df0576bf4ad"
  ],
  [
    "611b5725101f611c387ccaa13889ecf3bb5595071a179ce350029bfca4ad7f1",
    "3129755977abc8995fec7eec1123a1561e429fde37ff36af002d3211831ecf4"
  ],
  [
    "1c06bbd0c52fdab9fcaf680c7a93fb821e538a2ed79f00f3c34d5afb9ea6b31",
    "3873d3bdfe0be0157bbc141198dc95497823cc222986d24c594b87bd48dc527"
  ],
  [
    "275cdbabc989c615130d36dabfa55ca9d539ed5f67c187444b0a9a12e5b7234",
    "2b7f723e68e579e551115d56f0ae71a3b787b843cc04a35b9f11084b006521"
  ],
  [
    "6cc702eb20f8b5940c7da71f8b1801f55c8c2d8e2e4a3c6c983f00bc1ffdd95",
    "5d15b3727bc66f3aba6d589acdd139fae115232eb845abe61fbdfc51341352e"
  ],
  [
    "44defb418700cee8c9bd696b872adb005490512d8bba081f8f99a9f15cc981c",
    "3b2072cdb1d919b2b65b5cb3557f0a3381d7ca293c267ca4a38f83e77bcc96e"
  ],
  [
    "fd83ce77b1578b3a9b8c3cbeaddb1504d2fd4a19c901c21ac65961224e4966",
    "110cbe64fc10c6b9c66f15ca406a35f50b723b35d83c5eb9797a57f8395f4f9"
  ],
  [
    "9dc6ff90e341875e113bbfb507724dc7095a280d2f32cb6ba61a1e0c2d2aef",
    "4aeb622896c852c2747454e8f172c9482955a42ecbe522d6ce07ecde79d0a51"
  ],
  [
    "71c58b0e47b9dd9107ebd8a8c8fa9f0534e78231bac612c1ddc7a94edf33eb7",
    "7f90edaf4792bf8334adbaa0f4ee7c654312725af188682d75f34874c4eccb9"
  ],
  [
    "1f6de1f14988778ceb2dfe844f92394f1f1e72fd1581ceb3bf336c95ce50345",
    "4f6007ed4e022d2ee9fe4ca8207c5f6c766c4f3b85260e941fb24ad0dcbf0bc"
  ],
  [
    "3ddc3ac25ede4a67a97547ed27dc920239b585fb3624177e2e8d59eba678115",
    "a9afd8f8bb759cbd1dff2addc63f47da4ba1291ea34229c09c0637dc5c8d24"
  ],
  [
    "c56b0269d8431556e471cab9d70edda3a37b391696f107b2dc370631de51d",
    "729c52f6b134f733eb750c14bd9f95c077f0f6f6ff4005701e5bedc6544599d"
  ],
  [
    "44d32ce19ac6807cb22e4f25fe1486a36a13926f147fbfa054b63ff0446177d",
    "212a21e8c124c9cd37c80d2dd66913ceaa6b6f666522f115c39382b2d5925e8"
  ],
  [
    "35dfc16f3ae6ccc06a267bf6d931601e52f3e45359ffc513570b65b96adc4f",
    "74311d10f4bece01b5ae65a6affe5c931463aa1b73a3320eeb41bbb7bb1ff62"
  ],
  [
    "e0acd9d2d907031b319b80121dc90699d003d220ea785d50e5033cdb3b1a03",
    "3911ba78d6e507485d6374b0f7d2e6198f6462a7d6d3cf046404a07af690357"
  ],
  [
    "3c57918ca254c0cb7dac251ef4e10c7d82327969552eae15d26c4c52660922a",
    "5fd5f5ff3f14e671548074114c72c48409df8a2e71fc8aa3c8acb506e2a88df"
  ],
  [
    "222ad8b61e219ba2b581f606b7c996516850a46a3db72fe1f72b5a9be6c324c",
    "72015a5e2db648112abd284fd867b59fc5606645177d26cf6e9a655c9912d42"
  ],
  [
    "3c86d5d774bc614469768ad38f7be9a53e9a233942c5c553b82e49aae684764",
    "480febea8229e130dedffff89c11f3c43e11724e6bd89d5566d78752859d41c"
  ],
  [
    "adb73bb8352d0c10175df371f7868ef2c9e0c79ac788430c480c0f7d85c187",
    "60b564785248111502e6f39c4994d6293fac22bc25f4d764b2fb1957d3c9bd8"
  ],
  [
    "3836ab8b46cf4f453a22532c886940b982029b29c42adca90ded5bf77e6bcb9",
    "7b15e91d6355f147b171a90b064a9d8b2d7bf3699bbf4987664c61c950d8996"
  ],
  [
    "12ed96af1a97c45ec31f1531e96f6fb28a03ba52ab8484545fbe0dddc97bb32",
    "6d1f522b6c6cad0940cff8e23decc72bb8d4164696af031415508b025aa8be1"
  ],
  [
    "27382994ae5878223ef802e9b4882f481a1b4008f1eec8484483471f7aa742b",
    "c31750d242b3975b0026a0e86ccdd17d0f680a8c6f53f197fc25eb1f777917"
  ],
  [
    "431677eba3715455bc235557518a74f3b111a88844ef13e159ad44bc16de3e6",
    "30000e1eb6a17d9df776981e65c6e500fded1ac12003adc9446b269812c9197"
  ],
  [
    "4b563e6f42589671579eabfa2cda5502b361c46a5ac8d45c8ed44741a925b33",
    "627bdb41678443fdd1aa607709e9699b652308615f4bea760a3b79ee0d9ab5c"
  ],
  [
    "2932fd3f81fc973ca9def6b7f1bb50f980fe589187cfe9e9f52ba4d356cf2c8",
    "1e6bfd00fa976c4770263a227048214c38850fe0f059e7b3d2c7871ef07d68f"
  ],
  [
    "e44e4f3d96d9dec775b996be57e57fdc28e7c68023109b221c414a244a0dbc",
    "58b1e52fa274812e5184e00e9ad812bec2463140adfb4bea3b2d665867dcc9"
  ],
  [
    "7fcb89be1f4bec745887bb891e53fefd665c53d00a9e74de16b8a7e1f7adfb5",
    "74af0b06633f779897e199609c71cc5649bbb65bc2c0abd4c678f0480c198d1"
  ],
  [
    "62a381ffb904ea3ff4d451d4c8459457cdbc3dc2fd2da646a95d8c1e90c0b7b",
    "1ba058658e09db9e319fa73de8ab4a992b71e4efc22c273725bdcab84e2a315"
  ],
  [
    "1b0fbb7a84c67e668450a54449c7a46261a2d355589f8b84ebfbaf9a77ee938",
    "44f8fffa33dd33a6146c35d196595e22cc4a215f61ee9197cd751400970a1b"
  ],
  [
    "78fe920bd96a356d4d95ee34adafe8fecf071d3107c36f047b4024ddc4b3eea",
    "6162f29607fdbec10181fbac6e57d5cb41b922c5791fb24bd28bcdd75d16c41"
  ],
  [
    "5629b849e026e65d119ac11821d7ab7efd9c52226f75c7427505d6818bb0c8d",
    "1539c0f90970ee8b490e45bbe5568170e5708521a0e59f976be680595906feb"
  ],
  [
    "62bc853f349bac8c6e5921d27ba85dbd9ba20a375d70a7bc008928f3e123b04",
    "6acfeb1de05ba43c3ef1a9110a983a320e77b3ca294abbc04aeca19b194f26f"
  ],
  [
    "4cf4bed663464418285cbae359b5d84ec76b5997d24f3640984c7663421190f",
    "941f818e3e3e8fb1568da85217d17f9250ebc948379014d900a7b1a848494"
  ],
  [
    "52ff3d9ffe9a302f6dfaaf74bab57c08027d5cb699a69b30830540c0a2d47a1",
    "987dd8876873778d933fbfed37aab2f7d6f669c37024f926b1edcb2ca55782"
  ],
  [
    "1109ee32f0bc53de6bfa457060b366e909d7c18061ec9845f46ac715496897f",
    "38f36f172bdfd454b9285f86e6bdece8fdffc95182c7d801b03c671cc55139b"
  ],
  [
    "4b4482f1d84efe23dadf3bb10df3dcaa251312dcdd604f616f1eb540e1f3232",
    "7c9c149dcae9135f940fb54482f9c3cd8193721643a6e23157b8020410d439c"
  ],
  [
    "69cb459b9e415b7581ca163611c470d875971d5d7949de732d1f0f200544a73",
    "a7136fa9dd00c0469863b7def3f83a5611ed628810d7e807e7a873da5a9897"
  ],
  [
    "b66a4e32ac9a4baa8f64780acd94ed3628b2b0ea874ba4dece629af65f9e62",
    "24328ba9996a24389658e3467b8b90dc3927ef8419fe28b3f55b1c1aaa51915"
  ],
  [
    "5ecc3080062dd451236de0e4eb91c5c75100733364bc5469f5fa76f79021ecb",
    "6da4abb9031a27b5be94529324fad8026e7d871570780081b0f424d4fe543c9"
  ],
  [
    "1e3146f00880bb22486d5bc73e54367d54251f4002bcf342d0393b05a4b9ce0",
    "23b6fb8e945d3205f633ba724202db5a99305f807137edf942cd60eef867699"
  ],
  [
    "2e1da8013285598b899f026c6974185db12c97b4c63509769d3d4ad1d18a4e5",
    "1e7e7b668674d1593c39d58bc7bccbf568208732b3519bc2cdf93db34366862"
  ],
  [
    "d26c3f389d81709506f184b53871497c8d36c5c9eee8e3737358204c1acba3",
    "34649c3d39f3b825947fedbca215ae30c5a5995e93b1c8efca4944cf85a082a"
  ],
  [
    "91300478a83595d548f32f259033291fc7d083953b0b8bde88c7559660c563",
    "e5d2bff57fc6551e9b80c06ac7314a71907cdcc66ce82f2cce721a670df10a"
  ],
  [
    "1f7abcb9d462c63ffe92aa56619ae8590089cca4d93ee3e5f34a63882452cc7",
    "7e9f85c7b7ca6e9a4f3a026d1048adbeef69ea9d876c6f647c257b879a81bdd"
  ],
  [
    "4d2caa1323012e4c83b0ad387308b8aef5637bc35ddd882e7f5e41cf2ca410f",
    "47150e808c81a540b6f8864e9d6636589cacaa516f82caaa96506edfbd6f0e"
  ],
  [
    "3c10a6083c38351deb3e6d1b386827d0acf48979b66b95249eb8700ec26b069",
    "47e34bfe561d903cffdd1d849b85aa3cbd31cb4a9bbd8cc2e5fd2f95016cabc"
  ],
  [
    "758bd54868eec045d0b4d3d2bc415d24bce13fee47cefdfda46425c109b657",
    "3392a7c66ea3bd7b044680bbe9f78ae86752097404c067e9d2572f55330df83"
  ],
  [
    "19e718e0ca1d2d6fadbc6006ee7dda7a385430e29f5e239cdd4bb7c3fdcb2f8",
    "5c68249b7fe03ea2e13481a63b6cd4bf74ce42009a89fee0b3f8f968b3ec709"
  ],
  [
    "28077f57ea62401806367e6d54fe45d02de5b072db787ffdcc3854e12a3e855",
    "14f3762689072f5fb41d03e94b01808c739f6d42b7b785b0e464100b150efd2"
  ],
  [
    "3b8a8cefd017363ce867265af3293cec081fa589fe561830f0078778cbd338f",
    "69ccf2383cb7b4f9c806d72535812483e7c5e9a1a5928529d64ca7e085e758d"
  ],
  [
    "77878f388d22161a2953e5aca6bac1ea480e102f329574b4b201640d44a296b",
    "7eb35706a90a03aff7c2fecca72659136547cee98038746db5aba16fd7178df"
  ],
  [
    "97332e6da70961f2ef31b7b628f1018d21db8db015922a301fca7d6fc6a8e6",
    "2e37b06f639fc7a82601b744570a2619e543cbfaf60e474107fcaf4686d3223"
  ],
  [
    "a81518d452d3aac48bf0386c3ff170ef4e684a4def242c964e129c64f4d647",
    "37506e44c85908ec7b7adda9547fbdcc2e3605151fefa77fbf127ce3bc938f2"
  ],
  [
    "e80336b2220b1d666074f6b0dac85353d0e4c2e8bd0f37055a2236a6a9fadc",
    "1cae76d73eda7a5964c5d9d3ad6748aff51f5543c56441d2fdb7b444a39846a"
  ],
  [
    "2c01fd8430ecb44e066f352c4f697fc9fda177dbe162f82862d7b9ea8c918de",
    "6e1dfa99640fdf5b30603d34c7c97c1aa6e6b7f3a2c52a21fc64b0fcac7d591"
  ],
  [
    "744e37b511cd0ddcfe15f3581947014c159de81ed055d15a13c7a2d1fa39f0f",
    "685caa8ff6979a6c63640ac638a3f9c75737f2031bd55322a47384357af164d"
  ],
  [
    "40e627ff84e1a7a9068b4368770f5956128a4d9e9e33e9cf5e24d9a242149fd",
    "2465bd6cb20bbdf810e2bc5c3c458cecf4f3aa163a7ac99c2579e5f33417f2e"
  ],
  [
    "5f635af7f554a17bceb6ccb6e637abf89ab6dadd399189b0a0390e87b1896bc",
    "2aa6238a69f89665646c0e3ca2ba5f709cc6e14351cf71e1b00ec45201417a2"
  ],
  [
    "5edad3063c9fa8305978d7e6a4e037c9fa519b8023c7608dfc3b66e5c1e8985",
    "49f405d07d7d01919da51159ecdad1031a5ac208c026fdfc14d38f633d92183"
  ],
  [
    "2fdf2e8a45858c12926a1f25a62255fb2d02d0149a15ef669f859806683e649",
    "61cfb686bb31e2524470d4ad2ae09e3cc91b16305a21d748098feb1d8ce3b3d"
  ],
  [
    "ecdbd7c37f1dffa3943977278da3bb429afdf948b4ea6cdebace3d3be82381",
    "190b67fb34f7f3ad6afd3d6b6427aa327547d8ac0fb4deeb0feeba1f63d6c60"
  ],
  [
    "233021b483f578dfa5222f8cccba5766ceee0ac65f6d4a3b1673b302a21fb3c",
    "7d4b6d44d175d4b593f06f5a6dcba2cdbc4eaa2097abaf613123546866cf4ef"
  ],
  [
    "42db4e953c2a7a743de9fe20c5798f2247f51db4eabc6f40e86c13909a310ce",
    "12c1a0764a0b9f3666e431923ce15e7fcd0ded5ab153f0b48d362cca1604e65"
  ],
  [
    "30d539e2b545fb957e40e2255f6463b52d227c9808472cee6a3d521aa283a44",
    "5f9eccf747fe6313570f99e845db32b40070acee9ce9e34da7f3c29ca53a07a"
  ],
  [
    "4bd64e5ade3e2733580a6116b4af328751198e7128f9acfe3a3496b545efb5a",
    "4d584768900dabfc0dbaa086632b8051bb3905ef79b84d96c01514441d0cc93"
  ],
  [
    "62d6e771f02e591557197d13c3e77dfa2d1794ac1808407bd8227c4be31b466",
    "5c6f5607c1808e899ba36a425911fa8566b7ea9cc80de8a80538c0fceb837c0"
  ],
  [
    "5ce406218cb2852b1d2fe1836b19462f664631785216e87ffbce26030e2101f",
    "5225f107743c255ab50e7be4a090fe39478d1ef4ff558468559d8cfa87bb94"
  ],
  [
    "670286486e8dda3dc66b0ed3149be7697d3e06c8279844079daa7e42d5af728",
    "26becabe7430380c56e320f5ae3329569cae7b0af06fd5327ee23979d200eb0"
  ],
  [
    "3ef448df33a4394c43e93e5850cd0c5a6dcb18ae1cd865d00fe8ede9336a9f5",
    "56711f6ab7e0e4f7365ac34e284ac2879f40208c46f6febcc1dcf7146ecf015"
  ],
  [
    "4b63fc130288e92f2d6ba238caa7a6364804e29829ac037c57df32fbf762bc3",
    "1eb8c80af55278b4113286c038fff2bfad2da62763bb03426506b869139da0e"
  ],
  [
    "4e7e998557b29a95f805a6e2e26efc1e970108272d4755738c04f28572295c0",
    "97cfcc2f447bde61bde71049d8200a74a3028b21703bc139143d81a3623f09"
  ],
  [
    "574b67898f02964c408f68e9470e7b615be037e40b824e6617f89cb56c21219",
    "49392d5f8e6740a1b0b7444f56d7a17363f8656c6e4c628678c86223f2e46c8"
  ],
  [
    "7e8cb50ea5d5c1b09e219e7305bcb601d99b6d7185b1c388aa8e36fe1e56554",
    "47fefa308645455c12ccb5817da338f0c4f423b341aff4a9d158891a4fd69ba"
  ],
  [
    "67266dea9e71b4ed2bf24a597a823dd048cf31e725db511edceac72998c9ef6",
    "39babd65850befde1f7c28e41dbdbb4caf82bbcf3bcb5b33161f1c2960b2d8"
  ],
  [
    "63e99c2cb9c74eb9227d48065e27abb8f606df8fc83b2c44e4ea38b046bad2b",
    "60494a53dd13ecf34e08079d343c88fb655d6d810785af81f08d5aa9bcdcf9"
  ],
  [
    "3cf0600b0f5a2a4eb78c487cd385350e8c7848e3f6983231881d7f1bbe28543",
    "56dee4288528de609976ef6b903b652127c37b0590e91a2fdbebc3f11df2628"
  ],
  [
    "758f09245fa4b8b23d290ee2b3bfcede199b4fdb11f3cf2502a8ceedd61b129",
    "622d9baadfde781e985d9722e0a04715666769a4cc7a9bea0b96d6386be1746"
  ],
  [
    "38e1a45b81492aa95d7abea2b08b8c14dc0b8a41108b036871fb737910ae18c",
    "145c611262656385e5ed6243568cd3f9f59dbfed7a01ba11e22bb8bb272e08e"
  ],
  [
    "206e54ca53a2f155bd4fc45bf2edb77798ae6623defd4cf22f2dd4a7d119dad",
    "6c94e7f0825ad81680e4cdbcaaaf4df806d57a0d1fb2331926c3fe2b79d22e8"
  ],
  [
    "56e98d2862893caebf66180e84badf19ffc8b53041eaaa313ae7286a8fac3d",
    "526306f9c01afd6e0c1198ea5de17630f5a39c4ecd02d8e6f0d613c355995c6"
  ],
  [
    "4fa56f376c83db33f9dab2656558f3399099ec1de5e3018b7a6932dba8aa378",
    "3fa0984c931c9e38113e0c0e47e4401562761f92a7a23b45168f4e80ff5b54d"
  ],
  [
    "450cfaadfecdb8a2fbd4b95c44cb1db723ee5ac9677c9c188b3d7c8eff4ca58",
    "1a552bdfc0c81be734f1f6ca9a6dd3ab4daa61c11fb53ebb7046eee25d617c7"
  ],
  [
    "6fe20e5c8a8004e33eafc84d16ef770f2f0b7bace19adaaa150f987d295a34d",
    "28a35040a2ebe9a14a162d3208d5eabc6e2f3a8310f926bd80be65aa71775e2"
  ],
  [
    "1bd65f45a35bf62ae8f9ffcbd7de2976b90518b6820c219f039c50043bb1edf",
    "fb5f0f8659f9b6ed7cb0ddd7999506d0c20b26bbe69d1915a31842cfac41eb"
  ],
  [
    "4ba4cc166be8dec764910f75b45f74b40c690c74709e90f3aa372f0bd2d6997",
    "40301cf5c1751f4b971e46c4ede85fcac5c59a5ce5ae7c48151f27b24b219c"
  ],
  [
    "21cfbc678f5a279ebb6ed124273c8df37eaf12a2d04180403ae6b5ec0b1e1ef",
    "4478ed6a346d899ad7b0b10350270aad39ddd5b68529297e4c91a54357f0a7f"
  ],
  [
    "350bfefbe3d864eaadac9cc1195c14159bb736be743aed7380d2384cadd2046",
    "5e2a4b3ad0e1d7b9b8ef72b10d68a80e5ee691d7db591fcfbaad6240d41da8b"
  ],
  [
    "529acd569127f73c8d34345f87e96cebfb48ee12a00a3861cda209337ed94e6",
    "3120671a89b705e5bfd99b0e7fd2118b4914a3ac309b3d74527cacb5ad7491"
  ],
  [
    "55d3d7956a97d10e65a4d8ffeba40deaf0db0b57f8e022cdb3df6df613f5c6d",
    "159e59a6f92f48fcf85aa96c1a03749a4c4e2cf9e2bc94dd36796daebd9b8b9"
  ],
  [
    "405f019ee8f2e972a005c549b0884b5051f63d1e78480b73208dc07d8c65a1f",
    "4301a3d0c285ad309ff24a12c100ead7f48ba1368143712f32ac141ab4d9e8d"
  ],
  [
    "376d59b298d982f02dccad0edd5bbd4e5e8fad7898750675ed0856850a7babe",
    "5233b12bbc50564eb61cc098a17d3d97f06ec7a230380e4c5d3b725cc318eba"
  ],
  [
    "2f55624af6109ef04b2ed035a44a904ace8627f55889f011f768aabf4de9a38",
    "7f64209ce7dfb63337ccf3d8c14f4093295f86996cabfee23b1655549aca089"
  ],
  [
    "3b8965e942bed2714bc2e685fb103496e1e3595ac6a343d6df45fb5ef6979ed",
    "5b7cac7a165cb69ae103dd9052fb39c00ed0aad47989005aee53972d82d45b5"
  ],
  [
    "7abfe3accdec1eae1a50049efdd9a8eb7c2921a08e8bf1fe606e9d5a4039ec4",
    "3af178e7e831f8148244d2d2b284a32991852db6212ad0a9d77540ef648a5fe"
  ],
  [
    "4983196df6ad7d6f0a8d76f86af3863ad8611374a03fc0fd00793181dbde9d",
    "204c1f91b70f975a21d24a8face664e496f00f602daaafa69a3b56098a4cf89"
  ],
  [
    "79e2b91c1531a3b16dbd53e72d94e16bf265cbec261658151acfaea3718ea72",
    "3d9bdb47e8b148c1c5e9e694ffbc2cf71aac74ae1a85e8d8c3f77e580f962eb"
  ],
  [
    "297efceec61b3be17565843cae465c52524b4ecd9331a4170f54f7de8c4556c",
    "6ccef1733624cc8b973ac63dd54e7a53604929affe81c3439525ae5ed6af993"
  ],
  [
    "44f04b1966264a23ccdc870c8563ad2efcd4c8087b5469b90e792287a5581c7",
    "1c417f0e9829fa3d3cbb7c3cf4dc7aac04c5bf66ff3f86b833a42c533aed1fc"
  ],
  [
    "6ff83f5d8b51db3be0bda80eed2e2adb7037f2f58f705e88f0f98197431ac26",
    "64f59b8428894c2b7afd740866065ded42e716c7d48accd3f117f22768ed9fd"
  ],
  [
    "14aa8187c9559f77cd1cf96b2dfc949182529936f2b0b4050ea56e134073b24",
    "5f36508c68b1dc586f3fd3f4e2bd29c6d8258491b8a6aa19ede811ce0d3d0a1"
  ],
  [
    "95e8882a68c5000d1c2be7c0b43e7f2a6f8de906485241f0285a5c73a27a83",
    "1e4cb67207ab73bc1e5d19fa2146fde6d03021393b77a55df4ddda1fd28f5b1"
  ],
  [
    "2ae0704dacb3da47d564514b4c3543505b403ba09a248c6e74593cba1867ff5",
    "5a4b5818088dc9ef4066b90a8893ae80fc89584f987ec1928ef9d72cea2bd67"
  ],
  [
    "61a10898a76fb99989e51c0e823cb60b95ec7ccccb917c42b2b28014f5fd94d",
    "23d8ec1de45366d3b86c64c2da05a2ce3d171adf52ca5522e652ffd0eeee795"
  ],
  [
    "79884133c879cf07734976fd64de220c5a972e04c2a3afb74c362d6c3beecbf",
    "2aaa0e6d4891b792b5643fdf09873343cd0e3fbba3cbd0601b481a4083f32b6"
  ],
  [
    "45f73d2fa82be6c5ccd0f62d2237efe8727c479967d27cce28e42b9a44bad5b",
    "2fa4932215f72d56d8be5205c5851c9b3e5f2a14468e4a7acace5437c6b27dd"
  ],
  [
    "37f53f771850f52f9c8f87b53c6bf0c93c2bed76f5fd1d5697356d0b2325007",
    "50f1a052b79b446fbc7b93ffa1a4515f6c3be3a76a2b0bc5eb8ff327549960c"
  ],
  [
    "71bd6d23e0d2f312d47582efa609101f15b9ccc571fca8ac4fe3457c67fbc9b",
    "3b3fdf86bd4c7fc26d60540a6439b4d179dcbf7b91efb0ddc60dfbff9a148c6"
  ],
  [
    "78219ba049438385b829c13a4993874a4a326c4143de0dd581c7b9956f99b06",
    "5505f1268dcdd4ee01b77abac3bfdcbf3f0513ab097c69ff777b4a631aaf256"
  ],
  [
    "b81e924a86536dcf68bc5a2ca2065a61103ba6c9eb0ae4cf8cce9dbe286f15",
    "653a6dfb51acfe8a844fb8362795e5549d424aed88d3a090366a44f840b5b83"
  ],
  [
    "441c0d7b7aa705046dc0e07ba5f33a7d9df23f694a05192ff8c2d7be2aa3fdc",
    "4c06568c0902bb99d428bfa0a946ed0f0ca0a51fbf07cad88e06e9c78e38a59"
  ],
  [
    "2569c8c78b6d6b92533f29f767c95720d377fa63ad5a3b9827ee0a74b0488aa",
    "4b59c81d3cfe08834f946d9d57614f5366e0bcd9349475aaaebe01341196fe0"
  ],
  [
    "3f2fa285a0471647b214eac652bbad9d58a9f2dd2e812aff0210d0d8a6eb32f",
    "4cdb18e1c2848c2b52c1a6557165bd1a8f55c2f7562f5cc0b326f73c25b696c"
  ],
  [
    "5bb5141ab4fcc5290ae9151b8045a2cd8391547ce7b3b33cbbb10f8fb538092",
    "5a36bfd52acc6a83a9913b937ec086cc27fed030b5fa70dbc5d3c12c9515f56"
  ],
  [
    "3f3fed272edf91aa7f8ca5d70005d390fbc67830ffc69c5fa3ae17582d2771",
    "459057e0883c44d8776fa217405f443e5954f08c4a5db68e437becaa664a999"
  ],
  [
    "5237ca6656237a717a739a4509f70db1b9dedbb6cd232f60c9bd8c4563a6b1f",
    "56c7799dd02896dbe7d69dd8bb9718270549592099569d107b7b49c34bf5a49"
  ],
  [
    "1cf6b8499ac881e0b2fc7def9bc1a28937033b2fc52de99e75909a620c7a281",
    "5769cf4f735366fa386b6858043dc99a100f86fbc77b16d57d77766197ba27a"
  ],
  [
    "1b74b8a6b86dbf9638cdb0601e1a332b8d880753423d38c3394902c57f15e40",
    "6bb2dc10d2ecbb913219d0ebdc8d3337d644ed8b6c4e70637ef4c7e50887488"
  ],
  [
    "61e4da415661bba52a4737e2bcde1a837787c4796b2e1854778534f1582c29b",
    "27c43e632cb7652e8508c9c38e3b4ad0d3dd6ba748d42dc84ec2685e64b9aad"
  ],
  [
    "7c460a204d23f20ce86596dae6ac9b36734e4a9f7c5b43262c97a36c6a41c6e",
    "481a11f9300ab4c4bf6924c5ca884728cc361247377065920966785d043fbbf"
  ],
  [
    "124ff5e55e4effa40daa5b9618d75c49c8b6fad95cbe8c0bfdd83cb9bed8316",
    "33a2ea15d0f71f58a00de71acd7f22ccf9002115e49dd1f7631faa0d32f9987"
  ],
  [
    "61c9f8fc86715e95ff43583a865c5a6515f93381839d557ef884a68637eaf4c",
    "5877daaa42bbab9083b571e12648a9d62ced4470d71653092b6546f4a5acceb"
  ],
  [
    "70a6b9a9e5d1fcc07dd9ebef6d8f5fcf04c6cb34932d0fe2335330ac6dc8d3d",
    "3f0cbd332ac56922e886656bee74f6e9bb4bb88f7af7bba9098678af1f38fc"
  ],
  [
    "41db8a0f1ea78443a39e08a54323743c8897eed1ddc28f41aec6f2655040d9f",
    "7d4bf32f8f4719c2e4af8b7889f3b65cfdd033dc2f971798a12170f2b26efce"
  ],
  [
    "62f035e01acdfe841104942d6c8c07f0fbd618cb85998ea24bcc24cfac1f8",
    "1caa886104b7d753fda93645a746989794cd825c62473b526ea34b3d51b5771"
  ],
  [
    "441c6f016d270e86c19843727b83b864cec060cafc813b23d7e41e5abb1a60a",
    "29fece4e40400f3acae0586f4fc8ed535e805e472123ec38d662d8a0b01c086"
  ],
  [
    "2c791ba0fb0b66177815c98191fa6188dba9c795e34a7c3c8a19086215e3cee",
    "11123151389d4b330db6a665a560407e7cd8c3807c749e2b0cffd9c3074ba77"
  ],
  [
    "5292da4ca71ae75ed0554c267747e39c7a129b3b863e1af3ebb3e368439c4ea",
    "63af6a5016deea8cc674c44f16c63c1db31f09af4fb4d2ea7917c28116661fc"
  ],
  [
    "3367388d5d1b7758dc3d92e244f227bb8a54e3d9909e7b7dd62ab5965e3efc7",
    "7ffb4833071e4b03ea755ccb9938487a478248fe9b1158a08f1ac298801c092"
  ],
  [
    "95c863314b7f18090f8eee602403be823a367a1b416d54c32e5f914e67d922",
    "159c2824f899171deee23e0ed520d4825bd667983df0a8d45d3a1f7156d91f9"
  ],
  [
    "621c6e08b3c57404644ad49ac7629832c141273fa1f323781b3395393fe985c",
    "65d1eb0140652958c4371ebec791e03317d6b2e689d90e304666f1b610783dd"
  ],
  [
    "54313129bf13993952cd2b31ed06013aba85e74c1b8a00e062031f32188a84e",
    "680129efc9eb8ec07fc180e8f6877e5f0f9f44e3000a2c586ed4ce49d12a313"
  ],
  [
    "21ea57a1c8286bb45872e78617853c47b89091670ba51c124afa3362e7260d",
    "7087e5c1536df233ec9bfe2f983e8d7622892b9bf64c450c9823898e2cc2fc8"
  ],
  [
    "3793b05b99e7a57d88db4ed0dbc3b771285abcd9052da50f88595354409f3f3",
    "12164105041c056f127e737c7cd63981e05f246bd2b6b65d1f427019c7c3801"
  ],
  [
    "befd345cef5fcae22ac37dacd6b9128cc58cbba3e3fd774e11b421c2ba392",
    "6209d25f24f88f7876ca604db23d05f78e6b3b67fb033f2f1bee221f352b8c8"
  ],
  [
    "15fa536045fda4c65ff74f10b4e669ce88b9996c6772288289d3ad725987fa6",
    "30e0c2124a35e265e931ccc66ce5ac3697d982814beb407144ff6762cb691df"
  ],
  [
    "38b795bd77ac573576dc204857a488cac2cce19809882631ca2069598c577c8",
    "786ba555d55ebef688b068bb9186a34a08cb00bdfef51619bbf911890ae9a13"
  ],
  [
    "6c66853592196c3eb8d9526dc155205e2c64097adf8684bb0e15eb460ce1c72",
    "1bb4ebf654f4250c8dd1061a4e1b464b31a8a9999ac9960446ef8108a66871a"
  ],
  [
    "5b08dfbc87ad9c00b88e78816973ad2f9c10c70f2156908892cc7b7a2a1fd30",
    "1151f407a77e2556073173d8f5c9ff561d8a23742121ca15f7d0ac391af50ea"
  ],
  [
    "309190eba106aa6ead54b5ca5817969aa68b4b4c627700799a49fc6bdd32ba1",
    "505b6a2bc7b0d78ca6ce2abe7dfb7312369918a4599cccf8a615f6701cfd851"
  ],
  [
    "89cc205966af08acc8910d563af7443d5dfbb5d88dae79c013c678c65dcecc",
    "1f8cf955694b246a423ac725791231257b88936e00347ecaa1e17045c0ab540"
  ],
  [
    "480086b61a80c36cf1e1a350baf554e58ee8d9333186b70c9c512fb9e9d5a84",
    "511edfe58f8d36a6170df743731da1ff525cfd5108be20e30ac4183d1281570"
  ],
  [
    "3caf14fb1d2e90a13ad4eb091250fe37133aabf6029633e905e5a93ead41dbb",
    "49122aff6059dfda19e4b973aba5ebe3804c91728936c6381c1ed1ea9380920"
  ],
  [
    "66d1b8fb2cabc46cd79741ce1cb7326077ad8ea3227a6427244bdd3806bdadd",
    "4a52eb74f4d5371ba3265dffd61c844f9e68d4ff0b44dc4936182f9280bb66b"
  ],
  [
    "373330c5afd53c31257fcc9050fef873e15ea9f81d9810f30744309b04e02b3",
    "5889806607b3dc97a9c5b0c8a2f16d1792099a22866b879ca480cb89a11ef5c"
  ],
  [
    "26840d0ec69a22c6818ff64b8b14633b531508c866e21d1dc9239778ae9e8c7",
    "157971f9a6e3a24d3b307be0e7c8cd352e2eb5cad33cf276270c0f309ee63fc"
  ],
  [
    "ebb84848f1c38c19a754d1b5d9460e39624dadbb30800987c9419c0f933b9f",
    "517b297cf32f4064e6d6c8e761ba8db89809604a701c7b3aa1a9c6beb370ea7"
  ],
  [
    "25780380bc0795ed0dca727c55240f1d63593e552d224adb40df2d3721c0f66",
    "10215fb5a893e0275e9f1f66b217dde35addee91ed0e8f7d79531a2ff57b8c8"
  ],
  [
    "243e1581cd1abfbf18c31c19a4c3d1cedfe69a40bb57b607c9af2717eefc742",
    "1296c27929f14535718c3a4ebe045f00afdc60afc74c7d398d8ce1b6609dc0f"
  ],
  [
    "48babb8649e054bc8e0b902c89e6940c265f48464520649502ef1064eb94562",
    "3235be7852b0526d1a16f6969ec0e5b0e09cedaadc65863dea4e47f4f398264"
  ],
  [
    "592db7c27e63489ef4bcef2eafce89f40067cd9a1ba48bc3dc76b5fc62ad9ca",
    "48b7711b570cd9ac65910e75e752f4b751fdbfb4091a28f59b8c046d3d9f8bc"
  ],
  [
    "31d133456222586ae42a9ec7ce8539ee04afbe0b2ed00a2564dab0798d9b55d",
    "a77c52fa1fd718db5c83e7fda6d7d4d9aafef9ad95cad621470f2b753729e5"
  ],
  [
    "4651668379883521e7983aafcb93811b4a72ef2975b3277773746708ef3e3fc",
    "512507f3f544d80ba5d47f73b571881e8d70d7b1d305b9704bdad036b7abc47"
  ],
  [
    "26069e359b2e847affaef604f772f36224608b7642245d0e643889ed231bddc",
    "75ae1ec379f074ebc91270077c74b4d34347ce183b676b4dbe100bfff143b9e"
  ],
  [
    "3196d01d1fa11dc3803b4813c4bbc6326869f61410f2bd14bc0f570d875aebe",
    "20313217cac79875bd2a503db1e86d1e5559911667a02524759344468d9561d"
  ],
  [
    "483256607f75f06fb126addc60cadddd602154cc4782bcc08351a48745d0b97",
    "2950a7e500ebbe9775f08be37cc2e62ccf9030de18948d1bab07a4a9173f75d"
  ],
  [
    "65f07b6050a2fc6eebe2c29ffa62f764060f7f9d3c82d2cb5e4e368aaa442c9",
    "562c9654b646cb84a213b41de203c871b3eae0a05c9c105a66a53c319c06373"
  ],
  [
    "284870f6181c43f3b01d94baa9c5b6ada0deb861145523ad9169580eb7bed35",
    "5e03e6c40c1cfa3cafb01fd0622349871832a9d35499d06408a83edc1b76d02"
  ],
  [
    "32229810a52137f0e6c3d37595c46f6132822d4b05f42674b48d7a7ac3ad85",
    "7babde959a0cf2c53ee59fc52c77c3adf899453f077f441965629f9aead30cd"
  ],
  [
    "1ea8b98a6b85e74e0a2fbc18b206e290f3ed94ce99ca665e8e2351dfade990a",
    "478e93c4724115fb1648c8d5347422adbc1a0bbf962b2312e14aec80e1be742"
  ],
  [
    "270cbaa08c79140c85b864475a0bf569cc03ac785e57f543dc444f37ce746cf",
    "3a9b8d894016680ae9d1bf3deb931d8987d4d8d8bfed45b81ccc595ec79046b"
  ],
  [
    "6943922708b8ae5b40dd7031ef2e487abc4ac39a3591368285e83d6c9c51f4d",
    "5f157c37d09634e8cbfbef90ea50af59815d011e419a691c67ca3402b5efc33"
  ],
  [
    "48ac6a80979fab4912cf0cb557d917a0bd68825d8658ec100496eaae6ff62e1",
    "2b6931350ab183402e39476340eb1177b7006f7a552915581e29a79bd7203a0"
  ],
  [
    "e3adf9517d92ef22d1e2a787740a292ba32d5ca69faa9e8675f63ed816dce5",
    "36bccf69bb12dadd610145a3399213248d193660d8dc90a2e206f23bf2c7997"
  ],
  [
    "5e6c8ae5afb2fa470f767581f3d578cf6a49547e4b78665edfd45776948bef8",
    "6cbfc11953dd7e195d2ce74e52a60df524767b44c4608bdd755be4bc85eb74c"
  ],
  [
    "15a576a1242d39300f0db3ad770983825988da0457718ecd596c63a0a0eb4a6",
    "69a42e5f6f5a63349b57683a4609bba90f556a1680fa1ec3b02ee7d3211f903"
  ],
  [
    "274cd14e4fbf2ed07402e8ad8075b320c5f76b7ea45ea36af523e95ed63ab50",
    "6ca640f9557c5f2d8b27f6ce95b108880ff4e4816b26b70b6506114389ce656"
  ],
  [
    "4d8284e132e2fe81c5f71be1e3c79ab51b229e2c56c323e207cda179999d123",
    "116cfc00e9fbee1cf16af6282123cdf20eed13021c2037ef4c86f94eb6e6cba"
  ],
  [
    "4056194fb5643e97991942ef5b63cadd89080bf57a01489c4398aca03f0980a",
    "2e2cddb434fa6f6da7859c3d518f0ced8795eea043a6c9613fb3e020103339f"
  ],
  [
    "5d119d5c5ce532afc0875e0ee9b026d878c8773d34237f90a0d0670da6f01b3",
    "4a79fc025ce076b6a4742fbcc8cad313d0a8220c58024a41a5a674c0947e64b"
  ],
  [
    "11800ce4061d99b9d53fd4138802335258f7798c5a935c9979f5a949ce1d483",
    "36745a4741a5c7290eaa8f2a3f9ec955ccb7ca323272e5d35d35c2a724ffac8"
  ],
  [
    "4302525bceb97fa642fd5560a4a39fba3d2c06f68e6aff3332ff1854439ebb3",
    "e31edfd081ce82f8177b2d7d96e69851d09e908c2517114ffb37ee12c0ac64"
  ],
  [
    "2f5fcbb96f0a66fd3bdfbcc78bda361cb812570f50e7c476533d56eee01c0e3",
    "527428a34855b5695c479d8fb7e831a299f7897f36682a74169cc60d160df2d"
  ],
  [
    "52167df045ad0dc999b98de3d035aced9da4434211149b8cf4bf20e774580cf",
    "19051d2a1ad3fab190c5dfaf45188b49b4e90cca22aae54f0a785562d3d3f41"
  ],
  [
    "541b5332491dbdb2b6f6bccceb7634970c046963891fae936dd950f4432b961",
    "78fa54da996a51e3a9c06091d58c2405a806649da2bb1f323807c4eec50eda2"
  ],
  [
    "5f11e973da659b7738f87ca5bd4f3bd02207dd3c8d978f0d3e83fe81030febd",
    "137aba7027069f62d25caed416e13537687bb1428e71e5f0a0c52d52f2e65bc"
  ],
  [
    "15ec941ee6c2110b819b5541be52981c09d83484c9dc735c43f39f5778718b4",
    "4561826142dc5b56acfcf605a78a4090472bb61235bcd605a765e05d0a7e549"
  ],
  [
    "68ba398736d659522f484406110b43c68158bf4992094acf797a38979c587a4",
    "7c1d9e1702e28afddf22fed7a7a79df4315c174d0c6c4f4c75bc77d9b56777f"
  ],
  [
    "67889cea31c81a429fbae643a4fce0ecd690a5c32b99397e39ed6d7a08702df",
    "7ea277c80b671146c9e455b98f42f45b941ac95ca2d15c8fa9ea82ee9b45e01"
  ],
  [
    "596f2c68390ac26505d3c2eca5c77d46f8f3acbed192a2649d8c525a58d2334",
    "49f3bd8c62c610d5c19c52d970bde24b270c4ff7ae900453b909e72483974a0"
  ],
  [
    "567779fb8b0afe592cea284629e3621ccfae3c4d7d3dc559c9fed750591a395",
    "6010bdc33f1cdb374facefff537e7910b72a1120502f312a7ce41df0d552ddd"
  ],
  [
    "cebed0233e810aa6a29a8b0829d28f1c92f303d14dd73d6b12da98117dfc7",
    "4bdd51e1192a00df23aa8d0673e4915877ca41ddb8c9eaf21d39dd167fde7b7"
  ],
  [
    "4c7085f066adeb6781596771972b188177e63f2e2b3788d03e033cdd5af1f06",
    "2929ee89f525862b0cedb3ab9b5166e1680cb77fb4668f10a6a3d76b5434566"
  ],
  [
    "760e341bd836899c226176f47685f69438270c150c6fe7744cd723cd1e72359",
    "1bf09f2f1aac1a10ce8bdf20d5d178db747f01a4aa0aa8a5e4bfeef562cd94e"
  ],
  [
    "6016b94c00b54920027ef64902c61478244b1936337d2ad41d9a8d43dd6a4b2",
    "3bf3dd9bce7f6d6f120de87fcbce6219340b59c2c1d75ee0d45105d33aab1cd"
  ],
  [
    "4929e44ff692eb944d1045bee96e750219cda3bda0500029f0df49a1db30b5b",
    "2e138dcbd092242699004b4ce98764ffe4e892841f56830af298581cd1e523f"
  ],
  [
    "5972d0e526311bacb70a04e88969b6c63c7399b578f0dc28bbd00d65ef01da7",
    "76b22bca9ac12d26530e7b0757e646beb3bbc5680d0f3f82fb8ee57ed4b5e39"
  ],
  [
    "2ca0a42a26e26934ca2d48db960b4719113d87c5e57fb437d557c5eb4e03ac7",
    "62778c02561d4ec5d83a132afd7763a8349207c6b5d01fba70b56ba660cba2e"
  ],
  [
    "5137ee53f076e21a2c23da09f63c0d275408c31e4634a6b6373be5cf13e6c00",
    "14fb446c077beb78e04de3282a63bfde12f9af85caaca4ddfab506cee31c0c1"
  ],
  [
    "7d944853d1627b63f560aeda33acf640d35a4ee4d23a744957a2dae9d5b7c6c",
    "bcb411a210710acbcb9ea12680d89e3e4e652228b6786d3886e95f4d9e6970"
  ],
  [
    "37d412c2ffb173a728477446b60b2b702d07a5243cb5fc8963e623a5ee75843",
    "672c79968908f92cd0cb0b4c65ba86e8f359b015623a89441e1bf859bba84cb"
  ],
  [
    "5b37f472aa80398bff12cc74c8ee784c4fc89757292580d3a498bff17e9f114",
    "7d79da1aab9cfef58a5f3d1c9ec466956a45f8d2af0c1da6dd4c93f720fae6e"
  ],
  [
    "25c09b3f1188c562571536202eb0f5fc4b9a7590417b8ea58b4343685d88a63",
    "3d5b817c73b37e9a1d24ca923351359b42ced2f3cafbcac8c2d6322dc767bb"
  ],
  [
    "32e60904e73f9756f71e0a918d302aeca17cad4acacc81bab15702ab5ff78f0",
    "bcf4c0204f8275072f98a65b09ac58b87cdc9c70c4edfe99fe18870a3a5459"
  ],
  [
    "49c35575996c1517d2daed90d2fe4a58e674d6b4aaa7288d0642c8bf59e562f",
    "57eeee00adea4ca80eeabab57852cbf03f1a57e21872cd44221e0550b9193b8"
  ],
  [
    "10e1776b4c2a867bf1b028c6edec224cc6616c747e272f49e69b67b02a893dd",
    "8d45d62ec8e627b56950f2f7622a0438647f9e9f28e723e4a37cebc039a1b0"
  ],
  [
    "79a93a75ecbe943acc964fd39ecfc971dc6555b2bc335e7b53f52f4eb16cd36",
    "146132a68ce2ca8b48363612226771ac547eb3cf52b6eb7981718faac08aa3c"
  ],
  [
    "6b22d32e0590e169504e7f19864fd646d0994e7ed3e578a5b88f6e095913439",
    "68c3b22d859fb85e5c8fa0a8aea932285945b230957e603394333e9ad5acd82"
  ],
  [
    "71ce5ec8286eb8c93b8481c6d19cf0a288ef4da4397e9c80f65023e516bc097",
    "54470babc742780cd8a05499026e738ccbf81d4170d1731734de68a8e5b402c"
  ],
  [
    "27beb13a43bc6a1f6ce046da438b0beac5899ff4d57962dcfb6476b563f74b",
    "14074e9e93ee45394dfbe833998b9d1691961f8ba3166224b36404448c61bb3"
  ],
  [
    "6b1de6c8f161aa6509a1dcacf2c0aa1bcf6ee9d9b40e032a9d72f77a6fa298c",
    "5e9312eb5b59d6cbadd7d3dcbc39f1b5bd9a8346fdcfdf1107bada6f9cc048"
  ],
  [
    "32670fc3fa43bf39974ba72ea51f0d045d92d084a81fe5282dfc8309aa900b9",
    "518fee521bf1af62356aac3b7e53fdbf57121e030c6e9572b3de69912ca4eb4"
  ],
  [
    "4b9ca363eabed9c66091a347375f7065cd28f49f914447de7cc1461f1375f1e",
    "3a1a3a2e5e7e72476befe2571ece708052d740d02cbe6fed58740968ae609c4"
  ],
  [
    "4cc6da42863a3deca62fa218b7a3b50e034eb4bafd393eccba3f4cbe192ef10",
    "20bfa683c884f203713953b26d2821287ecd305fa2cb70570474533fc07f918"
  ],
  [
    "87705353c44a5ccec8de65cf5433be6b3d9bd21eea49b60e6c907cf1a67a6a",
    "112804b13eee56e3b01aff75fa08fa8374c44fc461aed8a30ad54acd09c24eb"
  ],
  [
    "6cf6eeeb9d339c0a05f72fd5af73fc7588e6d957100ee8999109437bc126cae",
    "54fa257cea22032eac272fcd034dadf2e00d602ef9e519cf7072023c130aad1"
  ],
  [
    "19b32925048c5519d929650c833661b452ef7be7963fab0b6b328ab7dd7a28a",
    "1bd0c14a10bf9b88ea61011c0b2e64d07da151c6203800d5a5d12063838a510"
  ],
  [
    "12a5fc5559428bc3b4eff97b21b63668b866e0722807f1db1f19696bacd9b0d",
    "4c2eb07f0c24047a3d73b560144f3fd32c99d6dbd9fc7cd2fd2a72a6e4b24c7"
  ],
  [
    "13662b7a7d390aa76eb86a7c3bff6d9913eb28db6bd1a7c42de5cdad2e35ce2",
    "40626aded7f56f82cc431ae30527b096f57fbfbc04d3e12a5abae3edf301cf1"
  ],
  [
    "255825bd49b8a2cce114360bd9c8fe8c641af64c8e7710107213cfcb006f43d",
    "3619cce4482335232f9e76a1460be9d296f2d468d26e4f95a78c71524fe59cc"
  ],
  [
    "7f83009eeed4f12f54d341bbf06066480cfcdf51dda103ac54d4bcecf6b3b31",
    "4269519d28faafd7fd68bebfd8404d71ba05d62c4bb6d65d24aa6802fb84ab6"
  ],
  [
    "2f325650eb316646b4eec903fe44828fcb11054f1bd42ca3a77f7e734110b35",
    "44f976082271016f9048e22c507d97d628722bb431f8d5cc1890524e6c386bf"
  ],
  [
    "750b166bb6edc0ee80fae39c7c106879036738df2d79fb2294e1c21e9a24d6b",
    "54f8aa297a1afafe2a17a3254f45861167414327e918d17003c6aad01d0b24c"
  ],
  [
    "3aedb10db9cf3285cdeee375879396fac1fb50dd259e1716f8c01e66f67ca72",
    "7feb9400f621f58c21601f23b7ec7c94a9b6b193c1cd74a8a60846aedadd359"
  ],
  [
    "4ab7151702de76faa493e7a0b1ac20ee4d10c33b83fec9477547cb1236973eb",
    "63f1f122e3ef3acc46b0915ac69c3f5772879799cad889a817f55f5853d1235"
  ],
  [
    "1675ead0d20e5bc3a7a7331999a87ac4c916ae29669e54197bb02aa6364520f",
    "4d1122da90d49e491922d9b533a6a668e2f65a2737ebb391ebb29fb7c1f8a9d"
  ],
  [
    "2f7148111ef53c613157aeec12e16a20f13481da4390b6ce18a85d1d8547087",
    "2eeda779ab395597651d2a0b833ccf53b10280750139916ae2baf4ec57c633d"
  ],
  [
    "4439c7810e7b2ba772b701ec3acdca0b80c9df23047710b87f7dc3f13b337d3",
    "5029cfe704c602a8a4662af0a5860ec03fb88f046d0e3400f2ce7638014c621"
  ],
  [
    "2248eec40b5732a6a488b681f093643af7937071bc73118acae295a32b51b05",
    "1577e4aec30a97b648de4d0b19cf8891151b4eb11f8de9c6d7312f091552e19"
  ],
  [
    "4738424e558d4e0d87a3124ca02ea24f0adc6b7a9768b0d3945ed2a6104857c",
    "33576f92aca3f0c8ae689c3c274c2de6b918940d86a6852e02fc99e35d1614"
  ],
  [
    "7829edd8b866ebf7baaf604ed13d19a9797578f44bbc51b1cd67ca53803e96b",
    "5559040a6083f2af1f9133ccaf5bc2ce06e56ddfc7dd410e9635c0116b62722"
  ],
  [
    "7f927b881f2cdc05e1a69e40bb714af47b630d1425f08ab5d574ee698f33d51",
    "26a465288e96572de303203bd38f4a03031e8158da0591cb037c0a5111d1056"
  ],
  [
    "36a65598552f8753580d1655417d645a140966e10a1e1663015f9fdfae44881",
    "33d5bbfaebf59eae72b89b1aea12ab2ba3c9617f8c3baed1ec16bdf668381b5"
  ],
  [
    "403becfa545c826782026ff409cc16c9d4fe428f1b5b6e630c92439d2fa5fd",
    "47bd6f2bf5d74f710ecb479c79b01fb774fbdad590e683a415cdedf33f71dc5"
  ],
  [
    "3a747826d241b877d3d56b16e0b810cf088eda4fd6048da174c9991a942a5eb",
    "2c7ba19b0a3486a2cdb84d4a388d34beb077a0e467ba44590166f93f6a09d2e"
  ],
  [
    "3d60cd375842714b37bda89dd1f13a7e0f3ff133b522209617d031bce05a537",
    "f77f216451ab01ad5226844d2162a7f32744688bcb4325445539e2ce5cec4"
  ],
  [
    "235bf66f67c9100e7f0e22bb299cdfaa603644b240e0770aec7e7fd163e2a65",
    "37110b3fa83ece3990afca2bea8d5ebb3c7aace60a0147f8e6ab733e2f2b4d5"
  ],
  [
    "3b796d4eb69a55471fa86108f787b3604874e92b6887a7667a6c2bfbbd9a42b",
    "4912d6dc0419732ef82cb3278415851d4e2d7ca89e0f4d7128cc9de51b810fe"
  ],
  [
    "48d53516dd51e49faa7ab46c8c10db1befd10f23c6a9d9bc3640a2f0da44518",
    "73a2fb3d064adadf21aa1362c04affc660598f38a9e069b3afb74d0a99ae9ee"
  ],
  [
    "48c32cff161ed145da0d5b73084897647abb777adf65738559ceab6939cf3e0",
    "3d99308978e828f857c382df32b472bda81e8ec8e30c8844077ba6d6d2ba903"
  ],
  [
    "2947ff091a8ec9684affbc9a62e09e598841c4a6dc638088492aa47dea57097",
    "19a2cc97975e547f97a4d02e42f89e6ced6f5a953cfccdec347867d26926541"
  ],
  [
    "1960d85f30475615f82484eba0bdafb7ea7cac3809f0518a757d66f02b01676",
    "36c8f77baabf0cc8805d993bbe62041fcf4e3239cf9d53278a4fbd91e75eeb7"
  ],
  [
    "2765f28074d21d5a055340b6d40092d2bbef807e02009fabfa08ec0b9bdf38b",
    "7fb189e0553d5df52b6843661814824b3f3cbebbd54988f042fb256c6bf30b"
  ],
  [
    "348836cb2aaa00212f4b1a4e2d7fc5417f246bf2fe5c9a16ebabda449e2e08a",
    "3f7276fd7d69e0d55ce5ee1d2d830534a27227fe0b6d8a36c93f9a78b872969"
  ],
  [
    "7afb9d34b6a42ea8c6d870e4b8191c274201dc1f93a1a2219a2392b7e345a31",
    "42bbc20dc7115e0758b364a110227b16b64ec58fc535ce5ff1a9ad8b8a09fdd"
  ],
  [
    "2cae0c2afee1767fd4c66f52e1f176d217e92e89cc19eb36d5a6c1715f641a",
    "5335efe2d9bc3667d25ea88bf76438a4d6ab9ba5c512f9da7d0529b79b62d83"
  ],
  [
    "1cc5fde334707723c3a06f00c106db88664284a2df47bb6b144d9f960aea3e2",
    "dbbf610d100316938bcd8bcd078513512ecb50d4579690dbefaa419c05980d"
  ],
  [
    "54e90cb8f3a2998d2675c5780679e06c0556b1e618f8fdf07f9a4b2466fbf1e",
    "16248676b6f06ec5e34994bc3115f85c8147b54f34d8500928f2fdc051e2089"
  ],
  [
    "525c70a2ba0dbdd68d75640f47f13d0d415ea595f7030f533f4625c2a46523b",
    "58292c8675e5e1a438f49e0c05648d9a7aa997f2f1fd77d5de1944afe5d7eea"
  ],
  [
    "54726d78d099007393348787a03107ab492e59690a46c87fb02ec554f2353bd",
    "53b54b77184ba75a3391e0ebfa6d6974db028f3f8e34bbd5460759a5848dd76"
  ],
  [
    "4ac81a66903537769d3aac6c483ccc08535cb767b6b5e1ec8017a7393ab70ae",
    "2cb22b77a8a05d26f11a4dec80eff292633aa05553a889c5ab16b6ac6e2ab17"
  ],
  [
    "21d0175349e21114988a2930b9a607d43245783cb4a0c984ce27f4c4206708",
    "59f1f49342cc5496213d3329bf4ca7fb0044337449c579bf53147a1dac9e67c"
  ],
  [
    "167f821b381f4c8adcc39789475fb55ba639e5124fe75f26dd61be396dd5e66",
    "22002c87d4cafb47ac9d27286d5cf5ff7a6715d69814118269b0729be9e4b3a"
  ],
  [
    "31010666c6db83a9f9e4db4c48173afd405783ac53852a6e38a8ff925528843",
    "1f466dc9b5d9094107c741dbf380f9fd98d8549cd50f67169901516f8cce74c"
  ],
  [
    "1ad3875769a5053388a86edc85dd80fdffbbda6a456aea497ff81a0f1f6707b",
    "2de7cdec5e2bad56a71bd2f33a4ae4c874e1ad4210a6ac32b443cfa34e85b1b"
  ],
  [
    "c489650fb7f459ce09cd05a456fc5a46b849b38a671298ed645bcdaab168b0",
    "45610d092b8af1c43ceed474cd17f7bbee65120aa6fa4d37f949e7e41f25327"
  ],
  [
    "394256a5ef4d7af5459587a0bd2edb8acaf5ecfef2563c9a04daf34a4abe4c6",
    "1ebee390dae1403c0c53994e1d064fa64e20fcb45392e209b2b99486a559ffd"
  ],
  [
    "410a1511fead6151e9bedb089b9832d0fe01fab76d3f8459929f767525aeb27",
    "361f0a5ffe09fcc3ad4eff3f5e89508ac247af80267100b69de3c59df561cfa"
  ],
  [
    "38cd437c9f659e110a869605c182ee9fdc26de36baf559d9229e258267bb734",
    "624b1128ea7739bf1cbd0e423af92a4884323c868d2ba0ee9d362946edee2d1"
  ],
  [
    "78b126e50b7042d2a019f95cb87a3213c664ca1bafe345999b1e9e2dac1e608",
    "19e398196b22f4488cbe854c614ad8c353839abc5ab3a4f3f5c03c16ba8a198"
  ],
  [
    "6d3a5ce91132f385a91823c5c8046c4b638f5fe63357424410d901457cdb867",
    "7b80bae16d2d487e122495174f7a70992bc5dafbed72bf84127ead7c57302bb"
  ],
  [
    "32d053a904dc4d88fbe7d0b96e0cbeca22a00aa5c79c753d52b0b60abf31602",
    "3af6a02e5cae6d6490354ae51185149e3fdb6d0d9caab90e95ff58aa0c40377"
  ],
  [
    "49b1fbff5bdb0aa6938b066dde0ed772c0d81f9eff52e7fe038b0ccbd78adb5",
    "1c6e57834eb14d507eed8b36c81ddf92fa91c242467061927a742fafa82b43d"
  ],
  [
    "2f28b8994ca6f234d9293d26196b43b9d1d5306844348c4a638102c05de85f5",
    "759cfb172eab065d477248b3569f4ff5791055f01e95fe71b94b8e615d73c96"
  ],
  [
    "3c2ee954ff534f856f59188fa0f29ed8a022aee0cac52d634f6dc58cd514d70",
    "22bd162e74925f0a876bd8a206b8767dfdd7c898576a73a490f138d9a7f99c6"
  ],
  [
    "5763a7cab001e1aaeabf9ab5b9b2fffe6cc2b299ab04ec4933da74d960e1ab",
    "715ee4f8ee93ab5a1dba00f0a6abc4eec47d49b61254cc27fc36a031e32f0f8"
  ],
  [
    "19976ad8d7b7f47c785408243a227401996b36e47c7a78a7bc7d4256233ba9a",
    "896b713c5d7777b0703821a73c1d9a4c3755501042120534ff13990975e1f5"
  ],
  [
    "61674b992c29827186cab5ff454758dbbed8e89bc23d0bd33193afccc3a04bc",
    "38e1020744c13903809ea30a0662fdb5226ae760cdcf10800faabec452e00f8"
  ],
  [
    "2ea2d48bcb83c0c9cda4efe11f07165cfcbc9ccd26526e5fb12556316d4b1df",
    "1d2d68b74ad384c5c4a9c85453104216357bfcdf635680b40215f0f800974cb"
  ],
  [
    "7881212050264c40c336ed3a15dd2cd868ec9a558f5b728869eab66e8b8ed54",
    "21aaefcc8ad8a161b8971d6880321781dbd939570c540da4c330922b8c81e9b"
  ],
  [
    "b6be88ce0461d20f59c5199573cda0170b61decf6e8e69a6d32f1695adc4ed",
    "5536e4808370716f2bb3423a9a49a38ddbfe91faf3b7a35eb53d3519238b6cf"
  ],
  [
    "e5972af1655eb6dde2e8c77cc58044299922441b5ee41ceaf5cafedc765bcc",
    "550282f37a4783dd60801c237045992d6fbe82a5902e7d837ea25f6f98c7b3a"
  ],
  [
    "7efc1aad1f580d8f50274f1c114c40056be19a8c96fa8c4cb5bf85e1e7f3e4",
    "2689f1c3898b114d668be6413643ee9f879913d40c262541fd0316264c60a4f"
  ],
  [
    "7939db98037f59b0113e9d60051f75ac9c3cfd1a3eb535c73e2d945068c6c5c",
    "410914ca8bbf3c65cdf3e9772ca790c19131c50068d34b7346c10260a578a8e"
  ],
  [
    "225b77ad00a2b83d26690190b74867326eca4f55bfbc3a13be036225ca3b1b5",
    "411faafef89042ce6beb64309fdaff70fa53e9d32d79a21e7f82f80e79ff05e"
  ],
  [
    "1501e64c99c8b6658b0479f2c05c9142d246eaabfccf2fcec8dc4399539d8e1",
    "3bab1e3339e42c9ee66c65b0b20236fdd9362d3ce786ad3a9779ab578af50a8"
  ],
  [
    "59b907b941f24fb8ea2458153e55f07534b388e835af7b69f3c9f54392a335",
    "1d5438c4f2f68a417f3d56f916d899a6ffe910f5f2989ca31687f1b10f60db8"
  ],
  [
    "2887d08a26f484546f360e33abbf7a998b7170a5b30070938b84f072c676bf3",
    "62a78e8d00e5d3a59e2fc424ffa08961567ba1ef24c8531cd7bceee6074a535"
  ],
  [
    "6e3cc8076b3d45377929033af35aab0c6d19ae4fd47c0daf844079ca04c46eb",
    "7b90f338e4d848aa8f19d0b5c3bca916a2a9024acbf14bddb278bca2aa39e5f"
  ],
  [
    "34844dacdd3ec54a3af328bb9d67715ab33425e194ac9977ca02ef22e8f7a88",
    "3c1affc6372f32a1634748124f9e1a03c4f0c993971da0dc28888b0801279d"
  ],
  [
    "436b192e03a49796cf9bc5e93c88268b71c9c24f9c3a85322bba634ebea309d",
    "67a8091ef69d62abcb28ce5df4dc7d53f8dc2b9690344f75ecd03a6d9386044"
  ],
  [
    "592d25b68baff87a6d7fd41ff0dadbddc1bd1316683de3b2d677501c0eb14e4",
    "27ad1e1099683f54589010faeefb19e38569ace43653be8787a42b0591e7bc5"
  ],
  [
    "89a5111ae911512ba62e87b97f643c0219702f235c70f62c6678a129302009",
    "557fa3d98e9ce7b83b47545013a4498f3de43787fb66b1a54521222242f7c1b"
  ],
  [
    "1c9b5e53377e72da5066cb08566bbf9ec31ec1877f455d932cd9b1aa375d34e",
    "72f79555a8bc207863f32d482fca54692825449fd8963fcea3de3a8183a739a"
  ],
  [
    "574a6e05eb14591729515be239ea8c1fa9e12d4049d42876f76c8ff37bca03",
    "5f99b3af43ca68c1c73e8190d5f73c8de162ba643d7d5f0cd73cfa8135db6d3"
  ],
  [
    "513fc5c2e16505b2b25a2f284e167d5401194bcac0dc3ecf8b7c9acb560daa1",
    "687ee7a1a8954d08d3856e1a16ded808e419e789736d3f55f79f7693bad69f5"
  ],
  [
    "53d48bd1205274b1c2b0a0ceb3d21c5fcd7c8892a784931603240b288a598b9",
    "35387abd7ea59c9b956de44d36533cad1f6668c438d666651695ff3862159be"
  ],
  [
    "213eb1ea99e08825110dd61094eb6e8145119dc1c507636f068730b1e086d44",
    "744f6853f4f02f4f042468d0739e0c9f64df720b87ed77d1979547084ef7a89"
  ],
  [
    "735ef017d091ca23264ad0aa7bb9b2be3309b4539605e79ed4a652ccb2fbe3c",
    "7f0ccc7a5747c4e921fff97d431169f690763427e2cfd1ad74d7a0308d7faa9"
  ],
  [
    "3f36babc5a30070b610ed97db44997e6d9115c9c0579ad8f75d295a17130001",
    "79047908a2474e32d5c712a07bf5c4ad522590bb5d6cefda410d30528e12ca8"
  ],
  [
    "51c04907ae88a5926b242fb2862cb1f2c651a94e6caad5bff8601c079fded74",
    "10a585a269f460aed43f54c7de13cdf623fc8de5957526997278be939ef32ad"
  ],
  [
    "c1e1bd626a735aa2c065831317217ecce68e377eb1f67e54ce2e97bc2ef2dc",
    "53c5af23a9b482f420be6dfd37b6886154cfd130794098e1f51c1885ac2556a"
  ],
  [
    "5aff3b30775ae4758e604a4a6262803a545f5ef4e7855fa245ac6a6431a9ece",
    "39a4799e5519047f29333bee9c86c99bfa8056d4aa381c396c4a44331fe795f"
  ],
  [
    "3d753e9723701a8e9d99b91bb93dee2eda7ffa5072fb2cd5c5fd99aebcdb299",
    "15798bf5c17d6d5880fed1553af32dd8d8baf2888c715a886575448a24c7975"
  ],
  [
    "6593e5078466b07a4222d2e544da826d2c583c9cc5f2eaea148b129b00d4aa0",
    "11b352b08a0a61d3cd67d1dc08069dec3bde907b3da0f56de5011b956bf8744"
  ],
  [
    "7a6eb353c5be9ff03fe4a06c01fb71aad2b38144179a291ebcbb2c2417cca65",
    "3de3ecb12f2fa699b46a9d399abf77ca17bebc3e491bfb2542dd0fba991e2bb"
  ],
  [
    "2c7ead583d6c32162091034a9eddfa775b4e84b8bdbea939edb2a80dcf64f6",
    "461790ce40d9c276d962b2a1e9a74d66e9d7335962e234e8a2fc6963d31722d"
  ],
  [
    "34285af023d9b4c2c2b88e8704bf2c05a9b553b00b2e70ff05f8c2970cb134f",
    "33fe678e7671760a83836107428dbade68c3593fbe568f3f8f1b2c568099c44"
  ],
  [
    "6222f720a24466263db6a11842f117fc4bb78da6705f140e48869db3e087441",
    "6eff5b9bf3aeedc962bc5a24b66e7bdad2153450ed53a058bf2c8dbf2907693"
  ],
  [
    "17c6ec5ea206eb97cbf53851e37ce391080e0d2bf1e5395610f79ab0503f7ce",
    "3adb71ca3523d88ceb1e365f12dfb24895453c14daf0046b2626cddadfdf5f7"
  ],
  [
    "70859f9771a713e54974ce11cdaf44b0dcc3e9befa0c0834908d877eeaafd27",
    "d18f794bf0cc0623b711e7450030424e52326c45ba9b03341883ae4828a5f8"
  ],
  [
    "2a820cfd0fd4ab0871e7b303cd545a3086caf8fa818c087a4017197da74efbf",
    "5f992683ff37f6c041b84bfc01503d333ac9763505cc8f69473da01812969d1"
  ],
  [
    "5b0526de2c07fe7cd73e3884f642d57a0ac5e13c68590ed03a14e530616e8c1",
    "eec69d0cbd92c9fca31ec967dba848bec368e792d6678797946a5e34fe3487"
  ],
  [
    "6cf6b3efee707210cb3a72f1e885c3d0953aefb43e5e148c740aa1641725c61",
    "911cb630b898e2c1a9115f9e45bafe3b819edfb1eab6e15612d14289939984"
  ],
  [
    "74e913de55f1e46143cb2ecfc580f8d3d3908f200281322b84e21c989cda293",
    "761d2736c9ac7670ba905bc2629c6c0dbe988820a4454ff415ba68710f7df92"
  ],
  [
    "44084305e0c911a40b7cbefe5f13cffe9a99375d1a584c4a2200958050af7a9",
    "249c83877371564708ea525b64b1e7e12785460d83364446531c9adcacba5f0"
  ],
  [
    "2bf71ad4d1bee1a67fb300477029f54bdb0e09f78bf2ac2e8afc7465a7adbcc",
    "6244dd6cad282539049be57487bfd9900bb0d5da805d02b535096368fcb4cd5"
  ],
  [
    "3a62d8f763b62def36e4089458046a49c5ecb91b861549530773e0548ff2bb",
    "6a10a03ba61e6ac657270465c09aa9526cf1ebe96bdecdf0e7000476a47b9eb"
  ],
  [
    "284eed3a17c51e0677d4fe897f056abe9def8af07a4630e6ca5723e2aa6677",
    "516a06ac1d5626ed03d2eee9de6f60f0311eca703a99b0fb31b9c66b01c27c7"
  ],
  [
    "2a2c63b16cccd685f731d06fe93ce2cffb358d34d03dda9a7368185c1eb0c32",
    "7180baca0ba81284809f92eca1654cd76b925a9242e5d5e0f18d0a55d13c6ec"
  ],
  [
    "5f9466017ec09769611389ea5370ad68dda936d3f5816c9e928ff9574abf9a7",
    "6619b5b145bb5f4f29deb7a4cd68ef4da3995312fa6537f0d01684da4267ece"
  ],
  [
    "74f229babe01b4962b3307589c1a13019134b1db6822698388bebb55d21c30f",
    "156ae857ab3279f754facba0db36398dffec8c31e5e160473198f2f891b7531"
  ],
  [
    "334b9fe3a5fd99bc966ddd1309698fd32afd1f235062f2c275b6616a185de45",
    "221a60053583cc0607f6f2e6966b62fc9dac00538bb7eb1148e007a92116d2"
  ],
  [
    "7ad710ba002a67c731efbaba2149d16fec5d2f7aa3d126fd9886172e9f4ea30",
    "3a10f8e902a7a13aec94d66415347e1314f9bac83a7db176096b809b25ffb86"
  ],
  [
    "4306dd0a184a3283c3097ff8f7434cec80912e9dc04b7df21ba73fda9f8e6d8",
    "6d42bd3d1a8dbddafd09e872e2aa3891ae79ec939dc1b382196bc21c4ab749"
  ],
  [
    "1c3f2124e1135c32a426d1d14e471edd9e0f2c7bd703ee123cbbd608e8c4be7",
    "3cc607a3c3f1ab68dd5fa56c65996002721b8ad8ad4b0dd9e5b1467d316583"
  ],
  [
    "294af33272ffcee0b56a436de1b73759cbddebef4c07888b42c2f92b0b68e1",
    "d837164311d5dca8d37b99ef9eb22708643c83d1cbdfe852f63ea07b06fbad"
  ],
  [
    "753bdb5439a19bbffdfa02b1dc24e8368f22d0a8276b109c11e6feb26f56f39",
    "6ed396231af93647633eab467f1a034f38e76823eb85baf97cae56e2dcd9f75"
  ],
  [
    "5674f0cb892b733fc0b50e121d8679afed0a925c32594cc65ffe83bebe7748e",
    "7fbf0325dd38dd94905adab2c52758552292a6a103d9edfcb11938828e828c8"
  ],
  [
    "4a8f053573a0a74251059d0229d89b6660407ba0b491779fd10f87a5117c81f",
    "21b70112485398bf67ec9d733df24a1df30dea718a93b786f41ed04e3ae3c5e"
  ],
  [
    "726c01ec4a08df8fc8de173311f50d4f3b97c5a9cf68c1536146f827db95ae8",
    "15013cafadefa7f1c4e4dfdd70bd4d3979dd18bd7f0332572ce2a3fd8773d12"
  ],
  [
    "38ac0fbfa98937257460db7e6645d7e5112b6fce7234813fc8a704e8ade8da2",
    "73c0109f86048aad08c443f781ae60ad13b99f7b9cfdf3128fe6d6eeb799a7b"
  ],
  [
    "6f6d3a38621582ace092eb50ecfe9eff265df141ebdcab8653299116fcea291",
    "4a1bf3f39bc919c8f1b720a0b1ce952cad17f2ba98308ee6b76dd9b6f3d7b75"
  ],
  [
    "6a307fc28e1df8d9ad01766419e097797d65cb674436fa1c8f012d3de2c2a1f",
    "26911a635ba824db004875d79dd84834a97ac12643e42829015bf88c1fd6f05"
  ],
  [
    "2a74860e3336d6db916555894cc8028f41508812925db1925457afe40257155",
    "5f8da573f4c39816ce2dba8a20224223a7cfec53117ec78973930c0e9b60244"
  ],
  [
    "4d2b49e1ed0799f719b8269f092cb489a466a645bc0ccabafdc678864c176d7",
    "5410083df7d256f18cbf5697ae5e52c31e075d8a3b27e21d6f5177ca882f6c1"
  ],
  [
    "110ecb9fbf6c333d168cee473cc5ad98809b6cb9eb5d1f6cd28ab5fab504fd3",
    "7e3c54d7533d9f8c3310f219dab0cc3ea4d39b418a748eeffd6bae2b8637a43"
  ],
  [
    "5be4d711b80da70e6d3ac493250bbfd16f20b25f31919b3a91cf14ffbac1096",
    "7f55a0919f082e8885f1515e83c5b39b6022404503507498e1b4422d79c43e2"
  ],
  [
    "2605125b95ca4ba93a21cbbba5762898a7cf9e988f07ab9e64cb3868e3b139d",
    "62f0ccf55b9fc0eaf9736fc8ee484e2acdbe259813af9803cf815829a5e9d3b"
  ],
  [
    "1092bbbf206f2a3068167c3dd99a72de31e206f6c504c071c8214d105ff814d",
    "309f489f68a62089f53b96df5d4fbc3ecc5a1a42eb7ece0e49bad17ad490ff4"
  ],
  [
    "2abdee9409d9c92559ca3f4e6bddd649c31aa09b90bfcb4a612af491241e18d",
    "3ffa8eac180a29de3f8a69efca84bac046f921f5725e96a6ff0530be1436aaf"
  ],
  [
    "376313f27d00bb1aae7ec991745efe6ee28c6b50de0c6cd9845cc4bb4f83543",
    "6a8e0a9389ba528b156fa94ac090a895d7b795818d4941c29415d9e2984c547"
  ],
  [
    "a80380c71bd466a696b3f0fbf02817c9459d9798f4f3899cf32edf647fe066",
    "6a09805e814e7cdfc76eba4b79f1df5ae559e0f0aba9f728d3cba4ea5c57471"
  ],
  [
    "223694b921d247d989a79b9b2b2f07496036c40cb043eab074a9d6a2cd2ffed",
    "c247217f1b1df35e30d9e15fdaadf42d6fb0edd3a5a7e265d4cdc426c120aa"
  ],
  [
    "102333620df278c6714bbc880fc087db58c1b9b4d77ed4d61b32a74bfc7c3e2",
    "6a77d37727ccf71c2caeb151faf4404d4b94e9047f9f0a7c3966367f3b53c65"
  ],
  [
    "891626f466536929ee7eadcd18b41925706dedab7528ed5f0f7abf039eb9d2",
    "5f73d11c141c933a35b2d0d06e5cbae614a20d17dc3b439f8bcdc3413c5ea37"
  ],
  [
    "215c23fd3f073f870e5e80303967391bf173f8adcdbeec72d131c557babc203",
    "10634332e9d9439a321597dc5b0fac9ff478834c3d6e281735f21a4a5e13266"
  ],
  [
    "21ea0bdc1332bc36e6aeb43be9071651c27e4ea2eadec636c8d818d4af72a36",
    "3a523d9643dccc6bb9c7c58413312caa3e60ba9c7c7f0177e0f3f469a3241e3"
  ],
  [
    "60deaed1bffb6190beed40caaf2bfab5e43d3707aff7ad3f278d571aa247eae",
    "e41f71ff254c1418e6a66992af307789fe04d6606fb2670900bb1a089fd879"
  ],
  [
    "1e1fac4a1646253fb1332fadc21fbdd3e3a24a840d129400f520ae4116a4cf5",
    "69c406f9f46576afad68808de0ab7e8922b6226af748e721d9097e21f1800f3"
  ],
  [
    "5db0ddcdf79ffe74d6454c12d2bc60b06776db03c75dc413f5be42ea9a91b5e",
    "134c3d6c699841f17306835bb193785228ffe7ab212a01a861c56b086a18cec"
  ],
  [
    "626814e320fb5bea505b248fd1c1389ad586c1cfe04923fe2f83173e915f4f8",
    "7ae407a926e887206a8b85cf485f1f327c9bb8ccbb6897024e2d122877d8ee0"
  ],
  [
    "23186237dc7d3b570cea645282ad4c359731bbfa54e7f036426bf6493812cd",
    "7d1fbab7e61a22d3b00993290d9f4cd5d820061573e787f66c2cff9a18e1eaf"
  ],
  [
    "54302dcb0e6cc1c6e44cca8f61a63bb2ca65048d53fb325d36ff12c49a58202",
    "1b77b3e37d13504b348046268d8ae25ce98ad783c25561a879dcc77e99c2426"
  ],
  [
    "13961b56b9fc0e412e468c385c22bd0680a25624ec211ffbb6bc877b2a6926c",
    "62f7f7792c77cd981fad13cb6863fe099c4d971c1374109185eae99943f16e9"
  ],
  [
    "47abd7308c70659af3f00fafe6837298af3cb530b6c2ba710ffd07a6bc1ae98",
    "75d0c8a7377aa9f0663d0c124a5659750847afabc29e39893fd27534a4a03cb"
  ],
  [
    "2c6276b764fb398fa555857dbe0ce0ec18fab7a233bf23851295739801f0585",
    "5d8f4897ce44007ec5bfcb9aeb78b8f6e1d40a514f72d213c9300d2770d2b8c"
  ]
], N4 = {};
Ae(N4, {
  EntryPointType: () => Wl,
  RPC: () => vt,
  TransactionStatus: () => Kl,
  TransactionType: () => Gl
});
var Wl = /* @__PURE__ */ ((e) => (e.EXTERNAL = "EXTERNAL", e.L1_HANDLER = "L1_HANDLER", e.CONSTRUCTOR = "CONSTRUCTOR", e))(Wl || {}), Kl = /* @__PURE__ */ ((e) => (e.NOT_RECEIVED = "NOT_RECEIVED", e.RECEIVED = "RECEIVED", e.PENDING = "PENDING", e.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2", e.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1", e.REJECTED = "REJECTED", e))(Kl || {}), Gl = /* @__PURE__ */ ((e) => (e.INVOKE = "INVOKE_FUNCTION", e.DECLARE = "DECLARE", e.DEPLOY = "DEPLOY", e.DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT", e))(Gl || {}), vt;
((e) => {
  ((t) => {
    t.DECLARE = "DECLARE", t.DEPLOY = "DEPLOY", t.DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT", t.INVOKE = "INVOKE", t.L1_HANDLER = "L1_HANDLER";
  })(e.TransactionType || (e.TransactionType = {}));
})(vt || (vt = {}));
function ye(e, t) {
  if (!e)
    throw new Error(t || "Assertion failure");
}
var R4 = {};
Ae(R4, {
  assertInRange: () => P4,
  bigNumberishArrayToDecimalStringArray: () => qs,
  bigNumberishArrayToHexadecimalStringArray: () => Xl,
  cleanHex: () => es,
  getDecimalString: () => Jl,
  getHexString: () => Ks,
  getHexStringArray: () => Ql,
  hexToBytes: () => eu,
  hexToDecimalString: () => Yl,
  isBigInt: () => Mc,
  isHex: () => bt,
  isStringWholeNumber: () => hn,
  toBigInt: () => Z,
  toCairoBool: () => ts,
  toHex: () => P,
  toHexString: () => Ws
});
function bt(e) {
  return /^0x[0-9a-f]*$/i.test(e);
}
function Z(e) {
  return BigInt(e);
}
function Mc(e) {
  return typeof e == "bigint";
}
function P(e) {
  return Be(Z(e).toString(16));
}
function Yl(e) {
  return BigInt(Be(e)).toString(10);
}
var es = (e) => e.toLowerCase().replace(/^(0x)0+/, "$1");
function P4(e, t, a, n = "") {
  const r = n === "" ? "invalid length" : `invalid ${n} length`, c = BigInt(e), i = BigInt(t), s = BigInt(a);
  ye(
    c >= i && c <= s,
    `Message not signable, ${r}.`
  );
}
function qs(e) {
  return e.map((t) => Z(t).toString(10));
}
function Xl(e) {
  return e.map((t) => P(t));
}
var hn = (e) => /^\d+$/.test(e), Ws = (e) => P(e);
function Jl(e) {
  if (bt(e))
    return Yl(e);
  if (hn(e))
    return e;
  throw new Error(`${e} need to be hex-string or whole-number-string`);
}
function Ks(e) {
  if (bt(e))
    return e;
  if (hn(e))
    return Ws(e);
  throw new Error(`${e} need to be hex-string or whole-number-string`);
}
function Ql(e) {
  return e.map((t) => Ks(t));
}
var ts = (e) => (+e).toString();
function eu(e) {
  if (!bt(e))
    throw new Error(`${e} need to be a hex-string`);
  let t = bn(e);
  return t.length % 2 !== 0 && (t = `0${t}`), Vt(t);
}
function L4(e) {
  const t = bn(P(BigInt(e))), a = t.length % 2 === 0 ? t : `0${t}`;
  return Be(yr(eu(Be(a))).toString(16));
}
function $4(e) {
  return Be(yr(Uc(e)).toString(16));
}
function tu(e) {
  return BigInt($4(e)) & Ml;
}
function ht(e) {
  return P(tu(e));
}
function au(e) {
  return bt(e) ? e : hn(e) ? Ws(e) : ht(e);
}
var D4 = {};
Ae(D4, {
  decodeShortString: () => Js,
  encodeShortString: () => ea,
  isASCII: () => Gs,
  isDecimalString: () => ru,
  isLongText: () => Ys,
  isShortString: () => Cr,
  isShortText: () => B4,
  isText: () => Ar,
  splitLongString: () => Xs
});
var nu = 31;
function Gs(e) {
  return /^[\x00-\x7F]*$/.test(e);
}
function Cr(e) {
  return e.length <= nu;
}
function ru(e) {
  return /^[0-9]*$/i.test(e);
}
function Ar(e) {
  return typeof e == "string" && !bt(e) && !hn(e);
}
var B4 = (e) => Ar(e) && Cr(e), Ys = (e) => Ar(e) && !Cr(e);
function Xs(e) {
  const t = RegExp(`[^]{1,${nu}}`, "g");
  return e.match(t) || [];
}
function ea(e) {
  if (!Gs(e))
    throw new Error(`${e} is not an ASCII string`);
  if (!Cr(e))
    throw new Error(`${e} is too long`);
  return Be(e.replace(/./g, (t) => t.charCodeAt(0).toString(16)));
}
function Js(e) {
  if (!Gs(e))
    throw new Error(`${e} is not an ASCII string`);
  if (bt(e))
    return bn(e).replace(/.{2}/g, (t) => String.fromCharCode(parseInt(t, 16)));
  if (ru(e))
    return Js("0X".concat(BigInt(e).toString(16)));
  throw new Error(`${e} is not Hex or decimal`);
}
var Z4 = {};
Ae(Z4, {
  Uint: () => ao,
  felt: () => Ue,
  getArrayType: () => Or,
  isCairo1Type: () => tn,
  isLen: () => _a,
  isTypeArray: () => xt,
  isTypeBool: () => Hc,
  isTypeContractAddress: () => su,
  isTypeFelt: () => sc,
  isTypeNamedTuple: () => iu,
  isTypeStruct: () => en,
  isTypeTuple: () => st,
  isTypeUint: () => no,
  isTypeUint256: () => ya,
  tuple: () => M4,
  uint256: () => ro
});
var j4 = {};
Ae(j4, {
  UINT_128_MAX: () => eo,
  UINT_256_MAX: () => cu,
  bnToUint256: () => U4,
  isUint256: () => to,
  uint256ToBN: () => Qs
});
function Qs(e) {
  return (Z(e.high) << 128n) + Z(e.low);
}
var eo = (1n << 128n) - 1n, cu = (1n << 256n) - 1n;
function to(e) {
  return Z(e) <= cu;
}
function U4(e) {
  const t = Z(e);
  if (!to(t))
    throw new Error("Number is too large");
  return {
    low: Be((t & eo).toString(16)),
    high: Be((t >> 128n).toString(16))
  };
}
var ao = /* @__PURE__ */ ((e) => (e.u8 = "core::integer::u8", e.u16 = "core::integer::u16", e.u32 = "core::integer::u32", e.u64 = "core::integer::u64", e.u128 = "core::integer::u128", e.u256 = "core::integer::u256", e))(ao || {}), _a = (e) => /_len$/.test(e), sc = (e) => e === "felt" || e === "core::felt252", xt = (e) => /\*/.test(e) || e.startsWith("core::array::Array::"), st = (e) => /^\(.*\)$/i.test(e), iu = (e) => /\(.*\)/i.test(e) && e.includes(":"), en = (e, t) => e in t, no = (e) => Object.values(ao).includes(e), ya = (e) => e === "core::integer::u256", Hc = (e) => e === "core::bool", su = (e) => e === "core::starknet::contract_address::ContractAddress", tn = (e) => e.includes("core::"), Or = (e) => tn(e) ? e.substring(e.indexOf("<") + 1, e.lastIndexOf(">")) : e.replace("*", ""), ro = (e) => {
  const t = BigInt(e);
  if (!to(t))
    throw new Error("Number is too large");
  return {
    // eslint-disable-next-line no-bitwise
    low: (t & eo).toString(10),
    // eslint-disable-next-line no-bitwise
    high: (t >> 128n).toString(10)
  };
}, M4 = (...e) => ({ ...e });
function Ue(e) {
  if (Mc(e) || typeof e == "number" && Number.isInteger(e))
    return e.toString();
  if (Ar(e)) {
    if (!Cr(e))
      throw new Error(
        `${e} is a long string > 31 chars, felt can store short strings, split it to array of short strings`
      );
    const t = ea(e);
    return BigInt(t).toString();
  }
  if (typeof e == "string" && bt(e))
    return BigInt(e).toString();
  if (typeof e == "string" && hn(e))
    return e;
  if (typeof e == "boolean")
    return `${+e}`;
  throw new Error(`${e} can't be computed by felt()`);
}
var xi = {
  isBN: (e, t, a) => {
    if (!Mc(e[a]))
      throw new Error(
        `Data and formatter mismatch on ${a}:${t[a]}, expected response data ${a}:${e[a]} to be BN instead it is ${typeof e[a]}`
      );
  },
  unknown: (e, t, a) => {
    throw new Error(`Unhandled formatter type on ${a}:${t[a]} for data ${a}:${e[a]}`);
  }
};
function Kr(e, t, a) {
  return Object.entries(e).reduce((n, [r, c]) => {
    const i = a ?? t[r];
    if (!(r in t) && !a)
      return n[r] = c, n;
    if (i === "string") {
      if (Array.isArray(e[r])) {
        const s = Kr(
          e[r],
          e[r].map((o) => i)
        );
        return n[r] = Object.values(s).join(""), n;
      }
      return xi.isBN(e, t, r), n[r] = Js(c), n;
    }
    if (i === "number")
      return xi.isBN(e, t, r), n[r] = Number(c), n;
    if (typeof i == "function")
      return n[r] = i(c), n;
    if (Array.isArray(i)) {
      const s = Kr(e[r], i, i[0]);
      return n[r] = Object.values(s), n;
    }
    return typeof i == "object" ? (n[r] = Kr(e[r], i), n) : (xi.unknown(e, t, r), n);
  }, {});
}
function H4(e) {
  const t = e.substring(0, e.indexOf(":")), a = e.substring(t.length + 1);
  return { name: t, type: a };
}
function ou(e) {
  if (!e.includes("("))
    return { subTuple: [], result: e };
  const t = [];
  let a = "", n = 0;
  for (; n < e.length; ) {
    if (e[n] === "(") {
      let r = 1;
      const c = n;
      for (n++; r; )
        e[n] === ")" && r--, e[n] === "(" && r++, n++;
      t.push(e.substring(c, n)), a += " ", n--;
    } else
      a += e[n];
    n++;
  }
  return {
    subTuple: t,
    result: a
  };
}
function z4(e) {
  const t = e.replace(/\s/g, "").slice(1, -1), { subTuple: a, result: n } = ou(t);
  let r = n.split(",").map((c) => a.length ? c.replace(" ", a.shift()) : c);
  return iu(e) && (r = r.reduce((c, i) => c.concat(H4(i)), [])), r;
}
function F4(e) {
  const t = e.replace(/\s/g, "").slice(1, -1), { subTuple: a, result: n } = ou(t);
  return n.split(",").map((c) => a.length ? c.replace(" ", a.shift()) : c);
}
function co(e) {
  return tn(e) ? F4(e) : z4(e);
}
function Ei(e) {
  return Error(
    `Your object includes the property : ${e}, containing an Uint256 object without the 'low' and 'high' keys.`
  );
}
function V4(e, t, a) {
  const n = (i, s) => s.reduce((d, f) => {
    const l = (b) => Object.defineProperty(d, f.name, {
      enumerable: !0,
      value: b ?? i[f.name]
    });
    if (i[f.name] === "undefined" && (tn(f.type) || !_a(f.name)))
      throw Error(`Your object needs a property with key : ${f.name} .`);
    switch (!0) {
      case en(f.type, a):
        l(
          n(
            i[f.name],
            a[f.type].members
          )
        );
        break;
      case ya(f.type): {
        const b = i[f.name];
        if (typeof b != "object") {
          l();
          break;
        }
        if (!("low" in b && "high" in b))
          throw Ei(f.name);
        l({ low: b.low, high: b.high });
        break;
      }
      case st(f.type):
        l(c(i[f.name], f));
        break;
      case xt(f.type):
        l(r(i[f.name], f));
        break;
      case (!tn(f.type) && _a(f.name)):
        break;
      default:
        l();
    }
    return d;
  }, {});
  function r(i, s) {
    const o = Or(s.type);
    if (typeof i == "string")
      return i;
    switch (!0) {
      case o in a:
        return i.map((d) => n(d, a[o].members));
      case o === "core::integer::u256":
        return i.map((d) => {
          if (typeof d != "object")
            return d;
          if (!("low" in d && "high" in d))
            throw Ei(s.name);
          return { low: d.low, high: d.high };
        });
      case st(o):
        return i.map((d) => c(d, { name: "0", type: o }));
      case xt(o):
        return i.map((d) => r(d, { name: "0", type: o }));
      default:
        return i;
    }
  }
  function c(i, s) {
    return co(s.type).reduce((f, l, b) => {
      const u = Object.keys(i), h = (m) => Object.defineProperty(f, b.toString(), {
        enumerable: !0,
        value: m ?? i[u[b]]
      }), p = l?.type ? l.type : l;
      switch (!0) {
        case en(p, a):
          h(
            n(
              i[u[b]],
              a[p].members
            )
          );
          break;
        case ya(p): {
          const m = i[u[b]];
          if (typeof m != "object") {
            h();
            break;
          }
          if (!("low" in m && "high" in m))
            throw Ei(s.name);
          h({ low: m.low, high: m.high });
          break;
        }
        case st(p):
          h(
            c(i[u[b]], {
              name: "0",
              type: p
            })
          );
          break;
        case xt(p):
          h(
            r(i[u[b]], {
              name: "0",
              type: p
            })
          );
          break;
        default:
          h();
      }
      return f;
    }, {});
  }
  return n(e, t);
}
function du(e, t) {
  switch (!0) {
    case ya(e):
      const a = ro(t);
      return [Ue(a.low), Ue(a.high)];
    default:
      return Ue(t);
  }
}
function q4(e, t) {
  const a = co(t), n = Object.values(e);
  if (n.length !== a.length)
    throw Error(
      `ParseTuple: provided and expected abi tuple size do not match.
      provided: ${n} 
      expected: ${a}`
    );
  return a.map((r, c) => ({
    element: n[c],
    type: r.type ?? r
  }));
}
function Nn(e, t, a) {
  if (e === void 0)
    throw Error(`Missing parameter for type ${t}`);
  if (Array.isArray(e)) {
    const n = [];
    n.push(Ue(e.length));
    const r = Or(t);
    return e.reduce((c, i) => c.concat(Nn(i, r, a)), n);
  }
  if (a[t] && a[t].members.length) {
    const { members: n } = a[t], r = e;
    return n.reduce((c, i) => c.concat(Nn(r[i.name], i.type, a)), []);
  }
  if (st(t))
    return q4(e, t).reduce((r, c) => {
      const i = Nn(c.element, c.type, a);
      return r.concat(i);
    }, []);
  if (ya(t)) {
    if (typeof e == "object") {
      const { low: r, high: c } = e;
      return [Ue(r), Ue(c)];
    }
    const n = ro(e);
    return [Ue(n.low), Ue(n.high)];
  }
  if (typeof e == "object")
    throw Error(`Parameter ${e} do not align with abi parameter ${t}`);
  return du(t, e);
}
function W4(e, t, a) {
  const { name: n, type: r } = t;
  let { value: c } = e.next();
  switch (!0) {
    case xt(r):
      if (!Array.isArray(c) && !Ar(c))
        throw Error(`ABI expected parameter ${n} to be array or long string, got ${c}`);
      return typeof c == "string" && (c = Xs(c)), Nn(c, t.type, a);
    case (en(r, a) || st(r) || ya(r)):
      return Nn(c, r, a);
    default:
      return du(r, c);
  }
}
function fu(e, t) {
  let a;
  switch (!0) {
    case Hc(e):
      return a = t.next().value, !!BigInt(a);
    case ya(e):
      const n = t.next().value, r = t.next().value;
      return Qs({ low: n, high: r });
    default:
      return a = t.next().value, BigInt(a);
  }
}
function Fa(e, t, a) {
  if (t.type in a && a[t.type])
    return a[t.type].members.reduce((n, r) => (n[r.name] = Fa(e, r, a), n), {});
  if (st(t.type))
    return co(t.type).reduce((r, c, i) => {
      const s = c?.name ? c.name : i, o = c?.type ? c.type : c, d = { name: s, type: o };
      return r[s] = Fa(e, d, a), r;
    }, {});
  if (xt(t.type)) {
    const n = [], r = { name: "", type: Or(t.type) }, c = BigInt(e.next().value);
    for (; n.length < c; )
      n.push(Fa(e, r, a));
    return n;
  }
  return fu(t.type, e);
}
function K4(e, t, a, n) {
  const { name: r, type: c } = t;
  let i;
  switch (!0) {
    case _a(r):
      return i = e.next().value, BigInt(i);
    case (c in a || st(c)):
      return Fa(e, t, a);
    case xt(c):
      if (tn(c))
        return Fa(e, t, a);
      const s = [];
      if (n && n[`${r}_len`]) {
        const o = n[`${r}_len`];
        for (; s.length < o; )
          s.push(
            Fa(
              e,
              { name: r, type: t.type.replace("*", "") },
              a
            )
          );
      }
      return s;
    default:
      return fu(c, e);
  }
}
var lu = (e, t) => {
  ye(
    typeof e == "string" || typeof e == "number" || typeof e == "bigint",
    `Validate: arg ${t.name} should be a felt typed as (String, Number or BigInt)`
  );
}, uu = (e, t) => {
  typeof e == "number" && ye(
    e <= Number.MAX_SAFE_INTEGER,
    "Validation: Parameter is to large to be typed as Number use (BigInt or String)"
  ), ye(
    typeof e == "string" || typeof e == "number" || typeof e == "bigint" || typeof e == "object" && "low" in e && "high" in e,
    `Validate: arg ${t.name} of cairo ZORG type ${t.type} should be type (String, Number or BigInt)`
  );
  const a = typeof e == "object" ? Qs(e) : Z(e);
  switch (t.type) {
    case "core::integer::u8":
      ye(
        a >= 0n && a <= 255n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0 - 255]`
      );
      break;
    case "core::integer::u16":
      ye(
        a >= 0n && a <= 65535n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 65535]`
      );
      break;
    case "core::integer::u32":
      ye(
        a >= 0n && a <= 4294967295n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 4294967295]`
      );
      break;
    case "core::integer::u64":
      ye(
        a >= 0n && a <= 2n ** 64n - 1n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^64-1]`
      );
      break;
    case "core::integer::u128":
      ye(
        a >= 0n && a <= 2n ** 128n - 1n,
        `Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^128-1]`
      );
      break;
    case "core::integer::u256":
      ye(
        a >= 0n && a <= 2n ** 256n - 1n,
        `Validate: arg ${t.name} is ${t.type} 0 - 2^256-1`
      );
      break;
  }
}, bu = (e, t) => {
  ye(
    typeof e == "boolean",
    `Validate: arg ${t.name} of cairo type ${t.type} should be type (Boolean)`
  );
}, hu = (e, t, a) => {
  ye(
    typeof e == "object" && !Array.isArray(e),
    `Validate: arg ${t.name} is cairo type struct (${t.type}), and should be defined as js object (not array)`
  ), a[t.type].members.forEach(({ name: n }) => {
    ye(
      Object.keys(e).includes(n),
      `Validate: arg ${t.name} should have a property ${n}`
    );
  });
}, pu = (e, t) => {
  ye(
    typeof e == "object" && !Array.isArray(e),
    `Validate: arg ${t.name} should be a tuple (defined as object)`
  );
}, mu = (e, t, a) => {
  const n = Or(t.type);
  if (!(sc(n) && Ys(e)))
    switch (ye(Array.isArray(e), `Validate: arg ${t.name} should be an Array`), !0) {
      case sc(n):
        e.forEach((r) => lu(r, t));
        break;
      case st(n):
        e.forEach((r) => pu(r, { name: t.name, type: n }));
        break;
      case en(n, a):
        e.forEach(
          (r) => hu(r, { name: t.name, type: n }, a)
        );
        break;
      case no(n):
        e.forEach((r) => uu(r, t));
        break;
      case Hc(n):
        e.forEach((r) => bu(r, t));
        break;
      case xt(n):
        e.forEach(
          (r) => mu(r, { name: "", type: n }, a)
        );
        break;
      default:
        throw new Error(
          `Validate Unhandled: argument ${t.name}, type ${t.type}, value ${e}`
        );
    }
};
function Ld(e, t, a) {
  e.inputs.reduce((n, r) => {
    const c = t[n];
    switch (!0) {
      case _a(r.name):
        return n;
      case sc(r.type):
        lu(c, r);
        break;
      case no(r.type):
        uu(c, r);
        break;
      case Hc(r.type):
        bu(c, r);
        break;
      case su(r.type):
        break;
      case en(r.type, a):
        hu(c, r, a);
        break;
      case st(r.type):
        pu(c, r);
        break;
      case xt(r.type):
        mu(c, r, a);
        break;
      default:
        throw new Error(
          `Validate Unhandled: argument ${r.name}, type ${r.type}, value ${c}`
        );
    }
    return n + 1;
  }, 0);
}
var re = class {
  constructor(e) {
    this.abi = e, this.structs = re.getAbiStruct(e);
  }
  /**
   * Validate arguments passed to the method as corresponding to the ones in the abi
   * @param type string - type of the method
   * @param method string - name of the method
   * @param args ArgsOrCalldata - arguments that are passed to the method
   */
  validate(e, t, a = []) {
    if (e !== "DEPLOY") {
      const c = this.abi.filter((i) => {
        if (i.type !== "function")
          return !1;
        const s = i.stateMutability === "view" || i.state_mutability === "view";
        return e === "INVOKE" ? !s : s;
      }).map((i) => i.name);
      ye(
        c.includes(t),
        `${e === "INVOKE" ? "invocable" : "viewable"} method not found in abi`
      );
    }
    const n = this.abi.find(
      (c) => e === "DEPLOY" ? c.name === t && c.type === t : c.name === t && c.type === "function"
    ), r = re.abiInputsLength(n.inputs);
    if (a.length !== r)
      throw Error(
        `Invalid number of arguments, expected ${r} arguments, but got ${a.length}`
      );
    Ld(n, a, this.structs);
  }
  /**
   * Compile contract callData with abi
   * Parse the calldata by using input fields from the abi for that method
   * @param method string - method name
   * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).
   * @return Calldata - parsed arguments in format that contract is expecting
   * @example
   * ```typescript
   * const calldata = myCallData.compile("constructor",["0x34a",[1,3n]]);
   * ```
   * ```typescript
   * const calldata2 = myCallData.compile("constructor",{list:[1,3n],balance:"0x34"}); // wrong order is valid
   * ```
   */
  compile(e, t) {
    const a = this.abi.find((c) => c.name === e);
    let n;
    if (Array.isArray(t))
      n = t;
    else {
      const c = V4(t, a.inputs, this.structs);
      n = Object.values(c), Ld(a, n, this.structs);
    }
    const r = n[Symbol.iterator]();
    return a.inputs.reduce(
      (c, i) => _a(i.name) ? c : c.concat(W4(r, i, this.structs)),
      []
    );
  }
  /**
   * Compile contract callData without abi
   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data
   * @returns Calldata
   */
  static compile(e) {
    const t = (n) => {
      const r = (c, i = "") => {
        const s = Array.isArray(c) ? [c.length.toString(), ...c] : c;
        return Object.entries(s).flatMap(([o, d]) => {
          let f = d;
          Ys(f) && (f = Xs(f)), o === "entrypoint" && (f = ht(f));
          const l = Array.isArray(s) && o === "0" ? "$$len" : o;
          return Mc(f) ? [[`${i}${l}`, Ue(f)]] : Object(f) === f ? r(f, `${i}${l}.`) : [[`${i}${l}`, Ue(f)]];
        });
      };
      return Object.fromEntries(r(n));
    };
    let a;
    if (Array.isArray(e)) {
      const n = { ...e }, r = t(n);
      a = Object.values(r);
    } else {
      const n = t(e);
      a = Object.values(n);
    }
    return Object.defineProperty(a, "__compiled__", {
      enumerable: !1,
      writable: !1,
      value: !0
    }), a;
  }
  /**
   * Parse elements of the response array and structuring them into response object
   * @param method string - method name
   * @param response string[] - response from the method
   * @return Result - parsed response corresponding to the abi
   */
  parse(e, t) {
    const { outputs: a } = this.abi.find((c) => c.name === e), n = t.flat()[Symbol.iterator](), r = a.flat().reduce((c, i, s) => {
      const o = i.name ?? s;
      return c[o] = K4(n, i, this.structs, c), c[o] && c[`${o}_len`] && delete c[`${o}_len`], c;
    }, {});
    return Object.keys(r).length === 1 && 0 in r ? r[0] : r;
  }
  /**
   * Format cairo method response data to native js values based on provided format schema
   * @param method string - cairo method name
   * @param response string[] - cairo method response
   * @param format object - formatter object schema
   * @returns Result - parsed and formatted response object
   */
  format(e, t, a) {
    const n = this.parse(e, t);
    return Kr(n, a);
  }
  /**
   * Helper to calculate inputs from abi
   * @param inputs AbiEntry
   * @returns number
   */
  static abiInputsLength(e) {
    return e.reduce((t, a) => _a(a.name) ? t : t + 1, 0);
  }
  /**
   * Helper to extract structs from abi
   * @param abi Abi
   * @returns AbiStructs - structs from abi
   */
  static getAbiStruct(e) {
    return e.filter((t) => t.type === "struct").reduce(
      (t, a) => ({
        ...t,
        [a.name]: a
      }),
      {}
    );
  }
  /**
   * Helper: Compile HexCalldata | RawCalldata | RawArgs
   * @param rawCalldata HexCalldata | RawCalldata | RawArgs
   * @returns Calldata
   */
  static toCalldata(e = []) {
    return re.compile(e);
  }
  /**
   * Helper: Convert raw to HexCalldata
   * @param raw HexCalldata | RawCalldata | RawArgs
   * @returns HexCalldata
   */
  static toHex(e = []) {
    return re.compile(e).map((a) => P(a));
  }
}, gu = typeof window < "u" && window.fetch || // use buildin fetch in browser if available
typeof global < "u" && global.fetch || // use buildin fetch in node, react-native and service worker if available
Gh, G4 = {};
Ae(G4, {
  calculateContractAddressFromHash: () => Gr,
  calculateDeclareTransactionHash: () => yu,
  calculateDeployAccountTransactionHash: () => wu,
  calculateDeployTransactionHash: () => e5,
  calculateTransactionHash: () => vu,
  calculateTransactionHashCommon: () => Ir,
  computeCompiledClassHash: () => ku,
  computeContractClassHash: () => Su,
  computeHashOnElements: () => ke,
  computeLegacyContractClassHash: () => Eu,
  computeSierraContractClassHash: () => Tu,
  default: () => xu,
  feeTransactionVersion: () => sa,
  formatSpaces: () => Wn,
  getSelector: () => au,
  getSelectorFromName: () => ht,
  keccakBn: () => L4,
  poseidon: () => J1,
  starknetKeccak: () => tu,
  transactionVersion: () => Rn,
  transactionVersion_2: () => as
});
var Y4 = {};
Ae(Y4, {
  starkCurve: () => Dh,
  weierstrass: () => ih
});
var X4 = {};
Ae(X4, {
  parse: () => wa,
  parseAlwaysAsBig: () => _u,
  stringify: () => Tt,
  stringifyAlwaysAsBig: () => Q4
});
var J4 = (e) => {
  if (!xr(e))
    return parseFloat(e);
  const t = parseInt(e, 10);
  return Number.isSafeInteger(t) ? t : BigInt(e);
}, wa = (e) => Gf(String(e), null, J4), _u = (e) => Gf(String(e), null, l2), Tt = (...e) => Yf(...e), Q4 = Tt, Rn = 1n, as = 2n, sa = 2n ** 128n + Rn;
function ke(e) {
  return [...e, e.length].reduce((t, a) => dn(Z(t), Z(a)), 0).toString();
}
function Ir(e, t, a, n, r, c, i, s = []) {
  const o = ke(r), d = [
    e,
    t,
    a,
    n,
    o,
    c,
    i,
    ...s
  ];
  return ke(d);
}
function e5(e, t, a, n) {
  return Ir(
    "0x6465706c6f79",
    a,
    e,
    ht("constructor"),
    t,
    0,
    n
  );
}
function yu(e, t, a, n, r, c, i) {
  return Ir(
    "0x6465636c617265",
    a,
    t,
    0,
    [e],
    n,
    r,
    [c, ...i ? [i] : []]
  );
}
function wu(e, t, a, n, r, c, i, s) {
  const o = [t, n, ...a];
  return Ir(
    "0x6465706c6f795f6163636f756e74",
    r,
    e,
    0,
    o,
    c,
    i,
    [s]
  );
}
function vu(e, t, a, n, r, c) {
  return Ir(
    "0x696e766f6b65",
    t,
    e,
    0,
    a,
    n,
    r,
    [c]
  );
}
function Gr(e, t, a, n) {
  const r = re.compile(a), c = ke(r), i = Ue("0x535441524b4e45545f434f4e54524143545f41444452455353");
  return ke([
    i,
    n,
    e,
    t,
    c
  ]);
}
function t5(e, t) {
  return e === "attributes" || e === "accessible_scopes" ? Array.isArray(t) && t.length === 0 ? void 0 : t : e === "debug_info" ? null : t === null ? void 0 : t;
}
function Wn(e) {
  let t = !1, a = "";
  for (const n of e)
    n === '"' && a.endsWith("\\") === !1 && (t = !t), t ? a += n : a += n === ":" ? ": " : n === "," ? ", " : n;
  return a;
}
function xu(e) {
  const { abi: t, program: a } = e, r = Wn(Tt({ abi: t, program: a }, t5));
  return Be(yr(Uc(r)).toString(16));
}
function Eu(e) {
  const t = typeof e == "string" ? wa(e) : e, a = P(Hl), n = ke(
    t.entry_points_by_type.EXTERNAL.flatMap((d) => [d.selector, d.offset])
  ), r = ke(
    t.entry_points_by_type.L1_HANDLER.flatMap((d) => [d.selector, d.offset])
  ), c = ke(
    t.entry_points_by_type.CONSTRUCTOR.flatMap((d) => [d.selector, d.offset])
  ), i = ke(
    t.program.builtins.map((d) => ea(d))
  ), s = xu(t), o = ke(t.program.data);
  return ke([
    a,
    n,
    r,
    c,
    i,
    s,
    o
  ]);
}
function a5(e) {
  return qt(
    e.flatMap((t) => BigInt(ea(t)))
  );
}
function ki(e) {
  const t = e.flatMap((a) => [BigInt(a.selector), BigInt(a.offset), a5(a.builtins)]);
  return qt(t);
}
function ku(e) {
  const a = BigInt(ea("COMPILED_CLASS_V1")), n = ki(e.entry_points_by_type.EXTERNAL), r = ki(e.entry_points_by_type.L1_HANDLER), c = ki(e.entry_points_by_type.CONSTRUCTOR), i = qt(e.bytecode.map((s) => BigInt(s)));
  return P(
    qt([
      a,
      n,
      r,
      c,
      i
    ])
  );
}
function Ti(e) {
  const t = e.flatMap((a) => [BigInt(a.selector), BigInt(a.function_idx)]);
  return qt(t);
}
function n5(e) {
  const t = Wn(Tt(e.abi, null));
  return BigInt(Be(yr(Uc(t)).toString(16)));
}
function Tu(e) {
  const a = BigInt(ea("CONTRACT_CLASS_V0.1.0")), n = Ti(e.entry_points_by_type.EXTERNAL), r = Ti(e.entry_points_by_type.L1_HANDLER), c = Ti(e.entry_points_by_type.CONSTRUCTOR), i = n5(e), s = qt(e.sierra_program.map((o) => BigInt(o)));
  return P(
    qt([
      a,
      n,
      r,
      c,
      i,
      s
    ])
  );
}
function Su(e) {
  const t = typeof e == "string" ? wa(e) : e;
  return "sierra_program" in t ? Tu(t) : Eu(t);
}
function jt(e) {
  return "sierra_program" in (typeof e == "string" ? wa(e) : e);
}
function Si(e) {
  const t = { ...e };
  if (jt(e.contract) && (!e.compiledClassHash && e.casm && (t.compiledClassHash = ku(e.casm)), !t.compiledClassHash))
    throw new Error(
      "Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash"
    );
  if (t.classHash = e.classHash ?? Su(e.contract), !t.classHash)
    throw new Error("Extract classHash failed, provide (CompiledContract).json file or classHash");
  return t;
}
var r5 = {};
Ae(r5, {
  compressProgram: () => io,
  estimatedFeeToMaxFee: () => Da,
  formatSignature: () => Nr,
  makeAddress: () => c5,
  randomAddress: () => so,
  signatureToDecimalArray: () => tt,
  signatureToHexArray: () => na
});
function io(e) {
  const t = typeof e == "string" ? e : Tt(e), a = m4(t);
  return Dl(a);
}
function so() {
  const e = As.randomPrivateKey();
  return Is(e);
}
function c5(e) {
  return Be(e).toLowerCase();
}
function Nr(e) {
  if (!e)
    throw Error("formatSignature: provided signature is undefined");
  if (Array.isArray(e))
    return e.map((t) => P(t));
  try {
    const { r: t, s: a } = e;
    return [P(t), P(a)];
  } catch {
    throw new Error("Signature need to be weierstrass.SignatureType or an array for custom");
  }
}
function tt(e) {
  return qs(Nr(e));
}
function na(e) {
  return Xl(Nr(e));
}
function Da(e, t = 0.5) {
  const a = Math.round((1 + t) * 100);
  return Z(e) * Z(a) / 100n;
}
function ns(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function i5(e) {
  const t = { ...e };
  return delete t.sierra_program_debug_info, t.abi = Wn(Tt(e.abi)), t.sierra_program = Wn(Tt(e.sierra_program)), t.sierra_program = io(t.sierra_program), t;
}
function rs(e) {
  const t = typeof e == "string" ? wa(e) : e;
  return jt(e) ? i5(t) : {
    ...t,
    // TODO: Why do we gzip program object?
    ..."program" in t && { program: io(t.program) }
  };
}
var s5 = class {
  parseGetBlockResponse(e) {
    return {
      timestamp: e.timestamp,
      block_hash: e.block_hash,
      block_number: e.block_number,
      new_root: e.new_root,
      parent_hash: e.parent_hash,
      status: e.status,
      transactions: e.transactions
    };
  }
  parseGetTransactionResponse(e) {
    return {
      calldata: e.calldata || [],
      contract_address: e.contract_address,
      sender_address: e.contract_address,
      max_fee: e.max_fee,
      nonce: e.nonce,
      signature: e.signature || [],
      transaction_hash: e.transaction_hash,
      version: e.version
    };
  }
  parseFeeEstimateResponse(e) {
    return {
      overall_fee: Z(e.overall_fee),
      gas_consumed: Z(e.gas_consumed),
      gas_price: Z(e.gas_price)
    };
  }
  parseCallContractResponse(e) {
    return {
      result: e
    };
  }
};
function o5(e, t = e.constructor) {
  const { captureStackTrace: a } = Error;
  a && a(e, t);
}
function d5(e, t) {
  const { setPrototypeOf: a } = Object;
  a ? a(e, t) : e.__proto__ = t;
}
var f5 = class extends Error {
  constructor(e) {
    super(e), Object.defineProperty(this, "name", {
      value: new.target.name,
      enumerable: !1,
      configurable: !0
    }), d5(this, new.target.prototype), o5(this);
  }
}, Kn = class extends f5 {
}, l5 = class extends Kn {
  constructor(e, t) {
    super(e), this.errorCode = t;
  }
}, u5 = class extends Kn {
  constructor(e, t) {
    super(e), this.errorCode = t;
  }
}, b5 = {};
Ae(b5, {
  StarknetIdContract: () => Ou,
  getStarknetIdContract: () => oo,
  useDecoded: () => Cu,
  useEncoded: () => Au
});
var nt = "abcdefghijklmnopqrstuvwxyz0123456789-", Ma = BigInt(nt.length + 1), be = "ËøôÊù•", $d = BigInt(nt.length), cs = BigInt(be.length), Dd = BigInt(be.length + 1);
function is(e) {
  let t = 0;
  for (; e.endsWith(be[be.length - 1]); )
    e = e.substring(0, e.length - 1), t += 1;
  return [e, t];
}
function Cu(e) {
  let t = "";
  return e.forEach((a) => {
    for (; a !== Ie; ) {
      const c = a % Ma;
      if (a /= Ma, c === BigInt(nt.length)) {
        const i = a / Dd;
        if (i === Ie) {
          const s = a % Dd;
          a = i, s === Ie ? t += nt[0] : t += be[Number(s) - 1];
        } else {
          const s = a % cs;
          t += be[Number(s)], a /= cs;
        }
      } else
        t += nt[Number(c)];
    }
    const [n, r] = is(t);
    r && (t = n + (r % 2 === 0 ? be[be.length - 1].repeat(r / 2 - 1) + be[0] + nt[1] : be[be.length - 1].repeat((r - 1) / 2 + 1))), t += ".";
  }), t && t.concat("stark");
}
function Au(e) {
  let t = BigInt(0), a = BigInt(1);
  if (e.endsWith(be[0] + nt[1])) {
    const [n, r] = is(e.substring(0, e.length - 2));
    e = n + be[be.length - 1].repeat(2 * (r + 1));
  } else {
    const [n, r] = is(e);
    r && (e = n + be[be.length - 1].repeat(1 + 2 * (r - 1)));
  }
  for (let n = 0; n < e.length; n += 1) {
    const r = e[n], c = nt.indexOf(r), i = BigInt(nt.indexOf(r));
    if (c !== -1)
      n === e.length - 1 && e[n] === nt[0] ? (t += a * $d, a *= Ma, a *= Ma) : (t += a * i, a *= Ma);
    else if (be.indexOf(r) !== -1) {
      t += a * $d, a *= Ma;
      const s = (n === e.length - 1 ? 1 : 0) + be.indexOf(r);
      t += a * BigInt(s), a *= cs;
    }
  }
  return t;
}
var Ou = /* @__PURE__ */ ((e) => (e.MAINNET = "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678", e.TESTNET = "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce", e))(Ou || {});
function oo(e) {
  switch (e) {
    case "0x534e5f4d41494e":
      return "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
    case "0x534e5f474f45524c49":
      return "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce";
    default:
      throw new Error("Starknet.id is not yet deployed on this network");
  }
}
async function fo(e, t, a) {
  const n = await e.getChainId(), r = a ?? oo(n);
  try {
    const i = (await e.callContract({
      contractAddress: r,
      entrypoint: "address_to_domain",
      calldata: re.compile({
        address: t
      })
    })).result.map((o) => BigInt(o)).slice(1), s = Cu(i);
    if (!s)
      throw Error("Starkname not found");
    return s;
  } catch (c) {
    throw c instanceof Error && c.message === "Starkname not found" ? c : Error("Could not get stark name");
  }
}
async function lo(e, t, a) {
  const n = await e.getChainId(), r = a ?? oo(n);
  try {
    return (await e.callContract({
      contractAddress: r,
      entrypoint: "domain_to_address",
      calldata: re.compile({
        domain: [Au(t.replace(".stark", "")).toString(10)]
      })
    })).result[0];
  } catch {
    throw Error("Could not get address from stark name");
  }
}
var h5 = ["latest", "pending"], me = class {
  constructor(e) {
    this.hash = null, this.number = null, this.tag = null, this.valueOf = () => this.number, this.toString = () => this.hash, this.setIdentifier(e);
  }
  setIdentifier(e) {
    typeof e == "string" && bt(e) ? this.hash = e : typeof e == "bigint" ? this.hash = P(e) : typeof e == "number" ? this.number = e : typeof e == "string" && h5.includes(e) ? this.tag = e : this.tag = "pending";
  }
  // TODO: fix any
  get queryIdentifier() {
    return this.number !== null ? `blockNumber=${this.number}` : this.hash !== null ? `blockHash=${this.hash}` : `blockNumber=${this.tag}`;
  }
  // TODO: fix any
  get identifier() {
    return this.number !== null ? { block_number: this.number } : this.hash !== null ? { block_hash: this.hash } : this.tag;
  }
  set identifier(e) {
    this.setIdentifier(e);
  }
  get sequencerIdentifier() {
    return this.hash !== null ? { blockHash: this.hash } : { blockNumber: this.number ?? this.tag };
  }
}, Ci = {
  headers: { "Content-Type": "application/json" },
  blockIdentifier: "latest",
  retries: 200
}, Bd = class {
  constructor(e) {
    this.responseParser = new s5();
    const { nodeUrl: t, retries: a, headers: n, blockIdentifier: r, chainId: c } = e;
    this.nodeUrl = t, this.retries = a || Ci.retries, this.headers = { ...Ci.headers, ...n }, this.blockIdentifier = r || Ci.blockIdentifier, this.chainId = c, this.getChainId();
  }
  fetch(e, t) {
    return gu(this.nodeUrl, {
      method: "POST",
      body: Tt({ method: e, jsonrpc: "2.0", params: t, id: 0 }),
      headers: this.headers
    });
  }
  errorHandler(e) {
    if (e) {
      const { code: t, message: a } = e;
      throw new Kn(`${t}: ${a}`);
    }
  }
  async fetchEndpoint(e, t) {
    try {
      const a = await this.fetch(e, t), { error: n, result: r } = await a.json();
      return this.errorHandler(n), r;
    } catch (a) {
      throw this.errorHandler(a?.response?.data), a;
    }
  }
  // Methods from Interface
  async getChainId() {
    return this.chainId ?? (this.chainId = await this.fetchEndpoint("starknet_chainId")), this.chainId;
  }
  async getBlock(e = this.blockIdentifier) {
    return this.getBlockWithTxHashes(e).then(
      this.responseParser.parseGetBlockResponse
    );
  }
  async getBlockHashAndNumber() {
    return this.fetchEndpoint("starknet_blockHashAndNumber");
  }
  async getBlockWithTxHashes(e = this.blockIdentifier) {
    const t = new me(e).identifier;
    return this.fetchEndpoint("starknet_getBlockWithTxHashes", { block_id: t });
  }
  async getBlockWithTxs(e = this.blockIdentifier) {
    const t = new me(e).identifier;
    return this.fetchEndpoint("starknet_getBlockWithTxs", { block_id: t });
  }
  async getClassHashAt(e, t = this.blockIdentifier) {
    const a = new me(t).identifier;
    return this.fetchEndpoint("starknet_getClassHashAt", {
      block_id: a,
      contract_address: e
    });
  }
  async getNonceForAddress(e, t = this.blockIdentifier) {
    const a = new me(t).identifier;
    return this.fetchEndpoint("starknet_getNonce", {
      contract_address: e,
      block_id: a
    });
  }
  async getPendingTransactions() {
    return this.fetchEndpoint("starknet_pendingTransactions");
  }
  async getProtocolVersion() {
    throw new Error("Pathfinder does not implement this rpc 0.1.0 method");
  }
  async getStateUpdate(e = this.blockIdentifier) {
    const t = new me(e).identifier;
    return this.fetchEndpoint("starknet_getStateUpdate", { block_id: t });
  }
  async getStorageAt(e, t, a = this.blockIdentifier) {
    const n = P(t), r = new me(a).identifier;
    return this.fetchEndpoint("starknet_getStorageAt", {
      contract_address: e,
      key: n,
      block_id: r
    });
  }
  // Methods from Interface
  async getTransaction(e) {
    return this.getTransactionByHash(e).then(this.responseParser.parseGetTransactionResponse);
  }
  async getTransactionByHash(e) {
    return this.fetchEndpoint("starknet_getTransactionByHash", { transaction_hash: e });
  }
  async getTransactionByBlockIdAndIndex(e, t) {
    const a = new me(e).identifier;
    return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex", { block_id: a, index: t });
  }
  async getTransactionReceipt(e) {
    return this.fetchEndpoint("starknet_getTransactionReceipt", { transaction_hash: e });
  }
  async getClassByHash(e) {
    return this.getClass(e);
  }
  async getClass(e, t = this.blockIdentifier) {
    const a = new me(t).identifier;
    return this.fetchEndpoint("starknet_getClass", { class_hash: e, block_id: a });
  }
  async getClassAt(e, t = this.blockIdentifier) {
    const a = new me(t).identifier;
    return this.fetchEndpoint("starknet_getClassAt", {
      block_id: a,
      contract_address: e
    });
  }
  async getCode(e, t) {
    throw new Error("RPC does not implement getCode function");
  }
  async getEstimateFee(e, t, a = this.blockIdentifier) {
    return this.getInvokeEstimateFee(e, t, a);
  }
  async getInvokeEstimateFee(e, t, a = this.blockIdentifier) {
    const n = new me(a).identifier;
    return this.fetchEndpoint("starknet_estimateFee", {
      request: {
        type: vt.TransactionType.INVOKE,
        sender_address: e.contractAddress,
        calldata: re.toHex(e.calldata),
        signature: na(e.signature),
        version: P(t?.version || 0),
        nonce: P(t.nonce),
        max_fee: P(t?.maxFee || 0)
      },
      block_id: n
    }).then(this.responseParser.parseFeeEstimateResponse);
  }
  async getDeclareEstimateFee({ senderAddress: e, contractDefinition: t, signature: a }, n, r = this.blockIdentifier) {
    const c = new me(r).identifier;
    if ("program" in t)
      return this.fetchEndpoint("starknet_estimateFee", {
        request: {
          type: vt.TransactionType.DECLARE,
          contract_class: {
            program: t.program,
            entry_points_by_type: t.entry_points_by_type,
            abi: t.abi
            // rpc 2.0
          },
          sender_address: e,
          signature: na(a),
          version: P(n?.version || 0),
          nonce: P(n.nonce),
          max_fee: P(n?.maxFee || 0)
        },
        block_id: c
      }).then(this.responseParser.parseFeeEstimateResponse);
    throw new Error("RPC do not support Sierra Contracts yet");
  }
  async getDeployAccountEstimateFee({ classHash: e, constructorCalldata: t, addressSalt: a, signature: n }, r, c = this.blockIdentifier) {
    const i = new me(c).identifier;
    return this.fetchEndpoint("starknet_estimateFee", {
      request: {
        type: vt.TransactionType.DEPLOY_ACCOUNT,
        constructor_calldata: re.toHex(t || []),
        class_hash: P(e),
        contract_address_salt: P(a || 0),
        signature: na(n),
        version: P(r?.version || 0),
        nonce: P(r.nonce),
        max_fee: P(r?.maxFee || 0)
      },
      block_id: i
    }).then(this.responseParser.parseFeeEstimateResponse);
  }
  async getEstimateFeeBulk(e, t = this.blockIdentifier) {
    throw new Error("RPC does not implement getInvokeEstimateFeeBulk function");
  }
  // TODO: Revisit after Pathfinder release with JSON-RPC v0.2.1 RPC Spec
  async declareContract({ contractDefinition: e, signature: t, senderAddress: a }, n) {
    if ("program" in e)
      return this.fetchEndpoint("starknet_addDeclareTransaction", {
        declare_transaction: {
          contract_class: {
            program: e.program,
            entry_points_by_type: e.entry_points_by_type,
            abi: e.abi
            // rpc 2.0
          },
          type: vt.TransactionType.DECLARE,
          version: "0x1",
          max_fee: P(n.maxFee || 0),
          signature: na(t),
          sender_address: a,
          nonce: P(n.nonce)
        }
      });
    throw new Error("RPC do not support Sierra Contracts yet");
  }
  async deployAccountContract({ classHash: e, constructorCalldata: t, addressSalt: a, signature: n }, r) {
    return this.fetchEndpoint("starknet_addDeployAccountTransaction", {
      deploy_account_transaction: {
        constructor_calldata: re.toHex(t || []),
        class_hash: P(e),
        contract_address_salt: P(a || 0),
        type: vt.TransactionType.DEPLOY_ACCOUNT,
        max_fee: P(r.maxFee || 0),
        version: P(r.version || 0),
        signature: na(n),
        nonce: P(r.nonce)
      }
    });
  }
  async invokeFunction(e, t) {
    return this.fetchEndpoint("starknet_addInvokeTransaction", {
      invoke_transaction: {
        sender_address: e.contractAddress,
        calldata: re.toHex(e.calldata),
        type: vt.TransactionType.INVOKE,
        max_fee: P(t.maxFee || 0),
        version: "0x1",
        signature: na(e.signature),
        nonce: P(t.nonce)
      }
    });
  }
  // Methods from Interface
  async callContract(e, t = this.blockIdentifier) {
    const a = new me(t).identifier, n = await this.fetchEndpoint("starknet_call", {
      request: {
        contract_address: e.contractAddress,
        entry_point_selector: ht(e.entrypoint),
        calldata: re.toHex(e.calldata)
      },
      block_id: a
    });
    return this.responseParser.parseCallContractResponse(n);
  }
  async traceTransaction(e) {
    return this.fetchEndpoint("starknet_traceTransaction", { transaction_hash: e });
  }
  async traceBlockTransactions(e) {
    return this.fetchEndpoint("starknet_traceBlockTransactions", { block_hash: e });
  }
  async waitForTransaction(e, t) {
    const a = [
      "REJECTED",
      "NOT_RECEIVED"
      /* NOT_RECEIVED */
    ];
    let { retries: n } = this, r = !1, c = {};
    const i = t?.retryInterval ?? 8e3, s = t?.successStates ?? [
      "ACCEPTED_ON_L1",
      "ACCEPTED_ON_L2",
      "PENDING"
      /* PENDING */
    ];
    for (; !r; ) {
      await ns(i);
      try {
        if (c = await this.getTransactionReceipt(e), !("status" in c))
          throw new Error("pending transaction");
        if (c.status && s.includes(c.status))
          r = !0;
        else if (c.status && a.includes(c.status)) {
          const o = c.status, d = new Error(o);
          throw d.response = c, d;
        }
      } catch (o) {
        if (o instanceof Error && a.includes(o.message))
          throw o;
        if (n === 0)
          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
      }
      n -= 1;
    }
    return await ns(i), c;
  }
  /**
   * Gets the transaction count from a block.
   *
   *
   * @param blockIdentifier
   * @returns Number of transactions
   */
  async getTransactionCount(e = this.blockIdentifier) {
    const t = new me(e).identifier;
    return this.fetchEndpoint("starknet_getBlockTransactionCount", { block_id: t });
  }
  /**
   * Gets the latest block number
   *
   *
   * @returns Number of the latest block
   */
  async getBlockNumber() {
    return this.fetchEndpoint("starknet_blockNumber");
  }
  /**
   * Gets syncing status of the node
   *
   *
   * @returns Object with the stats data
   */
  async getSyncingStats() {
    return this.fetchEndpoint("starknet_syncing");
  }
  /**
   * Gets all the events filtered
   *
   *
   * @returns events and the pagination of the events
   */
  async getEvents(e) {
    return this.fetchEndpoint("starknet_getEvents", { filter: e });
  }
  async getSimulateTransaction(e, t, a) {
    throw new Error("RPC does not implement simulateTransaction function");
  }
  async getStarkName(e, t) {
    return fo(this, e, t);
  }
  async getAddressFromStarkName(e, t) {
    return lo(this, e, t);
  }
}, p5 = class {
}, m5 = class extends p5 {
  parseGetBlockResponse(e) {
    return {
      ...e,
      new_root: e.state_root,
      parent_hash: e.parent_block_hash,
      transactions: Object.values(e.transactions).map((t) => "transaction_hash" in t && t.transaction_hash).filter(Boolean)
    };
  }
  parseGetTransactionResponse(e) {
    return {
      ...e,
      calldata: "calldata" in e.transaction ? e.transaction.calldata : [],
      contract_class: "contract_class" in e.transaction ? e.transaction.contract_class : void 0,
      entry_point_selector: "entry_point_selector" in e.transaction ? e.transaction.entry_point_selector : void 0,
      max_fee: "max_fee" in e.transaction ? e.transaction.max_fee : void 0,
      nonce: e.transaction.nonce,
      sender_address: "sender_address" in e.transaction ? e.transaction.sender_address : void 0,
      signature: "signature" in e.transaction ? e.transaction.signature : void 0,
      transaction_hash: "transaction_hash" in e.transaction ? e.transaction.transaction_hash : void 0,
      version: "version" in e.transaction ? e.transaction.version : void 0
    };
  }
  parseGetTransactionReceiptResponse(e) {
    return {
      transaction_hash: e.transaction_hash,
      status: e.status,
      messages_sent: e.l2_to_l1_messages,
      // TODO: parse
      events: e.events,
      ..."block_hash" in e && { block_hash: e.block_hash },
      ..."block_number" in e && { block_number: e.block_number },
      ..."actual_fee" in e && { actual_fee: e.actual_fee },
      ..."transaction_index" in e && { transaction_index: e.transaction_index },
      ..."execution_resources" in e && { execution_resources: e.execution_resources },
      ..."l1_to_l2_consumed_message" in e && {
        // eslint-disable-next-line @typescript-eslint/dot-notation
        l1_to_l2_consumed_message: e.l1_to_l2_consumed_message
      },
      ..."transaction_failure_reason" in e && {
        transaction_failure_reason: e.transaction_failure_reason
      }
    };
  }
  parseFeeEstimateResponse(e) {
    if ("overall_fee" in e) {
      let t = {};
      try {
        t = {
          gas_consumed: Z(e.gas_usage),
          gas_price: Z(e.gas_price)
        };
      } catch {
      }
      return {
        overall_fee: Z(e.overall_fee),
        ...t
      };
    }
    return {
      overall_fee: Z(e.amount)
    };
  }
  parseFeeEstimateBulkResponse(e) {
    return [].concat(e).map((t) => {
      if ("overall_fee" in t) {
        let a = {};
        try {
          a = {
            gas_consumed: Z(t.gas_usage),
            gas_price: Z(t.gas_price)
          };
        } catch {
        }
        return {
          overall_fee: Z(t.overall_fee),
          ...a
        };
      }
      return {
        overall_fee: Z(t.amount)
      };
    });
  }
  parseFeeSimulateTransactionResponse(e) {
    if ("overall_fee" in e.fee_estimation) {
      let t = {};
      try {
        t = {
          gas_consumed: Z(e.fee_estimation.gas_usage),
          gas_price: Z(e.fee_estimation.gas_price)
        };
      } catch {
      }
      return {
        trace: e.trace,
        fee_estimation: {
          ...t,
          overall_fee: Z(e.fee_estimation.overall_fee)
        }
      };
    }
    return {
      trace: e.trace,
      fee_estimation: {
        overall_fee: Z(e.fee_estimation.amount)
      }
    };
  }
  parseCallContractResponse(e) {
    return {
      result: e.result
    };
  }
  parseInvokeFunctionResponse(e) {
    return {
      transaction_hash: e.transaction_hash
    };
  }
  parseDeployContractResponse(e) {
    return {
      transaction_hash: e.transaction_hash,
      contract_address: e.address
    };
  }
  parseDeclareContractResponse(e) {
    return {
      transaction_hash: e.transaction_hash,
      class_hash: e.class_hash
    };
  }
  parseGetStateUpdateResponse(e) {
    const t = Object.entries(e.state_diff.nonces).map(([n, r]) => ({
      contract_address: n,
      nonce: r
    })), a = Object.entries(e.state_diff.storage_diffs).map(
      ([n, r]) => ({ address: n, storage_entries: r })
    );
    return {
      ...e,
      state_diff: {
        ...e.state_diff,
        storage_diffs: a,
        nonces: t
      }
    };
  }
  // TODO: Define response as new type as it diff from ContractClass
  parseSierraContractClassResponse(e) {
    return {
      ...e,
      abi: JSON.parse(e.abi)
    };
  }
}, g5 = /^(?:\w+:)?\/\/(\S+)$/, _5 = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/, y5 = /^[^\s.]+\.\S{2,}$/;
function w5(e) {
  if (!e || typeof e != "string")
    return !1;
  const t = e.match(g5);
  if (!t)
    return !1;
  const a = t[1];
  return a ? !!(_5.test(a) || y5.test(a)) : !1;
}
function xn(e, t, a) {
  return w5(a) ? a : Pl(e, a ?? t);
}
function v5(e) {
  return e === void 0 || Object.keys(e).length === 0 || Object.keys(e).length === 1 && Object.entries(e).every(([t, a]) => t === "blockIdentifier" && a === null);
}
var Zd = {
  network: "SN_GOERLI2",
  blockIdentifier: "pending"
}, Va = class {
  constructor(e = Zd) {
    this.responseParser = new m5(), "network" in e ? (this.baseUrl = Va.getNetworkFromName(e.network), this.feederGatewayUrl = xn(this.baseUrl, "feeder_gateway"), this.gatewayUrl = xn(this.baseUrl, "gateway")) : (this.baseUrl = e.baseUrl, this.feederGatewayUrl = xn(
      this.baseUrl,
      "feeder_gateway",
      e.feederGatewayUrl
    ), this.gatewayUrl = xn(this.baseUrl, "gateway", e.gatewayUrl)), this.chainId = e?.chainId ?? Va.getChainIdFromBaseUrl(this.baseUrl), this.headers = e.headers, this.blockIdentifier = e?.blockIdentifier || Zd.blockIdentifier;
  }
  static getNetworkFromName(e) {
    switch (e) {
      case "SN_MAIN":
        return "https://alpha-mainnet.starknet.io";
      case "SN_GOERLI":
        return "https://alpha4.starknet.io";
      case "SN_GOERLI2":
        return "https://alpha4-2.starknet.io";
      default:
        throw new Error("Could not detect base url from NetworkName");
    }
  }
  static getChainIdFromBaseUrl(e) {
    try {
      const t = new URL(e);
      return t.host.includes("mainnet.starknet.io") ? "0x534e5f4d41494e" : t.host.includes("alpha4-2.starknet.io") ? "0x534e5f474f45524c4932" : "0x534e5f474f45524c49";
    } catch {
      return console.error(`Could not parse baseUrl: ${e}`), "0x534e5f474f45524c49";
    }
  }
  getFetchUrl(e) {
    return ["add_transaction"].includes(e) ? this.gatewayUrl : this.feederGatewayUrl;
  }
  getFetchMethod(e) {
    return [
      "add_transaction",
      "call_contract",
      "estimate_fee",
      "estimate_message_fee",
      "estimate_fee_bulk",
      "simulate_transaction"
    ].includes(e) ? "POST" : "GET";
  }
  getQueryString(e) {
    return v5(e) ? "" : `?${Object.entries(e).map(([a, n]) => a === "blockIdentifier" ? `${new me(n).queryIdentifier}` : `${a}=${n}`).join("&")}`;
  }
  getHeaders(e) {
    return e === "POST" ? {
      "Content-Type": "application/json",
      ...this.headers
    } : this.headers;
  }
  // typesafe fetch
  async fetchEndpoint(e, ...[t, a]) {
    const n = this.getFetchUrl(e), r = this.getFetchMethod(e), c = this.getQueryString(t), i = Pl(n, e, c);
    return this.fetch(i, {
      method: r,
      body: a
    });
  }
  async fetch(e, t) {
    const a = xn(this.baseUrl, "", e), n = t?.method ?? "GET", r = this.getHeaders(n), c = Tt(t?.body);
    try {
      const i = await gu(a, {
        method: n,
        body: c,
        headers: r
      }), s = await i.text();
      if (!i.ok) {
        let d;
        try {
          d = wa(s);
        } catch {
          throw new u5(i.statusText, i.status);
        }
        throw new l5(d.message, d.code);
      }
      return (t?.parseAlwaysAsBigInt ? _u : wa)(s);
    } catch (i) {
      throw i instanceof Error && !(i instanceof Kn) ? Error(`Could not ${n} from endpoint \`${a}\`: ${i.message}`) : i;
    }
  }
  async getChainId() {
    return Promise.resolve(this.chainId);
  }
  async callContract({ contractAddress: e, entrypoint: t, calldata: a = [] }, n = this.blockIdentifier) {
    return this.fetchEndpoint(
      "call_contract",
      { blockIdentifier: n },
      {
        // TODO - determine best choice once both are fully supported in devnet
        // signature: [],
        // sender_address: contractAddress,
        contract_address: e,
        entry_point_selector: ht(t),
        calldata: re.compile(a)
      }
    ).then(this.responseParser.parseCallContractResponse);
  }
  async getBlock(e = this.blockIdentifier) {
    return this.fetchEndpoint("get_block", { blockIdentifier: e }).then(
      this.responseParser.parseGetBlockResponse
    );
  }
  async getNonceForAddress(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_nonce", { contractAddress: e, blockIdentifier: t });
  }
  async getStorageAt(e, t, a = this.blockIdentifier) {
    const n = Z(t).toString(10);
    return this.fetchEndpoint("get_storage_at", {
      blockIdentifier: a,
      contractAddress: e,
      key: n
    });
  }
  async getTransaction(e) {
    const t = P(e);
    return this.fetchEndpoint("get_transaction", { transactionHash: t }).then((a) => {
      if (Object.values(a).length === 1)
        throw new Kn(a.status);
      return this.responseParser.parseGetTransactionResponse(a);
    });
  }
  async getTransactionReceipt(e) {
    const t = P(e);
    return this.fetchEndpoint("get_transaction_receipt", { transactionHash: t }).then(
      this.responseParser.parseGetTransactionReceiptResponse
    );
  }
  async getClassAt(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_full_contract", { blockIdentifier: t, contractAddress: e }).then(
      (a) => jt(a) ? this.responseParser.parseSierraContractClassResponse(a) : rs(a)
    );
  }
  async getClassHashAt(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_class_hash_at", { blockIdentifier: t, contractAddress: e });
  }
  async getClassByHash(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_class_by_hash", { classHash: e, blockIdentifier: t }).then((a) => jt(a) ? this.responseParser.parseSierraContractClassResponse(a) : rs(a));
  }
  async getCompiledClassByClassHash(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_compiled_class_by_class_hash", { classHash: e, blockIdentifier: t });
  }
  async invokeFunction(e, t) {
    return this.fetchEndpoint("add_transaction", void 0, {
      type: "INVOKE_FUNCTION",
      sender_address: e.contractAddress,
      calldata: re.compile(e.calldata ?? []),
      signature: tt(e.signature),
      nonce: P(t.nonce),
      max_fee: P(t.maxFee || 0),
      version: "0x1"
    }).then(this.responseParser.parseInvokeFunctionResponse);
  }
  async deployAccountContract({ classHash: e, constructorCalldata: t, addressSalt: a, signature: n }, r) {
    return this.fetchEndpoint("add_transaction", void 0, {
      type: "DEPLOY_ACCOUNT",
      contract_address_salt: a ?? so(),
      constructor_calldata: re.compile(t ?? []),
      class_hash: P(e),
      max_fee: P(r.maxFee || 0),
      version: P(r.version || 0),
      nonce: P(r.nonce),
      signature: tt(n)
    }).then(this.responseParser.parseDeployContractResponse);
  }
  async declareContract({ senderAddress: e, contractDefinition: t, signature: a, compiledClassHash: n }, r) {
    return jt(t) ? this.fetchEndpoint("add_transaction", void 0, {
      type: "DECLARE",
      sender_address: e,
      compiled_class_hash: n,
      contract_class: t,
      nonce: P(r.nonce),
      signature: tt(a),
      max_fee: P(r.maxFee || 0),
      version: "0x2"
    }).then(this.responseParser.parseDeclareContractResponse) : this.fetchEndpoint("add_transaction", void 0, {
      type: "DECLARE",
      contract_class: t,
      nonce: P(r.nonce),
      signature: tt(a),
      sender_address: e,
      max_fee: P(r.maxFee || 0),
      version: "0x1"
    }).then(this.responseParser.parseDeclareContractResponse);
  }
  async getEstimateFee(e, t, a = this.blockIdentifier, n = !1) {
    return this.getInvokeEstimateFee(e, t, a, n);
  }
  async getInvokeEstimateFee(e, t, a = this.blockIdentifier, n = !1) {
    return this.fetchEndpoint(
      "estimate_fee",
      { blockIdentifier: a, skipValidate: n },
      {
        type: "INVOKE_FUNCTION",
        sender_address: e.contractAddress,
        calldata: re.compile(e.calldata ?? []),
        signature: tt(e.signature),
        version: P(t?.version || 1),
        nonce: P(t.nonce)
      }
    ).then(this.responseParser.parseFeeEstimateResponse);
  }
  async getDeclareEstimateFee({ senderAddress: e, contractDefinition: t, signature: a, compiledClassHash: n }, r, c = this.blockIdentifier, i = !1) {
    return jt(t) ? this.fetchEndpoint(
      "estimate_fee",
      { blockIdentifier: c, skipValidate: i },
      {
        type: "DECLARE",
        sender_address: e,
        compiled_class_hash: n,
        contract_class: t,
        nonce: P(r.nonce),
        signature: tt(a),
        version: "0x2"
      }
    ).then(this.responseParser.parseFeeEstimateResponse) : this.fetchEndpoint(
      "estimate_fee",
      { blockIdentifier: c, skipValidate: i },
      {
        type: "DECLARE",
        sender_address: e,
        contract_class: t,
        signature: tt(a),
        version: P(r?.version || Z(sa)),
        nonce: P(r.nonce)
      }
    ).then(this.responseParser.parseFeeEstimateResponse);
  }
  async getDeployAccountEstimateFee({ classHash: e, addressSalt: t, constructorCalldata: a, signature: n }, r, c = this.blockIdentifier, i = !1) {
    return this.fetchEndpoint(
      "estimate_fee",
      { blockIdentifier: c, skipValidate: i },
      {
        type: "DEPLOY_ACCOUNT",
        class_hash: P(e),
        constructor_calldata: re.compile(a || []),
        contract_address_salt: P(t || 0),
        signature: tt(n),
        version: P(r?.version || 0),
        nonce: P(r.nonce)
      }
    ).then(this.responseParser.parseFeeEstimateResponse);
  }
  async getEstimateFeeBulk(e, t = this.blockIdentifier) {
    const a = e.map((n) => {
      let r;
      return n.type === "INVOKE_FUNCTION" ? r = {
        type: n.type,
        sender_address: n.contractAddress,
        calldata: re.compile(n.calldata ?? [])
      } : n.type === "DECLARE" ? r = {
        type: n.type,
        sender_address: n.senderAddress,
        contract_class: n.contractDefinition
      } : r = {
        type: n.type,
        class_hash: P(Z(n.classHash)),
        constructor_calldata: re.compile(n.constructorCalldata || []),
        contract_address_salt: P(Z(n.addressSalt || 0))
      }, {
        ...r,
        signature: qs(Nr(n.signature)),
        version: P(Z(n?.version || 1)),
        nonce: P(Z(n.nonce))
      };
    });
    return this.fetchEndpoint("estimate_fee_bulk", { blockIdentifier: t }, a).then(
      this.responseParser.parseFeeEstimateBulkResponse
    );
  }
  async getCode(e, t = this.blockIdentifier) {
    return this.fetchEndpoint("get_code", { contractAddress: e, blockIdentifier: t });
  }
  async waitForTransaction(e, t) {
    const a = [
      "REJECTED",
      "NOT_RECEIVED"
      /* NOT_RECEIVED */
    ];
    let n = !1, r;
    const c = t?.retryInterval ?? 8e3, i = t?.successStates ?? [
      "ACCEPTED_ON_L1",
      "ACCEPTED_ON_L2",
      "PENDING"
      /* PENDING */
    ];
    for (; !n; )
      if (await ns(c), r = await this.getTransactionStatus(e), i.includes(r.tx_status))
        n = !0;
      else if (a.includes(r.tx_status)) {
        const o = r.tx_failure_reason ? `${r.tx_status}: ${r.tx_failure_reason.code}
${r.tx_failure_reason.error_message}` : r.tx_status, d = new Error(o);
        throw d.response = r, d;
      }
    return await this.getTransactionReceipt(e);
  }
  /**
   * Gets the status of a transaction.
   *
   * [Reference](https://github.com/starkware-libs/cairo-lang/blob/f464ec4797361b6be8989e36e02ec690e74ef285/src/starkware/starknet/services/api/feeder_gateway/feeder_gateway_client.py#L48-L52)
   *
   * @param txHash
   * @returns the transaction status object \{ block_number, tx_status: NOT_RECEIVED | RECEIVED | PENDING | REJECTED | ACCEPTED_ONCHAIN \}
   */
  async getTransactionStatus(e) {
    const t = P(e);
    return this.fetchEndpoint("get_transaction_status", { transactionHash: t });
  }
  /**
   * Gets the smart contract address on the goerli testnet.
   *
   * [Reference](https://github.com/starkware-libs/cairo-lang/blob/f464ec4797361b6be8989e36e02ec690e74ef285/src/starkware/starknet/services/api/feeder_gateway/feeder_gateway_client.py#L13-L15)
   * @returns starknet smart contract addresses
   */
  async getContractAddresses() {
    return this.fetchEndpoint("get_contract_addresses");
  }
  /**
   * Gets the transaction trace from a tx id.
   *
   * @param txHash
   * @returns the transaction trace
   */
  async getTransactionTrace(e) {
    const t = P(e);
    return this.fetchEndpoint("get_transaction_trace", { transactionHash: t });
  }
  async estimateMessageFee({ from_address: e, to_address: t, entry_point_selector: a, payload: n }, r = this.blockIdentifier) {
    const c = {
      from_address: Jl(e),
      to_address: Ks(t),
      entry_point_selector: au(a),
      payload: Ql(n)
    };
    return this.fetchEndpoint("estimate_message_fee", { blockIdentifier: r }, c);
  }
  async getSimulateTransaction(e, t, a = this.blockIdentifier, n = !1) {
    return this.fetchEndpoint(
      "simulate_transaction",
      { blockIdentifier: a, skipValidate: n },
      {
        type: "INVOKE_FUNCTION",
        sender_address: e.contractAddress,
        calldata: re.compile(e.calldata ?? []),
        signature: tt(e.signature),
        version: P(t?.version || 1),
        nonce: P(t.nonce),
        max_fee: P(t?.maxFee || 0)
      }
    ).then(this.responseParser.parseFeeSimulateTransactionResponse);
  }
  async getStateUpdate(e = this.blockIdentifier) {
    const t = new me(e).sequencerIdentifier;
    return this.fetchEndpoint("get_state_update", { ...t }).then(
      this.responseParser.parseGetStateUpdateResponse
    );
  }
  // consider adding an optional trace retrieval parameter to the getBlock method
  async getBlockTraces(e = this.blockIdentifier) {
    const t = new me(e).sequencerIdentifier;
    return this.fetchEndpoint("get_block_traces", { ...t });
  }
  async getStarkName(e, t) {
    return fo(this, e, t);
  }
  async getAddressFromStarkName(e, t) {
    return lo(this, e, t);
  }
}, uo = class {
  constructor(e) {
    e instanceof uo ? this.provider = e.provider : e instanceof Bd || e instanceof Va ? this.provider = e : e && "rpc" in e ? this.provider = new Bd(e.rpc) : e && "sequencer" in e ? this.provider = new Va(e.sequencer) : this.provider = new Va();
  }
  async getChainId() {
    return this.provider.getChainId();
  }
  async getBlock(e) {
    return this.provider.getBlock(e);
  }
  async getClassAt(e, t) {
    return this.provider.getClassAt(e, t);
  }
  async getClassHashAt(e, t) {
    return this.provider.getClassHashAt(e, t);
  }
  getClassByHash(e) {
    return this.provider.getClassByHash(e);
  }
  async getEstimateFee(e, t, a) {
    return this.provider.getEstimateFee(e, t, a);
  }
  async getInvokeEstimateFee(e, t, a, n) {
    return this.provider.getInvokeEstimateFee(
      e,
      t,
      a,
      n
    );
  }
  async getEstimateFeeBulk(e, t) {
    return this.provider.getEstimateFeeBulk(e, t);
  }
  async getNonceForAddress(e, t) {
    return this.provider.getNonceForAddress(e, t);
  }
  async getStorageAt(e, t, a) {
    return this.provider.getStorageAt(e, t, a);
  }
  async getTransaction(e) {
    return this.provider.getTransaction(e);
  }
  async getTransactionReceipt(e) {
    return this.provider.getTransactionReceipt(e);
  }
  async callContract(e, t) {
    return this.provider.callContract(e, t);
  }
  async invokeFunction(e, t) {
    return this.provider.invokeFunction(e, t);
  }
  async deployAccountContract(e, t) {
    return this.provider.deployAccountContract(e, t);
  }
  async declareContract(e, t) {
    return this.provider.declareContract(e, t);
  }
  async getDeclareEstimateFee(e, t, a, n) {
    return this.provider.getDeclareEstimateFee(e, t, a, n);
  }
  getDeployAccountEstimateFee(e, t, a, n) {
    return this.provider.getDeployAccountEstimateFee(
      e,
      t,
      a,
      n
    );
  }
  async getCode(e, t) {
    return this.provider.getCode(e, t);
  }
  async waitForTransaction(e, t) {
    return this.provider.waitForTransaction(e, t);
  }
  async getSimulateTransaction(e, t, a, n) {
    return this.provider.getSimulateTransaction(
      e,
      t,
      a,
      n
    );
  }
  async getStateUpdate(e) {
    return this.provider.getStateUpdate(e);
  }
  async getStarkName(e, t) {
    return fo(this, e, t);
  }
  async getAddressFromStarkName(e, t) {
    return lo(this, e, t);
  }
}, x5 = {};
Ae(x5, {
  fromCallsToExecuteCalldata: () => bo,
  fromCallsToExecuteCalldataWithNonce: () => E5,
  fromCallsToExecuteCalldata_cairo1: () => Nu,
  getExecuteCalldata: () => oc,
  transformCallsToMulticallArrays: () => Iu,
  transformCallsToMulticallArrays_cairo1: () => k5
});
var Iu = (e) => {
  const t = [], a = [];
  return e.forEach((n) => {
    const r = re.compile(n.calldata || []);
    t.push({
      to: Z(n.contractAddress).toString(10),
      selector: Z(ht(n.entrypoint)).toString(10),
      data_offset: a.length.toString(),
      data_len: r.length.toString()
    }), a.push(...r);
  }), {
    callArray: t,
    calldata: re.compile({ calldata: a })
  };
}, bo = (e) => {
  const { callArray: t, calldata: a } = Iu(e);
  return [...re.compile({ callArray: t }), ...a];
}, E5 = (e, t) => [...bo(e), Z(t).toString()], k5 = (e) => e.map((a) => ({
  to: Z(a.contractAddress).toString(10),
  selector: Z(ht(a.entrypoint)).toString(10),
  calldata: re.compile(a.calldata || [])
})), Nu = (e) => {
  const t = e.map((a) => ({
    contractAddress: a.contractAddress,
    entrypoint: a.entrypoint,
    calldata: a.calldata
  }));
  return re.compile({ orderCalls: t });
}, oc = (e, t = "0") => t === "1" ? Nu(e) : bo(e), T5 = {};
Ae(T5, {
  encodeData: () => Bu,
  encodeType: () => $u,
  encodeValue: () => po,
  getDependencies: () => ho,
  getMessageHash: () => mo,
  getStructHash: () => Gn,
  getTypeHash: () => Du,
  isMerkleTreeType: () => Lu,
  prepareSelector: () => Pu
});
var S5 = {};
Ae(S5, {
  MerkleTree: () => qa,
  proofMerklePath: () => Ru
});
var qa = class {
  constructor(e) {
    this.branches = [], this.leaves = e, this.root = this.build(e);
  }
  build(e) {
    if (e.length === 1)
      return e[0];
    e.length !== this.leaves.length && this.branches.push(e);
    const t = [];
    for (let a = 0; a < e.length; a += 2)
      a + 1 === e.length ? t.push(qa.hash(e[a], "0x0")) : t.push(qa.hash(e[a], e[a + 1]));
    return this.build(t);
  }
  static hash(e, t) {
    const [a, n] = [Z(e), Z(t)].sort((r, c) => r >= c ? 1 : -1);
    return dn(a, n);
  }
  getProof(e, t = this.leaves, a = []) {
    const n = t.indexOf(e);
    if (n === -1)
      throw new Error("leaf not found");
    if (t.length === 1)
      return a;
    const r = n % 2 === 0, c = (r ? t[n + 1] : t[n - 1]) ?? "0x0", i = [...a, c], s = this.leaves.length === t.length ? -1 : this.branches.findIndex((d) => d.length === t.length), o = this.branches[s + 1] ?? [this.root];
    return this.getProof(
      qa.hash(r ? e : c, r ? c : e),
      o,
      i
    );
  }
};
function Ru(e, t, a) {
  if (a.length === 0)
    return e === t;
  const [n, ...r] = a;
  return Ru(e, qa.hash(t, n), r);
}
function C5(e) {
  try {
    return P(e);
  } catch {
    if (typeof e == "string")
      return P(ea(e));
    throw new Error(`Invalid BigNumberish: ${e}`);
  }
}
var A5 = (e) => {
  const t = e;
  return !!(t.types && t.primaryType && t.message);
};
function Pu(e) {
  return bt(e) ? e : ht(e);
}
function Lu(e) {
  return e.type === "merkletree";
}
var ho = (e, t, a = []) => (t[t.length - 1] === "*" && (t = t.slice(0, -1)), a.includes(t) || !e[t] ? a : [
  t,
  ...e[t].reduce(
    (n, r) => [
      ...n,
      ...ho(e, r.type, n).filter(
        (c) => !n.includes(c)
      )
    ],
    []
  )
]);
function O5(e, t) {
  if (t.parent && t.key) {
    const n = e[t.parent].find((c) => c.name === t.key);
    if (!Lu(n))
      throw new Error(`${t.key} is not a merkle tree`);
    if (n.contains.endsWith("*"))
      throw new Error(`Merkle tree contain property must not be an array but was given ${t.key}`);
    return n.contains;
  }
  return "raw";
}
var $u = (e, t) => {
  const [a, ...n] = ho(e, t);
  return (a ? [a, ...n.sort()] : []).map((c) => `${c}(${e[c].map((i) => `${i.name}:${i.type}`)})`).join("");
}, Du = (e, t) => ht($u(e, t)), po = (e, t, a, n = {}) => {
  if (e[t])
    return [t, Gn(e, t, a)];
  if (Object.keys(e).map((r) => `${r}*`).includes(t)) {
    const r = a.map((c) => Gn(e, t.slice(0, -1), c));
    return [t, ke(r)];
  }
  if (t === "merkletree") {
    const r = O5(e, n), c = a.map((s) => po(e, r, s)[1]), { root: i } = new qa(c);
    return ["felt", i];
  }
  return t === "felt*" ? ["felt*", ke(a)] : t === "selector" ? ["felt", Pu(a)] : [t, C5(a)];
}, Bu = (e, t, a) => {
  const [n, r] = e[t].reduce(
    ([c, i], s) => {
      if (a[s.name] === void 0 || a[s.name] === null)
        throw new Error(`Cannot encode data: missing data for '${s.name}'`);
      const o = a[s.name], [d, f] = po(e, s.type, o, {
        parent: t,
        key: s.name
      });
      return [
        [...c, d],
        [...i, f]
      ];
    },
    [["felt"], [Du(e, t)]]
  );
  return [n, r];
}, Gn = (e, t, a) => ke(Bu(e, t, a)[1]), mo = (e, t) => {
  if (!A5(e))
    throw new Error("Typed data does not match JSON schema");
  const a = [
    ea("StarkNet Message"),
    Gn(e.types, "StarkNetDomain", e.domain),
    t,
    Gn(e.types, e.primaryType, e.message)
  ];
  return ke(a);
}, I5 = class {
  constructor(e = As.randomPrivateKey()) {
    this.pk = e instanceof Uint8Array ? Bl(e) : P(e);
  }
  async getPubKey() {
    return Is(this.pk);
  }
  async signMessage(e, t) {
    const a = mo(e, t);
    return En(a, this.pk);
  }
  async signTransaction(e, t, a) {
    if (a && a.length !== e.length)
      throw new Error("ABI must be provided for each transaction or no transaction");
    const n = oc(e, t.cairoVersion), r = vu(
      t.walletAddress,
      t.version,
      n,
      t.maxFee,
      t.chainId,
      t.nonce
    );
    return En(r, this.pk);
  }
  async signDeployAccountTransaction({
    classHash: e,
    contractAddress: t,
    constructorCalldata: a,
    addressSalt: n,
    maxFee: r,
    version: c,
    chainId: i,
    nonce: s
  }) {
    const o = wu(
      t,
      e,
      re.compile(a),
      n,
      c,
      r,
      i,
      s
    );
    return En(o, this.pk);
  }
  async signDeclareTransaction({
    classHash: e,
    senderAddress: t,
    chainId: a,
    maxFee: n,
    version: r,
    nonce: c,
    compiledClassHash: i
  }) {
    const s = yu(
      e,
      t,
      r,
      n,
      a,
      c,
      i
    );
    return En(s, this.pk);
  }
};
function N5(e) {
  if (!e.events)
    throw new Error("UDC emited event is empty");
  const t = e.events.find(
    (a) => es(a.from_address) === es(ia.ADDRESS)
  ) || {
    data: []
  };
  return {
    transaction_hash: e.transaction_hash,
    contract_address: t.data[0],
    address: t.data[0],
    deployer: t.data[1],
    unique: t.data[2],
    classHash: t.data[3],
    calldata_len: t.data[4],
    calldata: t.data.slice(5, 5 + parseInt(t.data[4], 16)),
    salt: t.data[t.data.length - 1]
  };
}
var R5 = class extends uo {
  constructor(e, t, a, n = "0") {
    super(e), this.deploySelf = this.deployAccount, this.address = t.toLowerCase(), this.signer = typeof a == "string" || a instanceof Uint8Array ? new I5(a) : a, this.cairoVersion = n;
  }
  async getNonce(e) {
    return super.getNonceForAddress(this.address, e);
  }
  async estimateFee(e, t) {
    return this.estimateInvokeFee(e, t);
  }
  async estimateInvokeFee(e, { nonce: t, blockIdentifier: a, skipValidate: n } = {}) {
    const r = Array.isArray(e) ? e : [e], c = Z(t ?? await this.getNonce()), i = Z(sa), s = await this.getChainId(), o = {
      walletAddress: this.address,
      nonce: c,
      maxFee: Ie,
      version: i,
      chainId: s,
      cairoVersion: this.cairoVersion
    }, d = await this.buildInvocation(r, o), f = await super.getInvokeEstimateFee(
      { ...d },
      { version: i, nonce: c },
      a,
      n
    ), l = Da(f.overall_fee);
    return {
      ...f,
      suggestedMaxFee: l
    };
  }
  async estimateDeclareFee({ contract: e, classHash: t, casm: a, compiledClassHash: n }, { blockIdentifier: r, nonce: c, skipValidate: i } = {}) {
    const s = Z(c ?? await this.getNonce()), o = jt(e) ? as : Z(sa), d = await this.getChainId(), f = await this.buildDeclarePayload(
      { classHash: t, contract: e, casm: a, compiledClassHash: n },
      {
        nonce: s,
        chainId: d,
        version: o,
        walletAddress: this.address,
        maxFee: Ie,
        cairoVersion: this.cairoVersion
      }
    ), l = await super.getDeclareEstimateFee(
      f,
      { version: o, nonce: s },
      r,
      i
    ), b = Da(l.overall_fee);
    return {
      ...l,
      suggestedMaxFee: b
    };
  }
  async estimateAccountDeployFee({
    classHash: e,
    addressSalt: t = 0,
    constructorCalldata: a = [],
    contractAddress: n
  }, { blockIdentifier: r, skipValidate: c } = {}) {
    const i = Z(sa), s = Ie, o = await this.getChainId(), d = await this.buildAccountDeployPayload(
      { classHash: e, addressSalt: t, constructorCalldata: a, contractAddress: n },
      {
        nonce: s,
        chainId: o,
        version: i,
        walletAddress: this.address,
        maxFee: Ie,
        cairoVersion: this.cairoVersion
      }
    ), f = await super.getDeployAccountEstimateFee(
      { ...d },
      { version: i, nonce: s },
      r,
      c
    ), l = Da(f.overall_fee);
    return {
      ...f,
      suggestedMaxFee: l
    };
  }
  async estimateDeployFee(e, t) {
    const a = this.buildUDCContractPayload(e);
    return this.estimateInvokeFee(a, t);
  }
  async estimateFeeBulk(e, { nonce: t, blockIdentifier: a } = {}) {
    const n = Z(t ?? await this.getNonce()), r = Z(sa), c = await this.getChainId(), i = await Promise.all(
      [].concat(e).map(async (o, d) => {
        const f = {
          walletAddress: this.address,
          nonce: Z(Number(n) + d),
          maxFee: Ie,
          version: r,
          chainId: c,
          cairoVersion: this.cairoVersion
        }, l = o.payload;
        let b;
        if (typeof o == "object" && o.type === "INVOKE_FUNCTION")
          b = {
            type: "INVOKE_FUNCTION",
            ...await this.buildInvocation(
              Array.isArray(l) ? l : [l],
              f
            ),
            version: r,
            nonce: Z(Number(n) + d),
            blockIdentifier: a
          };
        else if (typeof o == "object" && o.type === "DECLARE")
          b = {
            type: "DECLARE",
            ...await this.buildDeclarePayload(l, f),
            version: r,
            nonce: Z(Number(n) + d),
            blockIdentifier: a
          };
        else if (typeof o == "object" && o.type === "DEPLOY_ACCOUNT")
          b = {
            type: "DEPLOY_ACCOUNT",
            ...await this.buildAccountDeployPayload(l, f),
            version: r,
            nonce: n,
            blockIdentifier: a
          };
        else if (typeof o == "object" && o.type === "DEPLOY") {
          const u = this.buildUDCContractPayload(l);
          b = {
            type: "INVOKE_FUNCTION",
            ...await this.buildInvocation(u, f),
            version: r,
            nonce: Z(Number(n) + d),
            blockIdentifier: a
          };
        }
        return b;
      })
    ), s = await super.getEstimateFeeBulk(i, a);
    return [].concat(s).map((o) => {
      const d = Da(o.overall_fee);
      return {
        ...o,
        suggestedMaxFee: d
      };
    });
  }
  async buildInvocation(e, t) {
    const a = oc(e, this.cairoVersion), n = await this.signer.signTransaction(e, t);
    return {
      contractAddress: this.address,
      calldata: a,
      signature: n
    };
  }
  async execute(e, t = void 0, a = {}) {
    const n = Array.isArray(e) ? e : [e], r = Z(a.nonce ?? await this.getNonce()), c = a.maxFee ?? await this.getSuggestedMaxFee(
      { type: "INVOKE_FUNCTION", payload: e },
      a
    ), i = Z(Rn), s = await this.getChainId(), o = {
      walletAddress: this.address,
      nonce: r,
      maxFee: c,
      version: i,
      chainId: s,
      cairoVersion: this.cairoVersion
    }, d = await this.signer.signTransaction(n, o, t), f = oc(n, this.cairoVersion);
    return this.invokeFunction(
      { contractAddress: this.address, calldata: f, signature: d },
      {
        nonce: r,
        maxFee: c,
        version: i
      }
    );
  }
  /**
   * First check if contract is already declared, if not declare it
   * If contract already declared returned transaction_hash is ''.
   * Method will pass even if contract is already declared
   * @param payload DeclareContractPayload
   * @param transactionsDetail (optional) InvocationsDetails = \{\}
   * @returns DeclareContractResponse
   */
  async declareIfNot(e, t = {}) {
    const a = Si(e);
    try {
      await this.getClassByHash(a.classHash);
    } catch {
      return this.declare(e, t);
    }
    return {
      transaction_hash: "",
      class_hash: a.classHash
    };
  }
  async declare(e, t = {}) {
    const a = Si(e), n = {};
    n.nonce = Z(t.nonce ?? await this.getNonce()), n.maxFee = t.maxFee ?? await this.getSuggestedMaxFee(
      {
        type: "DECLARE",
        payload: a
      },
      t
    ), n.version = jt(e.contract) ? as : Rn, n.chainId = await this.getChainId();
    const r = await this.buildDeclarePayload(a, {
      ...n,
      walletAddress: this.address,
      cairoVersion: this.cairoVersion
    });
    return this.declareContract(r, n);
  }
  async deploy(e, t) {
    const a = [].concat(e).map((i) => {
      const {
        classHash: s,
        salt: o,
        unique: d = !0,
        constructorCalldata: f = []
      } = i, l = re.compile(f), b = o ?? so();
      return {
        call: {
          contractAddress: ia.ADDRESS,
          entrypoint: ia.ENTRYPOINT,
          calldata: [
            s,
            b,
            ts(d),
            l.length,
            ...l
          ]
        },
        address: Gr(
          d ? dn(this.address, b) : b,
          s,
          l,
          d ? ia.ADDRESS : 0
        )
      };
    }), n = a.map((i) => i.call), r = a.map((i) => i.address);
    return {
      ...await this.execute(n, void 0, t),
      contract_address: r
    };
  }
  async deployContract(e, t) {
    const a = await this.deploy(e, t), n = await this.waitForTransaction(a.transaction_hash, {
      successStates: [
        "ACCEPTED_ON_L2"
        /* ACCEPTED_ON_L2 */
      ]
    });
    return N5(n);
  }
  async declareAndDeploy(e, t) {
    const { constructorCalldata: a, salt: n, unique: r } = e;
    let c = await this.declareIfNot(e, t);
    if (c.transaction_hash !== "") {
      const s = await this.waitForTransaction(c.transaction_hash, {
        successStates: [
          "ACCEPTED_ON_L2"
          /* ACCEPTED_ON_L2 */
        ]
      });
      c = { ...c, ...s };
    }
    const i = await this.deployContract(
      { classHash: c.class_hash, salt: n, unique: r, constructorCalldata: a },
      t
    );
    return { declare: { ...c }, deploy: i };
  }
  async deployAccount({
    classHash: e,
    constructorCalldata: t = [],
    addressSalt: a = 0,
    contractAddress: n
  }, r = {}) {
    const c = Z(Rn), i = Ie, s = await this.getChainId(), o = re.compile(t), d = n ?? Gr(a, e, o, 0), f = r.maxFee ?? await this.getSuggestedMaxFee(
      {
        type: "DEPLOY_ACCOUNT",
        payload: {
          classHash: e,
          constructorCalldata: o,
          addressSalt: a,
          contractAddress: d
        }
      },
      r
    ), l = await this.signer.signDeployAccountTransaction({
      classHash: e,
      constructorCalldata: o,
      contractAddress: d,
      addressSalt: a,
      chainId: s,
      maxFee: f,
      version: c,
      nonce: i
    });
    return this.deployAccountContract(
      { classHash: e, addressSalt: a, constructorCalldata: t, signature: l },
      {
        nonce: i,
        maxFee: f,
        version: c
      }
    );
  }
  async signMessage(e) {
    return this.signer.signMessage(e, this.address);
  }
  async hashMessage(e) {
    return mo(e, this.address);
  }
  async verifyMessageHash(e, t) {
    try {
      return await this.callContract({
        contractAddress: this.address,
        entrypoint: "isValidSignature",
        calldata: re.compile({
          hash: Z(e).toString(),
          signature: Nr(t)
        })
      }), !0;
    } catch {
      return !1;
    }
  }
  async verifyMessage(e, t) {
    const a = await this.hashMessage(e);
    return this.verifyMessageHash(a, t);
  }
  async getSuggestedMaxFee({ type: e, payload: t }, a) {
    let n;
    switch (e) {
      case "INVOKE_FUNCTION":
        n = await this.estimateInvokeFee(t, a);
        break;
      case "DECLARE":
        n = await this.estimateDeclareFee(t, a);
        break;
      case "DEPLOY_ACCOUNT":
        n = await this.estimateAccountDeployFee(t, a);
        break;
      case "DEPLOY":
        n = await this.estimateDeployFee(t, a);
        break;
      default:
        n = { suggestedMaxFee: Ie, overall_fee: Ie };
        break;
    }
    return n.suggestedMaxFee;
  }
  /**
   * will be renamed to buildDeclareContractTransaction
   */
  async buildDeclarePayload(e, { nonce: t, chainId: a, version: n, walletAddress: r, maxFee: c }) {
    const { classHash: i, contract: s, compiledClassHash: o } = Si(e), d = rs(s), f = await this.signer.signDeclareTransaction({
      classHash: i,
      compiledClassHash: o,
      senderAddress: r,
      chainId: a,
      maxFee: c,
      version: n,
      nonce: t
    });
    return {
      senderAddress: r,
      signature: f,
      contractDefinition: d,
      compiledClassHash: o
    };
  }
  async buildAccountDeployPayload({
    classHash: e,
    addressSalt: t = 0,
    constructorCalldata: a = [],
    contractAddress: n
  }, { nonce: r, chainId: c, version: i, maxFee: s }) {
    const o = re.compile(a), d = n ?? Gr(t, e, o, 0), f = await this.signer.signDeployAccountTransaction({
      classHash: e,
      contractAddress: d,
      chainId: c,
      maxFee: s,
      version: i,
      nonce: r,
      addressSalt: t,
      constructorCalldata: o
    });
    return {
      classHash: e,
      addressSalt: t,
      constructorCalldata: o,
      signature: f
    };
  }
  buildUDCContractPayload(e) {
    return [].concat(e).map((a) => {
      const {
        classHash: n,
        salt: r = "0",
        unique: c = !0,
        constructorCalldata: i = []
      } = a, s = re.compile(i);
      return {
        contractAddress: ia.ADDRESS,
        entrypoint: ia.ENTRYPOINT,
        calldata: [
          n,
          r,
          ts(c),
          s.length,
          ...s
        ]
      };
    });
  }
  async simulateTransaction(e, { nonce: t, blockIdentifier: a, skipValidate: n } = {}) {
    const r = Array.isArray(e) ? e : [e], c = Z(t ?? await this.getNonce()), i = Z(sa), s = await this.getChainId(), o = {
      walletAddress: this.address,
      nonce: c,
      maxFee: Ie,
      version: i,
      chainId: s,
      cairoVersion: this.cairoVersion
    }, d = await this.buildInvocation(r, o), f = await super.getSimulateTransaction(
      d,
      { version: i, nonce: c },
      a,
      n
    ), l = Da(f.fee_estimation.overall_fee);
    return {
      ...f,
      fee_estimation: {
        ...f.fee_estimation,
        suggestedMaxFee: l
      }
    };
  }
  async getStarkName(e = this.address, t) {
    return super.getStarkName(e, t);
  }
};
new uo();
class jd {
  async getPubKey() {
    throw new Error("Method not implemented");
  }
  async signMessage() {
    throw new Error("Method not implemented");
  }
  async signTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeclareTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeployAccountTransaction() {
    throw new Error("Method not implemented");
  }
}
class P5 extends R5 {
  constructor(a, n, r) {
    super(a, n, new jd());
    $r(this, "signer", new jd());
    $r(this, "execute", async (a, n, r) => {
      try {
        return {
          transaction_hash: await this.proxyLink.execute.mutate([
            a,
            n,
            r
          ])
        };
      } catch (c) {
        throw new Error(c);
      }
    });
    $r(this, "signMessage", async (a) => {
      try {
        return await this.proxyLink.signMessage.mutate([a]);
      } catch (n) {
        throw new Error(n);
      }
    });
    this.address = n, this.proxyLink = r;
  }
}
const qr = [], L5 = (e, t, a) => {
  const n = {
    ...e,
    isConnected: !1,
    provider: t,
    getLoginStatus: () => a.getLoginStatus.mutate(),
    async request(r) {
      switch (r.type) {
        case "wallet_addStarknetChain":
          return await a.addStarknetChain.mutate();
        case "wallet_switchStarknetChain":
          return await a.switchStarknetChain.mutate();
        case "wallet_watchAsset":
          return await a.watchAsset.mutate();
        default:
          throw new Error("not implemented");
      }
    },
    async enable(r) {
      if (r?.starknetVersion !== "v4")
        throw Error("not implemented");
      try {
        const c = await a.enable.mutate();
        return await $5(
          n,
          t,
          a,
          c
        ), [c];
      } catch (c) {
        throw new Error(c);
      }
    },
    async isPreauthorized() {
      const { isLoggedIn: r, isPreauthorized: c } = await a.getLoginStatus.mutate();
      return !!(r && c);
    },
    on: (r, c) => {
      if (r === "accountsChanged")
        qr.push({
          type: r,
          handler: c
        });
      else if (r === "networkChanged")
        qr.push({
          type: r,
          handler: c
        });
      else
        throw new Error(`Unknwown event: ${r}`);
    },
    off: (r, c) => {
      if (r !== "accountsChanged" && r !== "networkChanged")
        throw new Error(`Unknwown event: ${r}`);
      const i = qr.findIndex(
        (s) => s.type === r && s.handler === c
      );
      i >= 0 && qr.splice(i, 1);
    }
  };
  return n;
};
async function $5(e, t, a, n) {
  if (e.isConnected)
    return e;
  const c = {
    isConnected: !0,
    chainId: await t.getChainId(),
    selectedAddress: n,
    account: new P5(t, n, a),
    provider: t
  };
  return Object.assign(e, c);
}
var ee;
(function(e) {
  e.assertEqual = (r) => r;
  function t(r) {
  }
  e.assertIs = t;
  function a(r) {
    throw new Error();
  }
  e.assertNever = a, e.arrayToEnum = (r) => {
    const c = {};
    for (const i of r)
      c[i] = i;
    return c;
  }, e.getValidEnumValues = (r) => {
    const c = e.objectKeys(r).filter((s) => typeof r[r[s]] != "number"), i = {};
    for (const s of c)
      i[s] = r[s];
    return e.objectValues(i);
  }, e.objectValues = (r) => e.objectKeys(r).map(function(c) {
    return r[c];
  }), e.objectKeys = typeof Object.keys == "function" ? (r) => Object.keys(r) : (r) => {
    const c = [];
    for (const i in r)
      Object.prototype.hasOwnProperty.call(r, i) && c.push(i);
    return c;
  }, e.find = (r, c) => {
    for (const i of r)
      if (c(i))
        return i;
  }, e.isInteger = typeof Number.isInteger == "function" ? (r) => Number.isInteger(r) : (r) => typeof r == "number" && isFinite(r) && Math.floor(r) === r;
  function n(r, c = " | ") {
    return r.map((i) => typeof i == "string" ? `'${i}'` : i).join(c);
  }
  e.joinValues = n, e.jsonStringifyReplacer = (r, c) => typeof c == "bigint" ? c.toString() : c;
})(ee || (ee = {}));
var ss;
(function(e) {
  e.mergeShapes = (t, a) => ({
    ...t,
    ...a
    // second overwrites first
  });
})(ss || (ss = {}));
const N = ee.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), $t = (e) => {
  switch (typeof e) {
    case "undefined":
      return N.undefined;
    case "string":
      return N.string;
    case "number":
      return isNaN(e) ? N.nan : N.number;
    case "boolean":
      return N.boolean;
    case "function":
      return N.function;
    case "bigint":
      return N.bigint;
    case "symbol":
      return N.symbol;
    case "object":
      return Array.isArray(e) ? N.array : e === null ? N.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? N.promise : typeof Map < "u" && e instanceof Map ? N.map : typeof Set < "u" && e instanceof Set ? N.set : typeof Date < "u" && e instanceof Date ? N.date : N.object;
    default:
      return N.unknown;
  }
}, k = ee.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), D5 = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class qe extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const a = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, a) : this.__proto__ = a, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const a = t || function(c) {
      return c.message;
    }, n = { _errors: [] }, r = (c) => {
      for (const i of c.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(r);
        else if (i.code === "invalid_return_type")
          r(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          r(i.argumentsError);
        else if (i.path.length === 0)
          n._errors.push(a(i));
        else {
          let s = n, o = 0;
          for (; o < i.path.length; ) {
            const d = i.path[o];
            o === i.path.length - 1 ? (s[d] = s[d] || { _errors: [] }, s[d]._errors.push(a(i))) : s[d] = s[d] || { _errors: [] }, s = s[d], o++;
          }
        }
    };
    return r(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, ee.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (a) => a.message) {
    const a = {}, n = [];
    for (const r of this.issues)
      r.path.length > 0 ? (a[r.path[0]] = a[r.path[0]] || [], a[r.path[0]].push(t(r))) : n.push(t(r));
    return { formErrors: n, fieldErrors: a };
  }
  get formErrors() {
    return this.flatten();
  }
}
qe.create = (e) => new qe(e);
const Yn = (e, t) => {
  let a;
  switch (e.code) {
    case k.invalid_type:
      e.received === N.undefined ? a = "Required" : a = `Expected ${e.expected}, received ${e.received}`;
      break;
    case k.invalid_literal:
      a = `Invalid literal value, expected ${JSON.stringify(e.expected, ee.jsonStringifyReplacer)}`;
      break;
    case k.unrecognized_keys:
      a = `Unrecognized key(s) in object: ${ee.joinValues(e.keys, ", ")}`;
      break;
    case k.invalid_union:
      a = "Invalid input";
      break;
    case k.invalid_union_discriminator:
      a = `Invalid discriminator value. Expected ${ee.joinValues(e.options)}`;
      break;
    case k.invalid_enum_value:
      a = `Invalid enum value. Expected ${ee.joinValues(e.options)}, received '${e.received}'`;
      break;
    case k.invalid_arguments:
      a = "Invalid function arguments";
      break;
    case k.invalid_return_type:
      a = "Invalid function return type";
      break;
    case k.invalid_date:
      a = "Invalid date";
      break;
    case k.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (a = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (a = `${a} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? a = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? a = `Invalid input: must end with "${e.validation.endsWith}"` : ee.assertNever(e.validation) : e.validation !== "regex" ? a = `Invalid ${e.validation}` : a = "Invalid";
      break;
    case k.too_small:
      e.type === "array" ? a = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? a = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? a = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? a = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : a = "Invalid input";
      break;
    case k.too_big:
      e.type === "array" ? a = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? a = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? a = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? a = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? a = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : a = "Invalid input";
      break;
    case k.custom:
      a = "Invalid input";
      break;
    case k.invalid_intersection_types:
      a = "Intersection results could not be merged";
      break;
    case k.not_multiple_of:
      a = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case k.not_finite:
      a = "Number must be finite";
      break;
    default:
      a = t.defaultError, ee.assertNever(e);
  }
  return { message: a };
};
let Zu = Yn;
function B5(e) {
  Zu = e;
}
function dc() {
  return Zu;
}
const fc = (e) => {
  const { data: t, path: a, errorMaps: n, issueData: r } = e, c = [...a, ...r.path || []], i = {
    ...r,
    path: c
  };
  let s = "";
  const o = n.filter((d) => !!d).slice().reverse();
  for (const d of o)
    s = d(i, { data: t, defaultError: s }).message;
  return {
    ...r,
    path: c,
    message: r.message || s
  };
}, Z5 = [];
function L(e, t) {
  const a = fc({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      dc(),
      Yn
      // then global default map
    ].filter((n) => !!n)
  });
  e.common.issues.push(a);
}
class ve {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, a) {
    const n = [];
    for (const r of a) {
      if (r.status === "aborted")
        return q;
      r.status === "dirty" && t.dirty(), n.push(r.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, a) {
    const n = [];
    for (const r of a)
      n.push({
        key: await r.key,
        value: await r.value
      });
    return ve.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, a) {
    const n = {};
    for (const r of a) {
      const { key: c, value: i } = r;
      if (c.status === "aborted" || i.status === "aborted")
        return q;
      c.status === "dirty" && t.dirty(), i.status === "dirty" && t.dirty(), (typeof i.value < "u" || r.alwaysSet) && (n[c.value] = i.value);
    }
    return { status: t.value, value: n };
  }
}
const q = Object.freeze({
  status: "aborted"
}), ju = (e) => ({ status: "dirty", value: e }), Se = (e) => ({ status: "valid", value: e }), os = (e) => e.status === "aborted", ds = (e) => e.status === "dirty", lc = (e) => e.status === "valid", uc = (e) => typeof Promise < "u" && e instanceof Promise;
var U;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
})(U || (U = {}));
class dt {
  constructor(t, a, n, r) {
    this._cachedPath = [], this.parent = t, this.data = a, this._path = n, this._key = r;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Ud = (e, t) => {
  if (lc(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const a = new qe(e.common.issues);
      return this._error = a, this._error;
    }
  };
};
function W(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: a, required_error: n, description: r } = e;
  if (t && (a || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: r } : { errorMap: (c, i) => c.code !== "invalid_type" ? { message: i.defaultError } : typeof i.data > "u" ? { message: n ?? i.defaultError } : { message: a ?? i.defaultError }, description: r };
}
class G {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return $t(t.data);
  }
  _getOrReturnCtx(t, a) {
    return a || {
      common: t.parent.common,
      data: t.data,
      parsedType: $t(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new ve(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: $t(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const a = this._parse(t);
    if (uc(a))
      throw new Error("Synchronous parse encountered promise.");
    return a;
  }
  _parseAsync(t) {
    const a = this._parse(t);
    return Promise.resolve(a);
  }
  parse(t, a) {
    const n = this.safeParse(t, a);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, a) {
    var n;
    const r = {
      common: {
        issues: [],
        async: (n = a?.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: a?.errorMap
      },
      path: a?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: $t(t)
    }, c = this._parseSync({ data: t, path: r.path, parent: r });
    return Ud(r, c);
  }
  async parseAsync(t, a) {
    const n = await this.safeParseAsync(t, a);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, a) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: a?.errorMap,
        async: !0
      },
      path: a?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: $t(t)
    }, r = this._parse({ data: t, path: n.path, parent: n }), c = await (uc(r) ? r : Promise.resolve(r));
    return Ud(n, c);
  }
  refine(t, a) {
    const n = (r) => typeof a == "string" || typeof a > "u" ? { message: a } : typeof a == "function" ? a(r) : a;
    return this._refinement((r, c) => {
      const i = t(r), s = () => c.addIssue({
        code: k.custom,
        ...n(r)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((o) => o ? !0 : (s(), !1)) : i ? !0 : (s(), !1);
    });
  }
  refinement(t, a) {
    return this._refinement((n, r) => t(n) ? !0 : (r.addIssue(typeof a == "function" ? a(n, r) : a), !1));
  }
  _refinement(t) {
    return new Ye({
      schema: this,
      typeName: H.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Et.create(this, this._def);
  }
  nullable() {
    return Ea.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return We.create(this, this._def);
  }
  promise() {
    return nn.create(this, this._def);
  }
  or(t) {
    return er.create([this, t], this._def);
  }
  and(t) {
    return tr.create(this, t, this._def);
  }
  transform(t) {
    return new Ye({
      ...W(this._def),
      schema: this,
      typeName: H.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const a = typeof t == "function" ? t : () => t;
    return new ir({
      ...W(this._def),
      innerType: this,
      defaultValue: a,
      typeName: H.ZodDefault
    });
  }
  brand() {
    return new Mu({
      typeName: H.ZodBranded,
      type: this,
      ...W(this._def)
    });
  }
  catch(t) {
    const a = typeof t == "function" ? t : () => t;
    return new mc({
      ...W(this._def),
      innerType: this,
      catchValue: a,
      typeName: H.ZodCatch
    });
  }
  describe(t) {
    const a = this.constructor;
    return new a({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Rr.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const j5 = /^c[^\s-]{8,}$/i, U5 = /^[a-z][a-z0-9]*$/, M5 = /[0-9A-HJKMNP-TV-Z]{26}/, H5 = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, z5 = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, F5 = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, V5 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, q5 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, W5 = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function K5(e, t) {
  return !!((t === "v4" || !t) && V5.test(e) || (t === "v6" || !t) && q5.test(e));
}
class Fe extends G {
  constructor() {
    super(...arguments), this._regex = (t, a, n) => this.refinement((r) => t.test(r), {
      validation: a,
      code: k.invalid_string,
      ...U.errToObj(n)
    }), this.nonempty = (t) => this.min(1, U.errToObj(t)), this.trim = () => new Fe({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new Fe({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new Fe({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== N.string) {
      const r = this._getOrReturnCtx(t);
      return L(
        r,
        {
          code: k.invalid_type,
          expected: N.string,
          received: r.parsedType
        }
        //
      ), q;
    }
    const a = new ve();
    let n;
    for (const r of this._def.checks)
      if (r.kind === "min")
        t.data.length < r.value && (n = this._getOrReturnCtx(t, n), L(n, {
          code: k.too_small,
          minimum: r.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: r.message
        }), a.dirty());
      else if (r.kind === "max")
        t.data.length > r.value && (n = this._getOrReturnCtx(t, n), L(n, {
          code: k.too_big,
          maximum: r.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: r.message
        }), a.dirty());
      else if (r.kind === "length") {
        const c = t.data.length > r.value, i = t.data.length < r.value;
        (c || i) && (n = this._getOrReturnCtx(t, n), c ? L(n, {
          code: k.too_big,
          maximum: r.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: r.message
        }) : i && L(n, {
          code: k.too_small,
          minimum: r.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: r.message
        }), a.dirty());
      } else if (r.kind === "email")
        z5.test(t.data) || (n = this._getOrReturnCtx(t, n), L(n, {
          validation: "email",
          code: k.invalid_string,
          message: r.message
        }), a.dirty());
      else if (r.kind === "emoji")
        F5.test(t.data) || (n = this._getOrReturnCtx(t, n), L(n, {
          validation: "emoji",
          code: k.invalid_string,
          message: r.message
        }), a.dirty());
      else if (r.kind === "uuid")
        H5.test(t.data) || (n = this._getOrReturnCtx(t, n), L(n, {
          validation: "uuid",
          code: k.invalid_string,
          message: r.message
        }), a.dirty());
      else if (r.kind === "cuid")
        j5.test(t.data) || (n = this._getOrReturnCtx(t, n), L(n, {
          validation: "cuid",
          code: k.invalid_string,
          message: r.message
        }), a.dirty());
      else if (r.kind === "cuid2")
        U5.test(t.data) || (n = this._getOrReturnCtx(t, n), L(n, {
          validation: "cuid2",
          code: k.invalid_string,
          message: r.message
        }), a.dirty());
      else if (r.kind === "ulid")
        M5.test(t.data) || (n = this._getOrReturnCtx(t, n), L(n, {
          validation: "ulid",
          code: k.invalid_string,
          message: r.message
        }), a.dirty());
      else if (r.kind === "url")
        try {
          new URL(t.data);
        } catch {
          n = this._getOrReturnCtx(t, n), L(n, {
            validation: "url",
            code: k.invalid_string,
            message: r.message
          }), a.dirty();
        }
      else
        r.kind === "regex" ? (r.regex.lastIndex = 0, r.regex.test(t.data) || (n = this._getOrReturnCtx(t, n), L(n, {
          validation: "regex",
          code: k.invalid_string,
          message: r.message
        }), a.dirty())) : r.kind === "trim" ? t.data = t.data.trim() : r.kind === "includes" ? t.data.includes(r.value, r.position) || (n = this._getOrReturnCtx(t, n), L(n, {
          code: k.invalid_string,
          validation: { includes: r.value, position: r.position },
          message: r.message
        }), a.dirty()) : r.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : r.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : r.kind === "startsWith" ? t.data.startsWith(r.value) || (n = this._getOrReturnCtx(t, n), L(n, {
          code: k.invalid_string,
          validation: { startsWith: r.value },
          message: r.message
        }), a.dirty()) : r.kind === "endsWith" ? t.data.endsWith(r.value) || (n = this._getOrReturnCtx(t, n), L(n, {
          code: k.invalid_string,
          validation: { endsWith: r.value },
          message: r.message
        }), a.dirty()) : r.kind === "datetime" ? W5(r).test(t.data) || (n = this._getOrReturnCtx(t, n), L(n, {
          code: k.invalid_string,
          validation: "datetime",
          message: r.message
        }), a.dirty()) : r.kind === "ip" ? K5(t.data, r.version) || (n = this._getOrReturnCtx(t, n), L(n, {
          validation: "ip",
          code: k.invalid_string,
          message: r.message
        }), a.dirty()) : ee.assertNever(r);
    return { status: a.value, value: t.data };
  }
  _addCheck(t) {
    return new Fe({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...U.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...U.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...U.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...U.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...U.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...U.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...U.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...U.errToObj(t) });
  }
  datetime(t) {
    var a;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof t?.precision > "u" ? null : t?.precision,
      offset: (a = t?.offset) !== null && a !== void 0 ? a : !1,
      ...U.errToObj(t?.message)
    });
  }
  regex(t, a) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...U.errToObj(a)
    });
  }
  includes(t, a) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: a?.position,
      ...U.errToObj(a?.message)
    });
  }
  startsWith(t, a) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...U.errToObj(a)
    });
  }
  endsWith(t, a) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...U.errToObj(a)
    });
  }
  min(t, a) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...U.errToObj(a)
    });
  }
  max(t, a) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...U.errToObj(a)
    });
  }
  length(t, a) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...U.errToObj(a)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
}
Fe.create = (e) => {
  var t;
  return new Fe({
    checks: [],
    typeName: H.ZodString,
    coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
    ...W(e)
  });
};
function G5(e, t) {
  const a = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, r = a > n ? a : n, c = parseInt(e.toFixed(r).replace(".", "")), i = parseInt(t.toFixed(r).replace(".", ""));
  return c % i / Math.pow(10, r);
}
class Wt extends G {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== N.number) {
      const r = this._getOrReturnCtx(t);
      return L(r, {
        code: k.invalid_type,
        expected: N.number,
        received: r.parsedType
      }), q;
    }
    let a;
    const n = new ve();
    for (const r of this._def.checks)
      r.kind === "int" ? ee.isInteger(t.data) || (a = this._getOrReturnCtx(t, a), L(a, {
        code: k.invalid_type,
        expected: "integer",
        received: "float",
        message: r.message
      }), n.dirty()) : r.kind === "min" ? (r.inclusive ? t.data < r.value : t.data <= r.value) && (a = this._getOrReturnCtx(t, a), L(a, {
        code: k.too_small,
        minimum: r.value,
        type: "number",
        inclusive: r.inclusive,
        exact: !1,
        message: r.message
      }), n.dirty()) : r.kind === "max" ? (r.inclusive ? t.data > r.value : t.data >= r.value) && (a = this._getOrReturnCtx(t, a), L(a, {
        code: k.too_big,
        maximum: r.value,
        type: "number",
        inclusive: r.inclusive,
        exact: !1,
        message: r.message
      }), n.dirty()) : r.kind === "multipleOf" ? G5(t.data, r.value) !== 0 && (a = this._getOrReturnCtx(t, a), L(a, {
        code: k.not_multiple_of,
        multipleOf: r.value,
        message: r.message
      }), n.dirty()) : r.kind === "finite" ? Number.isFinite(t.data) || (a = this._getOrReturnCtx(t, a), L(a, {
        code: k.not_finite,
        message: r.message
      }), n.dirty()) : ee.assertNever(r);
    return { status: n.value, value: t.data };
  }
  gte(t, a) {
    return this.setLimit("min", t, !0, U.toString(a));
  }
  gt(t, a) {
    return this.setLimit("min", t, !1, U.toString(a));
  }
  lte(t, a) {
    return this.setLimit("max", t, !0, U.toString(a));
  }
  lt(t, a) {
    return this.setLimit("max", t, !1, U.toString(a));
  }
  setLimit(t, a, n, r) {
    return new Wt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: a,
          inclusive: n,
          message: U.toString(r)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Wt({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: U.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: U.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: U.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: U.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: U.toString(t)
    });
  }
  multipleOf(t, a) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: U.toString(a)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: U.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: U.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: U.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && ee.isInteger(t.value));
  }
  get isFinite() {
    let t = null, a = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (a === null || n.value > a) && (a = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(a) && Number.isFinite(t);
  }
}
Wt.create = (e) => new Wt({
  checks: [],
  typeName: H.ZodNumber,
  coerce: e?.coerce || !1,
  ...W(e)
});
class Kt extends G {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== N.bigint) {
      const r = this._getOrReturnCtx(t);
      return L(r, {
        code: k.invalid_type,
        expected: N.bigint,
        received: r.parsedType
      }), q;
    }
    let a;
    const n = new ve();
    for (const r of this._def.checks)
      r.kind === "min" ? (r.inclusive ? t.data < r.value : t.data <= r.value) && (a = this._getOrReturnCtx(t, a), L(a, {
        code: k.too_small,
        type: "bigint",
        minimum: r.value,
        inclusive: r.inclusive,
        message: r.message
      }), n.dirty()) : r.kind === "max" ? (r.inclusive ? t.data > r.value : t.data >= r.value) && (a = this._getOrReturnCtx(t, a), L(a, {
        code: k.too_big,
        type: "bigint",
        maximum: r.value,
        inclusive: r.inclusive,
        message: r.message
      }), n.dirty()) : r.kind === "multipleOf" ? t.data % r.value !== BigInt(0) && (a = this._getOrReturnCtx(t, a), L(a, {
        code: k.not_multiple_of,
        multipleOf: r.value,
        message: r.message
      }), n.dirty()) : ee.assertNever(r);
    return { status: n.value, value: t.data };
  }
  gte(t, a) {
    return this.setLimit("min", t, !0, U.toString(a));
  }
  gt(t, a) {
    return this.setLimit("min", t, !1, U.toString(a));
  }
  lte(t, a) {
    return this.setLimit("max", t, !0, U.toString(a));
  }
  lt(t, a) {
    return this.setLimit("max", t, !1, U.toString(a));
  }
  setLimit(t, a, n, r) {
    return new Kt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: a,
          inclusive: n,
          message: U.toString(r)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Kt({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: U.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: U.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: U.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: U.toString(t)
    });
  }
  multipleOf(t, a) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: U.toString(a)
    });
  }
  get minValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
}
Kt.create = (e) => {
  var t;
  return new Kt({
    checks: [],
    typeName: H.ZodBigInt,
    coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
    ...W(e)
  });
};
class Xn extends G {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== N.boolean) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: k.invalid_type,
        expected: N.boolean,
        received: a.parsedType
      }), q;
    }
    return Se(t.data);
  }
}
Xn.create = (e) => new Xn({
  typeName: H.ZodBoolean,
  coerce: e?.coerce || !1,
  ...W(e)
});
class va extends G {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== N.date) {
      const r = this._getOrReturnCtx(t);
      return L(r, {
        code: k.invalid_type,
        expected: N.date,
        received: r.parsedType
      }), q;
    }
    if (isNaN(t.data.getTime())) {
      const r = this._getOrReturnCtx(t);
      return L(r, {
        code: k.invalid_date
      }), q;
    }
    const a = new ve();
    let n;
    for (const r of this._def.checks)
      r.kind === "min" ? t.data.getTime() < r.value && (n = this._getOrReturnCtx(t, n), L(n, {
        code: k.too_small,
        message: r.message,
        inclusive: !0,
        exact: !1,
        minimum: r.value,
        type: "date"
      }), a.dirty()) : r.kind === "max" ? t.data.getTime() > r.value && (n = this._getOrReturnCtx(t, n), L(n, {
        code: k.too_big,
        message: r.message,
        inclusive: !0,
        exact: !1,
        maximum: r.value,
        type: "date"
      }), a.dirty()) : ee.assertNever(r);
    return {
      status: a.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new va({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, a) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: U.toString(a)
    });
  }
  max(t, a) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: U.toString(a)
    });
  }
  get minDate() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t != null ? new Date(t) : null;
  }
}
va.create = (e) => new va({
  checks: [],
  coerce: e?.coerce || !1,
  typeName: H.ZodDate,
  ...W(e)
});
class bc extends G {
  _parse(t) {
    if (this._getType(t) !== N.symbol) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: k.invalid_type,
        expected: N.symbol,
        received: a.parsedType
      }), q;
    }
    return Se(t.data);
  }
}
bc.create = (e) => new bc({
  typeName: H.ZodSymbol,
  ...W(e)
});
class Jn extends G {
  _parse(t) {
    if (this._getType(t) !== N.undefined) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: k.invalid_type,
        expected: N.undefined,
        received: a.parsedType
      }), q;
    }
    return Se(t.data);
  }
}
Jn.create = (e) => new Jn({
  typeName: H.ZodUndefined,
  ...W(e)
});
class Qn extends G {
  _parse(t) {
    if (this._getType(t) !== N.null) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: k.invalid_type,
        expected: N.null,
        received: a.parsedType
      }), q;
    }
    return Se(t.data);
  }
}
Qn.create = (e) => new Qn({
  typeName: H.ZodNull,
  ...W(e)
});
class an extends G {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Se(t.data);
  }
}
an.create = (e) => new an({
  typeName: H.ZodAny,
  ...W(e)
});
class ua extends G {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Se(t.data);
  }
}
ua.create = (e) => new ua({
  typeName: H.ZodUnknown,
  ...W(e)
});
class St extends G {
  _parse(t) {
    const a = this._getOrReturnCtx(t);
    return L(a, {
      code: k.invalid_type,
      expected: N.never,
      received: a.parsedType
    }), q;
  }
}
St.create = (e) => new St({
  typeName: H.ZodNever,
  ...W(e)
});
class hc extends G {
  _parse(t) {
    if (this._getType(t) !== N.undefined) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: k.invalid_type,
        expected: N.void,
        received: a.parsedType
      }), q;
    }
    return Se(t.data);
  }
}
hc.create = (e) => new hc({
  typeName: H.ZodVoid,
  ...W(e)
});
class We extends G {
  _parse(t) {
    const { ctx: a, status: n } = this._processInputParams(t), r = this._def;
    if (a.parsedType !== N.array)
      return L(a, {
        code: k.invalid_type,
        expected: N.array,
        received: a.parsedType
      }), q;
    if (r.exactLength !== null) {
      const i = a.data.length > r.exactLength.value, s = a.data.length < r.exactLength.value;
      (i || s) && (L(a, {
        code: i ? k.too_big : k.too_small,
        minimum: s ? r.exactLength.value : void 0,
        maximum: i ? r.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: r.exactLength.message
      }), n.dirty());
    }
    if (r.minLength !== null && a.data.length < r.minLength.value && (L(a, {
      code: k.too_small,
      minimum: r.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: r.minLength.message
    }), n.dirty()), r.maxLength !== null && a.data.length > r.maxLength.value && (L(a, {
      code: k.too_big,
      maximum: r.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: r.maxLength.message
    }), n.dirty()), a.common.async)
      return Promise.all([...a.data].map((i, s) => r.type._parseAsync(new dt(a, i, a.path, s)))).then((i) => ve.mergeArray(n, i));
    const c = [...a.data].map((i, s) => r.type._parseSync(new dt(a, i, a.path, s)));
    return ve.mergeArray(n, c);
  }
  get element() {
    return this._def.type;
  }
  min(t, a) {
    return new We({
      ...this._def,
      minLength: { value: t, message: U.toString(a) }
    });
  }
  max(t, a) {
    return new We({
      ...this._def,
      maxLength: { value: t, message: U.toString(a) }
    });
  }
  length(t, a) {
    return new We({
      ...this._def,
      exactLength: { value: t, message: U.toString(a) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
We.create = (e, t) => new We({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: H.ZodArray,
  ...W(t)
});
function Ba(e) {
  if (e instanceof se) {
    const t = {};
    for (const a in e.shape) {
      const n = e.shape[a];
      t[a] = Et.create(Ba(n));
    }
    return new se({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof We ? new We({
      ...e._def,
      type: Ba(e.element)
    }) : e instanceof Et ? Et.create(Ba(e.unwrap())) : e instanceof Ea ? Ea.create(Ba(e.unwrap())) : e instanceof ft ? ft.create(e.items.map((t) => Ba(t))) : e;
}
class se extends G {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), a = ee.objectKeys(t);
    return this._cached = { shape: t, keys: a };
  }
  _parse(t) {
    if (this._getType(t) !== N.object) {
      const o = this._getOrReturnCtx(t);
      return L(o, {
        code: k.invalid_type,
        expected: N.object,
        received: o.parsedType
      }), q;
    }
    const { status: a, ctx: n } = this._processInputParams(t), { shape: r, keys: c } = this._getCached(), i = [];
    if (!(this._def.catchall instanceof St && this._def.unknownKeys === "strip"))
      for (const o in n.data)
        c.includes(o) || i.push(o);
    const s = [];
    for (const o of c) {
      const d = r[o], f = n.data[o];
      s.push({
        key: { status: "valid", value: o },
        value: d._parse(new dt(n, f, n.path, o)),
        alwaysSet: o in n.data
      });
    }
    if (this._def.catchall instanceof St) {
      const o = this._def.unknownKeys;
      if (o === "passthrough")
        for (const d of i)
          s.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: n.data[d] }
          });
      else if (o === "strict")
        i.length > 0 && (L(n, {
          code: k.unrecognized_keys,
          keys: i
        }), a.dirty());
      else if (o !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const o = this._def.catchall;
      for (const d of i) {
        const f = n.data[d];
        s.push({
          key: { status: "valid", value: d },
          value: o._parse(
            new dt(n, f, n.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in n.data
        });
      }
    }
    return n.common.async ? Promise.resolve().then(async () => {
      const o = [];
      for (const d of s) {
        const f = await d.key;
        o.push({
          key: f,
          value: await d.value,
          alwaysSet: d.alwaysSet
        });
      }
      return o;
    }).then((o) => ve.mergeObjectSync(a, o)) : ve.mergeObjectSync(a, s);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return U.errToObj, new se({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (a, n) => {
          var r, c, i, s;
          const o = (i = (c = (r = this._def).errorMap) === null || c === void 0 ? void 0 : c.call(r, a, n).message) !== null && i !== void 0 ? i : n.defaultError;
          return a.code === "unrecognized_keys" ? {
            message: (s = U.errToObj(t).message) !== null && s !== void 0 ? s : o
          } : {
            message: o
          };
        }
      } : {}
    });
  }
  strip() {
    return new se({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new se({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new se({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new se({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: H.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, a) {
    return this.augment({ [t]: a });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new se({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const a = {};
    return ee.objectKeys(t).forEach((n) => {
      t[n] && this.shape[n] && (a[n] = this.shape[n]);
    }), new se({
      ...this._def,
      shape: () => a
    });
  }
  omit(t) {
    const a = {};
    return ee.objectKeys(this.shape).forEach((n) => {
      t[n] || (a[n] = this.shape[n]);
    }), new se({
      ...this._def,
      shape: () => a
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ba(this);
  }
  partial(t) {
    const a = {};
    return ee.objectKeys(this.shape).forEach((n) => {
      const r = this.shape[n];
      t && !t[n] ? a[n] = r : a[n] = r.optional();
    }), new se({
      ...this._def,
      shape: () => a
    });
  }
  required(t) {
    const a = {};
    return ee.objectKeys(this.shape).forEach((n) => {
      if (t && !t[n])
        a[n] = this.shape[n];
      else {
        let r = this.shape[n];
        for (; r instanceof Et; )
          r = r._def.innerType;
        a[n] = r;
      }
    }), new se({
      ...this._def,
      shape: () => a
    });
  }
  keyof() {
    return Uu(ee.objectKeys(this.shape));
  }
}
se.create = (e, t) => new se({
  shape: () => e,
  unknownKeys: "strip",
  catchall: St.create(),
  typeName: H.ZodObject,
  ...W(t)
});
se.strictCreate = (e, t) => new se({
  shape: () => e,
  unknownKeys: "strict",
  catchall: St.create(),
  typeName: H.ZodObject,
  ...W(t)
});
se.lazycreate = (e, t) => new se({
  shape: e,
  unknownKeys: "strip",
  catchall: St.create(),
  typeName: H.ZodObject,
  ...W(t)
});
class er extends G {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), n = this._def.options;
    function r(c) {
      for (const s of c)
        if (s.result.status === "valid")
          return s.result;
      for (const s of c)
        if (s.result.status === "dirty")
          return a.common.issues.push(...s.ctx.common.issues), s.result;
      const i = c.map((s) => new qe(s.ctx.common.issues));
      return L(a, {
        code: k.invalid_union,
        unionErrors: i
      }), q;
    }
    if (a.common.async)
      return Promise.all(n.map(async (c) => {
        const i = {
          ...a,
          common: {
            ...a.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await c._parseAsync({
            data: a.data,
            path: a.path,
            parent: i
          }),
          ctx: i
        };
      })).then(r);
    {
      let c;
      const i = [];
      for (const o of n) {
        const d = {
          ...a,
          common: {
            ...a.common,
            issues: []
          },
          parent: null
        }, f = o._parseSync({
          data: a.data,
          path: a.path,
          parent: d
        });
        if (f.status === "valid")
          return f;
        f.status === "dirty" && !c && (c = { result: f, ctx: d }), d.common.issues.length && i.push(d.common.issues);
      }
      if (c)
        return a.common.issues.push(...c.ctx.common.issues), c.result;
      const s = i.map((o) => new qe(o));
      return L(a, {
        code: k.invalid_union,
        unionErrors: s
      }), q;
    }
  }
  get options() {
    return this._def.options;
  }
}
er.create = (e, t) => new er({
  options: e,
  typeName: H.ZodUnion,
  ...W(t)
});
const Yr = (e) => e instanceof nr ? Yr(e.schema) : e instanceof Ye ? Yr(e.innerType()) : e instanceof rr ? [e.value] : e instanceof Gt ? e.options : e instanceof cr ? Object.keys(e.enum) : e instanceof ir ? Yr(e._def.innerType) : e instanceof Jn ? [void 0] : e instanceof Qn ? [null] : null;
class zc extends G {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== N.object)
      return L(a, {
        code: k.invalid_type,
        expected: N.object,
        received: a.parsedType
      }), q;
    const n = this.discriminator, r = a.data[n], c = this.optionsMap.get(r);
    return c ? a.common.async ? c._parseAsync({
      data: a.data,
      path: a.path,
      parent: a
    }) : c._parseSync({
      data: a.data,
      path: a.path,
      parent: a
    }) : (L(a, {
      code: k.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), q);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, a, n) {
    const r = /* @__PURE__ */ new Map();
    for (const c of a) {
      const i = Yr(c.shape[t]);
      if (!i)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of i) {
        if (r.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        r.set(s, c);
      }
    }
    return new zc({
      typeName: H.ZodDiscriminatedUnion,
      discriminator: t,
      options: a,
      optionsMap: r,
      ...W(n)
    });
  }
}
function fs(e, t) {
  const a = $t(e), n = $t(t);
  if (e === t)
    return { valid: !0, data: e };
  if (a === N.object && n === N.object) {
    const r = ee.objectKeys(t), c = ee.objectKeys(e).filter((s) => r.indexOf(s) !== -1), i = { ...e, ...t };
    for (const s of c) {
      const o = fs(e[s], t[s]);
      if (!o.valid)
        return { valid: !1 };
      i[s] = o.data;
    }
    return { valid: !0, data: i };
  } else if (a === N.array && n === N.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const r = [];
    for (let c = 0; c < e.length; c++) {
      const i = e[c], s = t[c], o = fs(i, s);
      if (!o.valid)
        return { valid: !1 };
      r.push(o.data);
    }
    return { valid: !0, data: r };
  } else
    return a === N.date && n === N.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class tr extends G {
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t), r = (c, i) => {
      if (os(c) || os(i))
        return q;
      const s = fs(c.value, i.value);
      return s.valid ? ((ds(c) || ds(i)) && a.dirty(), { status: a.value, value: s.data }) : (L(n, {
        code: k.invalid_intersection_types
      }), q);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([c, i]) => r(c, i)) : r(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
tr.create = (e, t, a) => new tr({
  left: e,
  right: t,
  typeName: H.ZodIntersection,
  ...W(a)
});
class ft extends G {
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== N.array)
      return L(n, {
        code: k.invalid_type,
        expected: N.array,
        received: n.parsedType
      }), q;
    if (n.data.length < this._def.items.length)
      return L(n, {
        code: k.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), q;
    !this._def.rest && n.data.length > this._def.items.length && (L(n, {
      code: k.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), a.dirty());
    const r = [...n.data].map((c, i) => {
      const s = this._def.items[i] || this._def.rest;
      return s ? s._parse(new dt(n, c, n.path, i)) : null;
    }).filter((c) => !!c);
    return n.common.async ? Promise.all(r).then((c) => ve.mergeArray(a, c)) : ve.mergeArray(a, r);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new ft({
      ...this._def,
      rest: t
    });
  }
}
ft.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ft({
    items: e,
    typeName: H.ZodTuple,
    rest: null,
    ...W(t)
  });
};
class ar extends G {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== N.object)
      return L(n, {
        code: k.invalid_type,
        expected: N.object,
        received: n.parsedType
      }), q;
    const r = [], c = this._def.keyType, i = this._def.valueType;
    for (const s in n.data)
      r.push({
        key: c._parse(new dt(n, s, n.path, s)),
        value: i._parse(new dt(n, n.data[s], n.path, s))
      });
    return n.common.async ? ve.mergeObjectAsync(a, r) : ve.mergeObjectSync(a, r);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, a, n) {
    return a instanceof G ? new ar({
      keyType: t,
      valueType: a,
      typeName: H.ZodRecord,
      ...W(n)
    }) : new ar({
      keyType: Fe.create(),
      valueType: t,
      typeName: H.ZodRecord,
      ...W(a)
    });
  }
}
class pc extends G {
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== N.map)
      return L(n, {
        code: k.invalid_type,
        expected: N.map,
        received: n.parsedType
      }), q;
    const r = this._def.keyType, c = this._def.valueType, i = [...n.data.entries()].map(([s, o], d) => ({
      key: r._parse(new dt(n, s, n.path, [d, "key"])),
      value: c._parse(new dt(n, o, n.path, [d, "value"]))
    }));
    if (n.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const o of i) {
          const d = await o.key, f = await o.value;
          if (d.status === "aborted" || f.status === "aborted")
            return q;
          (d.status === "dirty" || f.status === "dirty") && a.dirty(), s.set(d.value, f.value);
        }
        return { status: a.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const o of i) {
        const d = o.key, f = o.value;
        if (d.status === "aborted" || f.status === "aborted")
          return q;
        (d.status === "dirty" || f.status === "dirty") && a.dirty(), s.set(d.value, f.value);
      }
      return { status: a.value, value: s };
    }
  }
}
pc.create = (e, t, a) => new pc({
  valueType: t,
  keyType: e,
  typeName: H.ZodMap,
  ...W(a)
});
class xa extends G {
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== N.set)
      return L(n, {
        code: k.invalid_type,
        expected: N.set,
        received: n.parsedType
      }), q;
    const r = this._def;
    r.minSize !== null && n.data.size < r.minSize.value && (L(n, {
      code: k.too_small,
      minimum: r.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: r.minSize.message
    }), a.dirty()), r.maxSize !== null && n.data.size > r.maxSize.value && (L(n, {
      code: k.too_big,
      maximum: r.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: r.maxSize.message
    }), a.dirty());
    const c = this._def.valueType;
    function i(o) {
      const d = /* @__PURE__ */ new Set();
      for (const f of o) {
        if (f.status === "aborted")
          return q;
        f.status === "dirty" && a.dirty(), d.add(f.value);
      }
      return { status: a.value, value: d };
    }
    const s = [...n.data.values()].map((o, d) => c._parse(new dt(n, o, n.path, d)));
    return n.common.async ? Promise.all(s).then((o) => i(o)) : i(s);
  }
  min(t, a) {
    return new xa({
      ...this._def,
      minSize: { value: t, message: U.toString(a) }
    });
  }
  max(t, a) {
    return new xa({
      ...this._def,
      maxSize: { value: t, message: U.toString(a) }
    });
  }
  size(t, a) {
    return this.min(t, a).max(t, a);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
xa.create = (e, t) => new xa({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: H.ZodSet,
  ...W(t)
});
class Wa extends G {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== N.function)
      return L(a, {
        code: k.invalid_type,
        expected: N.function,
        received: a.parsedType
      }), q;
    function n(s, o) {
      return fc({
        data: s,
        path: a.path,
        errorMaps: [
          a.common.contextualErrorMap,
          a.schemaErrorMap,
          dc(),
          Yn
        ].filter((d) => !!d),
        issueData: {
          code: k.invalid_arguments,
          argumentsError: o
        }
      });
    }
    function r(s, o) {
      return fc({
        data: s,
        path: a.path,
        errorMaps: [
          a.common.contextualErrorMap,
          a.schemaErrorMap,
          dc(),
          Yn
        ].filter((d) => !!d),
        issueData: {
          code: k.invalid_return_type,
          returnTypeError: o
        }
      });
    }
    const c = { errorMap: a.common.contextualErrorMap }, i = a.data;
    return this._def.returns instanceof nn ? Se(async (...s) => {
      const o = new qe([]), d = await this._def.args.parseAsync(s, c).catch((l) => {
        throw o.addIssue(n(s, l)), o;
      }), f = await i(...d);
      return await this._def.returns._def.type.parseAsync(f, c).catch((l) => {
        throw o.addIssue(r(f, l)), o;
      });
    }) : Se((...s) => {
      const o = this._def.args.safeParse(s, c);
      if (!o.success)
        throw new qe([n(s, o.error)]);
      const d = i(...o.data), f = this._def.returns.safeParse(d, c);
      if (!f.success)
        throw new qe([r(d, f.error)]);
      return f.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Wa({
      ...this._def,
      args: ft.create(t).rest(ua.create())
    });
  }
  returns(t) {
    return new Wa({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, a, n) {
    return new Wa({
      args: t || ft.create([]).rest(ua.create()),
      returns: a || ua.create(),
      typeName: H.ZodFunction,
      ...W(n)
    });
  }
}
class nr extends G {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    return this._def.getter()._parse({ data: a.data, path: a.path, parent: a });
  }
}
nr.create = (e, t) => new nr({
  getter: e,
  typeName: H.ZodLazy,
  ...W(t)
});
class rr extends G {
  _parse(t) {
    if (t.data !== this._def.value) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        received: a.data,
        code: k.invalid_literal,
        expected: this._def.value
      }), q;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
rr.create = (e, t) => new rr({
  value: e,
  typeName: H.ZodLiteral,
  ...W(t)
});
function Uu(e, t) {
  return new Gt({
    values: e,
    typeName: H.ZodEnum,
    ...W(t)
  });
}
class Gt extends G {
  _parse(t) {
    if (typeof t.data != "string") {
      const a = this._getOrReturnCtx(t), n = this._def.values;
      return L(a, {
        expected: ee.joinValues(n),
        received: a.parsedType,
        code: k.invalid_type
      }), q;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const a = this._getOrReturnCtx(t), n = this._def.values;
      return L(a, {
        received: a.data,
        code: k.invalid_enum_value,
        options: n
      }), q;
    }
    return Se(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  get Values() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  get Enum() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  extract(t) {
    return Gt.create(t);
  }
  exclude(t) {
    return Gt.create(this.options.filter((a) => !t.includes(a)));
  }
}
Gt.create = Uu;
class cr extends G {
  _parse(t) {
    const a = ee.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== N.string && n.parsedType !== N.number) {
      const r = ee.objectValues(a);
      return L(n, {
        expected: ee.joinValues(r),
        received: n.parsedType,
        code: k.invalid_type
      }), q;
    }
    if (a.indexOf(t.data) === -1) {
      const r = ee.objectValues(a);
      return L(n, {
        received: n.data,
        code: k.invalid_enum_value,
        options: r
      }), q;
    }
    return Se(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
cr.create = (e, t) => new cr({
  values: e,
  typeName: H.ZodNativeEnum,
  ...W(t)
});
class nn extends G {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== N.promise && a.common.async === !1)
      return L(a, {
        code: k.invalid_type,
        expected: N.promise,
        received: a.parsedType
      }), q;
    const n = a.parsedType === N.promise ? a.data : Promise.resolve(a.data);
    return Se(n.then((r) => this._def.type.parseAsync(r, {
      path: a.path,
      errorMap: a.common.contextualErrorMap
    })));
  }
}
nn.create = (e, t) => new nn({
  type: e,
  typeName: H.ZodPromise,
  ...W(t)
});
class Ye extends G {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === H.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t), r = this._def.effect || null;
    if (r.type === "preprocess") {
      const i = r.transform(n.data);
      return n.common.async ? Promise.resolve(i).then((s) => this._def.schema._parseAsync({
        data: s,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: i,
        path: n.path,
        parent: n
      });
    }
    const c = {
      addIssue: (i) => {
        L(n, i), i.fatal ? a.abort() : a.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (c.addIssue = c.addIssue.bind(c), r.type === "refinement") {
      const i = (s) => {
        const o = r.refinement(s, c);
        if (n.common.async)
          return Promise.resolve(o);
        if (o instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (n.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? q : (s.status === "dirty" && a.dirty(), i(s.value), { status: a.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((s) => s.status === "aborted" ? q : (s.status === "dirty" && a.dirty(), i(s.value).then(() => ({ status: a.value, value: s.value }))));
    }
    if (r.type === "transform")
      if (n.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!lc(i))
          return i;
        const s = r.transform(i.value, c);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: a.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((i) => lc(i) ? Promise.resolve(r.transform(i.value, c)).then((s) => ({ status: a.value, value: s })) : i);
    ee.assertNever(r);
  }
}
Ye.create = (e, t, a) => new Ye({
  schema: e,
  typeName: H.ZodEffects,
  effect: t,
  ...W(a)
});
Ye.createWithPreprocess = (e, t, a) => new Ye({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: H.ZodEffects,
  ...W(a)
});
class Et extends G {
  _parse(t) {
    return this._getType(t) === N.undefined ? Se(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Et.create = (e, t) => new Et({
  innerType: e,
  typeName: H.ZodOptional,
  ...W(t)
});
class Ea extends G {
  _parse(t) {
    return this._getType(t) === N.null ? Se(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ea.create = (e, t) => new Ea({
  innerType: e,
  typeName: H.ZodNullable,
  ...W(t)
});
class ir extends G {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    let n = a.data;
    return a.parsedType === N.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: a.path,
      parent: a
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ir.create = (e, t) => new ir({
  innerType: e,
  typeName: H.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...W(t)
});
class mc extends G {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), n = {
      ...a,
      common: {
        ...a.common,
        issues: []
      }
    }, r = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return uc(r) ? r.then((c) => ({
      status: "valid",
      value: c.status === "valid" ? c.value : this._def.catchValue({
        get error() {
          return new qe(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: r.status === "valid" ? r.value : this._def.catchValue({
        get error() {
          return new qe(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
mc.create = (e, t) => new mc({
  innerType: e,
  typeName: H.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...W(t)
});
class gc extends G {
  _parse(t) {
    if (this._getType(t) !== N.nan) {
      const a = this._getOrReturnCtx(t);
      return L(a, {
        code: k.invalid_type,
        expected: N.nan,
        received: a.parsedType
      }), q;
    }
    return { status: "valid", value: t.data };
  }
}
gc.create = (e) => new gc({
  typeName: H.ZodNaN,
  ...W(e)
});
const Y5 = Symbol("zod_brand");
class Mu extends G {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), n = a.data;
    return this._def.type._parse({
      data: n,
      path: a.path,
      parent: a
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Rr extends G {
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const r = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return r.status === "aborted" ? q : r.status === "dirty" ? (a.dirty(), ju(r.value)) : this._def.out._parseAsync({
          data: r.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const r = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return r.status === "aborted" ? q : r.status === "dirty" ? (a.dirty(), {
        status: "dirty",
        value: r.value
      }) : this._def.out._parseSync({
        data: r.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, a) {
    return new Rr({
      in: t,
      out: a,
      typeName: H.ZodPipeline
    });
  }
}
const Hu = (e, t = {}, a) => e ? an.create().superRefine((n, r) => {
  var c, i;
  if (!e(n)) {
    const s = typeof t == "function" ? t(n) : typeof t == "string" ? { message: t } : t, o = (i = (c = s.fatal) !== null && c !== void 0 ? c : a) !== null && i !== void 0 ? i : !0, d = typeof s == "string" ? { message: s } : s;
    r.addIssue({ code: "custom", ...d, fatal: o });
  }
}) : an.create(), X5 = {
  object: se.lazycreate
};
var H;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(H || (H = {}));
const J5 = (e, t = {
  message: `Input not instance of ${e.name}`
}) => Hu((a) => a instanceof e, t), zu = Fe.create, Fu = Wt.create, Q5 = gc.create, e8 = Kt.create, Vu = Xn.create, t8 = va.create, a8 = bc.create, n8 = Jn.create, r8 = Qn.create, c8 = an.create, i8 = ua.create, s8 = St.create, o8 = hc.create, d8 = We.create, f8 = se.create, l8 = se.strictCreate, u8 = er.create, b8 = zc.create, h8 = tr.create, p8 = ft.create, m8 = ar.create, g8 = pc.create, _8 = xa.create, y8 = Wa.create, w8 = nr.create, v8 = rr.create, x8 = Gt.create, E8 = cr.create, k8 = nn.create, Md = Ye.create, T8 = Et.create, S8 = Ea.create, C8 = Ye.createWithPreprocess, A8 = Rr.create, O8 = () => zu().optional(), I8 = () => Fu().optional(), N8 = () => Vu().optional(), R8 = {
  string: (e) => Fe.create({ ...e, coerce: !0 }),
  number: (e) => Wt.create({ ...e, coerce: !0 }),
  boolean: (e) => Xn.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Kt.create({ ...e, coerce: !0 }),
  date: (e) => va.create({ ...e, coerce: !0 })
}, P8 = q;
var D = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Yn,
  setErrorMap: B5,
  getErrorMap: dc,
  makeIssue: fc,
  EMPTY_PATH: Z5,
  addIssueToContext: L,
  ParseStatus: ve,
  INVALID: q,
  DIRTY: ju,
  OK: Se,
  isAborted: os,
  isDirty: ds,
  isValid: lc,
  isAsync: uc,
  get util() {
    return ee;
  },
  get objectUtil() {
    return ss;
  },
  ZodParsedType: N,
  getParsedType: $t,
  ZodType: G,
  ZodString: Fe,
  ZodNumber: Wt,
  ZodBigInt: Kt,
  ZodBoolean: Xn,
  ZodDate: va,
  ZodSymbol: bc,
  ZodUndefined: Jn,
  ZodNull: Qn,
  ZodAny: an,
  ZodUnknown: ua,
  ZodNever: St,
  ZodVoid: hc,
  ZodArray: We,
  ZodObject: se,
  ZodUnion: er,
  ZodDiscriminatedUnion: zc,
  ZodIntersection: tr,
  ZodTuple: ft,
  ZodRecord: ar,
  ZodMap: pc,
  ZodSet: xa,
  ZodFunction: Wa,
  ZodLazy: nr,
  ZodLiteral: rr,
  ZodEnum: Gt,
  ZodNativeEnum: cr,
  ZodPromise: nn,
  ZodEffects: Ye,
  ZodTransformer: Ye,
  ZodOptional: Et,
  ZodNullable: Ea,
  ZodDefault: ir,
  ZodCatch: mc,
  ZodNaN: gc,
  BRAND: Y5,
  ZodBranded: Mu,
  ZodPipeline: Rr,
  custom: Hu,
  Schema: G,
  ZodSchema: G,
  late: X5,
  get ZodFirstPartyTypeKind() {
    return H;
  },
  coerce: R8,
  any: c8,
  array: d8,
  bigint: e8,
  boolean: Vu,
  date: t8,
  discriminatedUnion: b8,
  effect: Md,
  enum: x8,
  function: y8,
  instanceof: J5,
  intersection: h8,
  lazy: w8,
  literal: v8,
  map: g8,
  nan: Q5,
  nativeEnum: E8,
  never: s8,
  null: r8,
  nullable: S8,
  number: Fu,
  object: f8,
  oboolean: N8,
  onumber: I8,
  optional: T8,
  ostring: O8,
  pipeline: A8,
  preprocess: C8,
  promise: k8,
  record: m8,
  set: _8,
  strictObject: l8,
  string: zu,
  symbol: a8,
  transformer: Md,
  tuple: p8,
  undefined: n8,
  union: u8,
  unknown: i8,
  void: o8,
  NEVER: P8,
  ZodIssueCode: k,
  quotelessJson: D5,
  ZodError: qe
});
const qu = /^0x[0-9a-f]+$/i, Wu = /^\d+$/, L8 = D.string().nonempty("The short string cannot be empty").max(31, "The short string cannot exceed 31 characters").refine(
  (e) => !qu.test(e),
  "The shortString should not be a hex string"
).refine(
  (e) => !Wu.test(e),
  "The shortString should not be an integer string"
), Xr = D.union([
  D.string().regex(
    qu,
    "Only hex, integers and bigint are supported in calldata"
  ),
  D.string().regex(
    Wu,
    "Only hex, integers and bigint are supported in calldata"
  ),
  L8,
  D.number().int("Only hex, integers and bigint are supported in calldata"),
  D.bigint()
]), Hd = D.object({
  contractAddress: D.string(),
  entrypoint: D.string(),
  calldata: D.array(Xr).optional()
}), $8 = D.object({
  types: D.record(
    D.array(
      D.union([
        D.object({
          name: D.string(),
          type: D.string()
        }),
        D.object({
          name: D.string(),
          type: D.literal("merkletree"),
          contains: D.string()
        })
      ])
    )
  ),
  primaryType: D.string(),
  domain: D.record(D.unknown()),
  message: D.record(D.unknown())
}), zd = {
  enable: D.tuple([
    D.object({
      starknetVersion: D.union([D.literal("v3"), D.literal("v4")]).optional()
    }).optional()
  ]).or(D.tuple([])),
  addStarknetChain: D.tuple([
    D.object({
      id: D.string(),
      chainId: D.string(),
      chainName: D.string(),
      rpcUrls: D.array(D.string()).optional(),
      nativeCurrency: D.object({
        name: D.string(),
        symbol: D.string(),
        decimals: D.number()
      }).optional(),
      blockExplorerUrls: D.array(D.string()).optional()
    })
  ]),
  switchStarknetChain: D.tuple([
    D.object({
      chainId: D.string()
    })
  ]),
  watchAsset: D.tuple([
    D.object({
      type: D.literal("ERC20"),
      options: D.object({
        address: D.string(),
        symbol: D.string().optional(),
        decimals: D.number().optional(),
        image: D.string().optional(),
        name: D.string().optional()
      })
    })
  ]),
  execute: D.tuple([
    D.array(Hd).nonempty().or(Hd),
    D.array(D.any()).optional(),
    D.object({
      nonce: Xr.optional(),
      maxFee: Xr.optional(),
      version: Xr.optional()
    }).optional()
  ]),
  signMessage: D.tuple([$8])
};
function D8(e) {
  return e;
}
function B8(e) {
  return e.length === 0 ? D8 : e.length === 1 ? e[0] : function(a) {
    return e.reduce((n, r) => r(n), a);
  };
}
function Z8(e) {
  return typeof e == "object" && e !== null && "subscribe" in e;
}
function Fc(e) {
  const t = {
    subscribe(a) {
      let n = null, r = !1, c = !1, i = !1;
      function s() {
        if (n === null) {
          i = !0;
          return;
        }
        c || (c = !0, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = e({
        next(o) {
          r || a.next?.(o);
        },
        error(o) {
          r || (r = !0, a.error?.(o), s());
        },
        complete() {
          r || (r = !0, a.complete?.(), s());
        }
      }), i && s(), {
        unsubscribe: s
      };
    },
    pipe(...a) {
      return B8(a)(t);
    }
  };
  return t;
}
function Ku(e) {
  return (t) => {
    let a = 0, n = null;
    const r = [];
    function c() {
      n || (n = t.subscribe({
        next(s) {
          for (const o of r)
            o.next?.(s);
        },
        error(s) {
          for (const o of r)
            o.error?.(s);
        },
        complete() {
          for (const s of r)
            s.complete?.();
        }
      }));
    }
    function i() {
      if (a === 0 && n) {
        const s = n;
        n = null, s.unsubscribe();
      }
    }
    return {
      subscribe(s) {
        return a++, r.push(s), c(), {
          unsubscribe() {
            a--, i();
            const o = r.findIndex((d) => d === s);
            o > -1 && r.splice(o, 1);
          }
        };
      }
    };
  };
}
function j8(e) {
  return (t) => ({
    subscribe(a) {
      let n = 0;
      return t.subscribe({
        next(c) {
          a.next?.(e(c, n++));
        },
        error(c) {
          a.error?.(c);
        },
        complete() {
          a.complete?.();
        }
      });
    }
  });
}
function Gu(e) {
  return (t) => ({
    subscribe(a) {
      return t.subscribe({
        next(n) {
          e.next?.(n), a.next?.(n);
        },
        error(n) {
          e.error?.(n), a.error?.(n);
        },
        complete() {
          e.complete?.(), a.complete?.();
        }
      });
    }
  });
}
let U8 = class Yu extends Error {
  constructor(t) {
    super(t), this.name = "ObservableAbortError", Object.setPrototypeOf(this, Yu.prototype);
  }
};
function Xu(e) {
  let t;
  return {
    promise: new Promise((n, r) => {
      let c = !1;
      function i() {
        c || (c = !0, r(new U8("This operation was aborted.")), s.unsubscribe());
      }
      const s = e.subscribe({
        next(o) {
          c = !0, n(o), i();
        },
        error(o) {
          c = !0, r(o), i();
        },
        complete() {
          c = !0, i();
        }
      });
      t = i;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: t
  };
}
const M8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isObservable: Z8,
  map: j8,
  observable: Fc,
  observableToPromise: Xu,
  share: Ku,
  tap: Gu
}, Symbol.toStringTag, { value: "Module" }));
function Ju(e) {
  return Fc((t) => {
    function a(r = 0, c = e.op) {
      const i = e.links[r];
      if (!i)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return i({
        op: c,
        next(o) {
          return a(r + 1, o);
        }
      });
    }
    return a().subscribe(t);
  });
}
function Fd(e) {
  return Array.isArray(e) ? e : [
    e
  ];
}
function H8(e) {
  return (t) => {
    const a = Fd(e.true).map((r) => r(t)), n = Fd(e.false).map((r) => r(t));
    return (r) => Fc((c) => {
      const i = e.condition(r.op) ? a : n;
      return Ju({
        op: r.op,
        links: i
      }).subscribe(c);
    });
  };
}
let z8 = class Jr extends Error {
  static from(t, a = {}) {
    return t instanceof Error ? t.name === "TRPCClientError" ? t : new Jr(t.message, {
      ...a,
      cause: t,
      result: null
    }) : new Jr(t.error.message ?? "", {
      ...a,
      cause: void 0,
      result: t
    });
  }
  constructor(t, a) {
    const n = a?.cause;
    super(t, {
      cause: n
    }), this.meta = a?.meta, this.cause = n, this.shape = a?.result?.error, this.data = a?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, Jr.prototype);
  }
};
function Qu(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const a in e) {
    const n = e[a];
    t[n] = a;
  }
  return t;
}
const Vc = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  /**
  * Internal JSON-RPC error.
  */
  INTERNAL_SERVER_ERROR: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
Qu(Vc);
Qu(Vc);
const F8 = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  NOT_FOUND: 404,
  INTERNAL_SERVER_ERROR: 500,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  TIMEOUT: 408,
  CONFLICT: 409,
  CLIENT_CLOSED_REQUEST: 499,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  METHOD_NOT_SUPPORTED: 405,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429
};
function V8(e) {
  return F8[e] ?? 500;
}
function e0(e) {
  const { code: t } = e;
  return V8(t);
}
const t0 = () => {
};
function a0(e, t) {
  return new Proxy(t0, {
    get(n, r) {
      if (!(typeof r != "string" || r === "then"))
        return a0(e, [
          ...t,
          r
        ]);
    },
    apply(n, r, c) {
      const i = t[t.length - 1] === "apply";
      return e({
        args: i ? c.length >= 2 ? c[1] : [] : c,
        path: i ? t.slice(0, -1) : t
      });
    }
  });
}
const go = (e) => a0(e, []), _o = (e) => new Proxy(t0, {
  get(t, a) {
    if (!(typeof a != "string" || a === "then"))
      return e(a);
  }
});
function q8(e) {
  const { path: t, error: a, config: n } = e, { code: r } = e.error, c = {
    message: a.message,
    code: Vc[r],
    data: {
      code: r,
      httpStatus: e0(a)
    }
  };
  return n.isDev && typeof e.error.stack == "string" && (c.data.stack = e.error.stack), typeof t == "string" && (c.data.path = t), n.errorFormatter({
    ...e,
    shape: c
  });
}
function Vd(e, t) {
  return "error" in t ? {
    ...t,
    error: e.transformer.output.serialize(t.error)
  } : "data" in t.result ? {
    ...t,
    result: {
      ...t.result,
      data: e.transformer.output.serialize(t.result.data)
    }
  } : t;
}
function W8(e, t) {
  return Array.isArray(t) ? t.map((a) => Vd(e, a)) : Vd(e, t);
}
const K8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createFlatProxy: _o,
  createRecursiveProxy: go,
  getErrorShape: q8,
  transformTRPCResponse: W8
}, Symbol.toStringTag, { value: "Module" })), G8 = {
  query: [
    "72e3ff",
    "3fb0d8"
  ],
  mutation: [
    "c5a3fc",
    "904dfc"
  ],
  subscription: [
    "ff49e1",
    "d83fbe"
  ]
};
function Y8(e) {
  return typeof FormData > "u" ? !1 : e instanceof FormData;
}
const X8 = (e = console) => (t) => {
  const { direction: a, type: n, path: r, context: c, id: i } = t, [s, o] = G8[n], d = t.input, f = Y8(d) ? Object.fromEntries(d) : d, l = `
    background-color: #${a === "up" ? s : o}; 
    color: ${a === "up" ? "black" : "white"};
    padding: 2px;
  `, b = [
    "%c",
    a === "up" ? ">>" : "<<",
    n,
    `#${i}`,
    `%c${r}%c`,
    "%O"
  ], u = [
    l,
    `${l}; font-weight: bold;`,
    `${l}; font-weight: normal;`
  ];
  t.direction === "up" ? u.push({
    input: f,
    context: c
  }) : u.push({
    input: f,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: c
  });
  const h = t.direction === "down" && t.result && (t.result instanceof Error || "error" in t.result.result) ? "error" : "log";
  e[h].apply(null, [
    b.join(" ")
  ].concat(u));
};
function J8(e = {}) {
  const { enabled: t = () => !0 } = e, { logger: a = X8(e.console) } = e;
  return () => ({ op: n, next: r }) => Fc((c) => {
    t({
      ...n,
      direction: "up"
    }) && a({
      ...n,
      direction: "up"
    });
    const i = Date.now();
    function s(o) {
      const d = Date.now() - i;
      t({
        ...n,
        direction: "down",
        result: o
      }) && a({
        ...n,
        direction: "down",
        elapsedMs: d,
        result: o
      });
    }
    return r(n).pipe(Gu({
      next(o) {
        s(o);
      },
      error(o) {
        s(o);
      }
    })).subscribe(c);
  });
}
let Q8 = class {
  $request({ type: t, input: a, path: n, context: r = {} }) {
    return Ju({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: t,
        path: n,
        input: a,
        context: r
      }
    }).pipe(Ku());
  }
  requestAsPromise(t) {
    const a = this.$request(t), { promise: n, abort: r } = Xu(a);
    return new Promise((i, s) => {
      t.signal?.addEventListener("abort", r), n.then((o) => {
        i(o.result.data);
      }).catch((o) => {
        s(z8.from(o));
      });
    });
  }
  query(t, a, n) {
    return this.requestAsPromise({
      type: "query",
      path: t,
      input: a,
      context: n?.context,
      signal: n?.signal
    });
  }
  mutation(t, a, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: t,
      input: a,
      context: n?.context,
      signal: n?.signal
    });
  }
  subscription(t, a, n) {
    return this.$request({
      type: "subscription",
      path: t,
      input: a,
      context: n?.context
    }).subscribe({
      next(c) {
        c.result.type === "started" ? n.onStarted?.() : c.result.type === "stopped" ? n.onStopped?.() : n.onData?.(c.result.data);
      },
      error(c) {
        n.onError?.(c);
      },
      complete() {
        n.onComplete?.();
      }
    });
  }
  constructor(t) {
    this.requestId = 0;
    const a = (() => {
      const n = t.transformer;
      return n ? "input" in n ? t.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (r) => r,
          deserialize: (r) => r
        },
        output: {
          serialize: (r) => r,
          deserialize: (r) => r
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => a.input.serialize(n),
        deserialize: (n) => a.output.deserialize(n)
      },
      combinedTransformer: a
    }, this.links = t.links.map((n) => n(this.runtime));
  }
};
const e9 = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, t9 = (e) => e9[e];
function a9(e) {
  return _o((t) => e.hasOwnProperty(t) ? e[t] : go(({ path: a, args: n }) => {
    const r = [
      t,
      ...a
    ], c = t9(r.pop()), i = r.join(".");
    return e[c](i, ...n);
  }));
}
function n9(e) {
  const t = new Q8(e);
  return a9(t);
}
function r9(e) {
  return !!e && !Array.isArray(e) && typeof e == "object";
}
function c9(e) {
  if (e instanceof rn)
    return e;
  const t = new rn({
    code: "INTERNAL_SERVER_ERROR",
    cause: e
  });
  return e instanceof Error && e.stack && (t.stack = e.stack), t;
}
class i9 extends Error {
}
function s9(e) {
  if (e instanceof Error)
    return e;
  const t = typeof e;
  if (!(t === "undefined" || t === "function" || e === null)) {
    if (t !== "object")
      return new Error(String(e));
    if (r9(e)) {
      const a = new i9();
      for (const n in e)
        a[n] = e[n];
      return a;
    }
  }
}
class rn extends Error {
  constructor(t) {
    const a = s9(t.cause), n = t.message ?? a?.message ?? t.code;
    super(n, {
      cause: a
    }), this.code = t.code, this.name = this.constructor.name;
  }
}
function o9(e) {
  return "input" in e ? e : {
    input: e,
    output: e
  };
}
const Pn = {
  _default: !0,
  input: {
    serialize: (e) => e,
    deserialize: (e) => e
  },
  output: {
    serialize: (e) => e,
    deserialize: (e) => e
  }
}, Ln = ({ shape: e }) => e;
function d9(e) {
  return Object.assign(/* @__PURE__ */ Object.create(null), e);
}
const f9 = [
  "query",
  "mutation",
  "subscription"
];
function l9(e) {
  return "router" in e._def;
}
const u9 = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: Ln,
  transformer: Pn
}, b9 = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function n0(e) {
  return function(a) {
    const n = new Set(Object.keys(a).filter((o) => b9.includes(o)));
    if (n.size > 0)
      throw new Error("Reserved words used in `router({})` call: " + Array.from(n).join(", "));
    const r = d9({});
    function c(o, d = "") {
      for (const [f, l] of Object.entries(o ?? {})) {
        const b = `${d}${f}`;
        if (l9(l)) {
          c(l._def.procedures, `${b}.`);
          continue;
        }
        if (r[b])
          throw new Error(`Duplicate key: ${b}`);
        r[b] = l;
      }
    }
    c(a);
    const i = {
      _config: e,
      router: !0,
      procedures: r,
      ...u9,
      record: a,
      queries: Object.entries(r).filter((o) => o[1]._def.query).reduce((o, [d, f]) => ({
        ...o,
        [d]: f
      }), {}),
      mutations: Object.entries(r).filter((o) => o[1]._def.mutation).reduce((o, [d, f]) => ({
        ...o,
        [d]: f
      }), {}),
      subscriptions: Object.entries(r).filter((o) => o[1]._def.subscription).reduce((o, [d, f]) => ({
        ...o,
        [d]: f
      }), {})
    };
    return {
      ...a,
      _def: i,
      createCaller(o) {
        return go(({ path: f, args: l }) => {
          if (f.length === 1 && f9.includes(f[0]))
            return h9({
              procedures: i.procedures,
              path: l[0],
              rawInput: l[1],
              ctx: o,
              type: f[0]
            });
          const b = f.join("."), u = i.procedures[b];
          let h = "query";
          return u._def.mutation ? h = "mutation" : u._def.subscription && (h = "subscription"), u({
            path: b,
            rawInput: l[0],
            ctx: o,
            type: h
          });
        });
      },
      getErrorShape(o) {
        const { path: d, error: f } = o, { code: l } = o.error, b = {
          message: f.message,
          code: Vc[l],
          data: {
            code: l,
            httpStatus: e0(f)
          }
        };
        return e.isDev && typeof o.error.stack == "string" && (b.data.stack = o.error.stack), typeof d == "string" && (b.data.path = d), this._def._config.errorFormatter({
          ...o,
          shape: b
        });
      }
    };
  };
}
function h9(e) {
  const { type: t, path: a } = e;
  if (!(a in e.procedures) || !e.procedures[a]?._def[t])
    throw new rn({
      code: "NOT_FOUND",
      message: `No "${t}"-procedure on path "${a}"`
    });
  const n = e.procedures[a];
  return n(e);
}
const qd = typeof window > "u" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;
function Wd(e) {
  const t = e;
  if (typeof t == "function")
    return t;
  if (typeof t.parseAsync == "function")
    return t.parseAsync.bind(t);
  if (typeof t.parse == "function")
    return t.parse.bind(t);
  if (typeof t.validateSync == "function")
    return t.validateSync.bind(t);
  if (typeof t.create == "function")
    return t.create.bind(t);
  if (typeof t.assert == "function")
    return (a) => (t.assert(a), a);
  throw new Error("Could not find a validator fn");
}
function r0(e, ...t) {
  const a = Object.assign(/* @__PURE__ */ Object.create(null), e);
  for (const n of t)
    for (const r in n) {
      if (r in a && a[r] !== n[r])
        throw new Error(`Duplicate key ${r}`);
      a[r] = n[r];
    }
  return a;
}
function p9() {
  function e(a) {
    return {
      _middlewares: a,
      unstable_pipe(n) {
        const r = "_middlewares" in n ? n._middlewares : [
          n
        ];
        return e([
          ...a,
          ...r
        ]);
      }
    };
  }
  function t(a) {
    return e([
      a
    ]);
  }
  return t;
}
function Kd(e) {
  return e && typeof e == "object" && !Array.isArray(e);
}
function m9(e) {
  const t = async ({ next: a, rawInput: n, input: r }) => {
    let c;
    try {
      c = await e(n);
    } catch (s) {
      throw new rn({
        code: "BAD_REQUEST",
        cause: s
      });
    }
    const i = Kd(r) && Kd(c) ? {
      ...r,
      ...c
    } : c;
    return a({
      input: i
    });
  };
  return t._type = "input", t;
}
function g9(e) {
  const t = async ({ next: a }) => {
    const n = await a();
    if (!n.ok)
      return n;
    try {
      const r = await e(n.data);
      return {
        ...n,
        data: r
      };
    } catch (r) {
      throw new rn({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause: r
      });
    }
  };
  return t._type = "output", t;
}
const c0 = "middlewareMarker";
function Za(e, t) {
  const { middlewares: a = [], inputs: n, meta: r, ...c } = t;
  return i0({
    ...r0(e, c),
    inputs: [
      ...e.inputs,
      ...n ?? []
    ],
    middlewares: [
      ...e.middlewares,
      ...a
    ],
    meta: e.meta && r ? {
      ...e.meta,
      ...r
    } : r ?? e.meta
  });
}
function i0(e = {}) {
  const t = {
    inputs: [],
    middlewares: [],
    ...e
  };
  return {
    _def: t,
    input(a) {
      const n = Wd(a);
      return Za(t, {
        inputs: [
          a
        ],
        middlewares: [
          m9(n)
        ]
      });
    },
    output(a) {
      const n = Wd(a);
      return Za(t, {
        output: a,
        middlewares: [
          g9(n)
        ]
      });
    },
    meta(a) {
      return Za(t, {
        meta: a
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(a) {
      return Za(t, a._def);
    },
    use(a) {
      const n = "_middlewares" in a ? a._middlewares : [
        a
      ];
      return Za(t, {
        middlewares: n
      });
    },
    query(a) {
      return Ai({
        ...t,
        query: !0
      }, a);
    },
    mutation(a) {
      return Ai({
        ...t,
        mutation: !0
      }, a);
    },
    subscription(a) {
      return Ai({
        ...t,
        subscription: !0
      }, a);
    }
  };
}
function Ai(e, t) {
  const a = Za(e, {
    resolver: t,
    middlewares: [
      async function(r) {
        const c = await t(r);
        return {
          marker: c0,
          ok: !0,
          data: c,
          ctx: r.ctx
        };
      }
    ]
  });
  return y9(a._def);
}
const _9 = `
If you want to call this function on the server, you do the following:
This is a client-only function.

const caller = appRouter.createCaller({
  /* ... your context */
});

const result = await caller.call('myProcedure', input);
`.trim();
function y9(e) {
  const t = async function(n) {
    if (!n || !("rawInput" in n))
      throw new Error(_9);
    const r = async (i = {
      index: 0,
      ctx: n.ctx
    }) => {
      try {
        const s = e.middlewares[i.index];
        return await s({
          ctx: i.ctx,
          type: n.type,
          path: n.path,
          rawInput: i.rawInput ?? n.rawInput,
          meta: e.meta,
          input: i.input,
          next(d) {
            const f = d;
            return r({
              index: i.index + 1,
              ctx: f && "ctx" in f ? {
                ...i.ctx,
                ...f.ctx
              } : i.ctx,
              input: f && "input" in f ? f.input : i.input,
              rawInput: f && "rawInput" in f ? f.rawInput : i.rawInput
            });
          }
        });
      } catch (s) {
        return {
          ok: !1,
          error: c9(s),
          marker: c0
        };
      }
    }, c = await r();
    if (!c)
      throw new rn({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    if (!c.ok)
      throw c.error;
    return c.data;
  };
  return t._def = e, t.meta = e.meta, t;
}
function w9(...e) {
  const t = r0({}, ...e.map((c) => c._def.record)), a = e.reduce((c, i) => {
    if (i._def._config.errorFormatter && i._def._config.errorFormatter !== Ln) {
      if (c !== Ln && c !== i._def._config.errorFormatter)
        throw new Error("You seem to have several error formatters");
      return i._def._config.errorFormatter;
    }
    return c;
  }, Ln), n = e.reduce((c, i) => {
    if (i._def._config.transformer && i._def._config.transformer !== Pn) {
      if (c !== Pn && c !== i._def._config.transformer)
        throw new Error("You seem to have several transformers");
      return i._def._config.transformer;
    }
    return c;
  }, Pn);
  return n0({
    errorFormatter: a,
    transformer: n,
    isDev: e.some((c) => c._def._config.isDev),
    allowOutsideOfServer: e.some((c) => c._def._config.allowOutsideOfServer),
    isServer: e.some((c) => c._def._config.isServer),
    $types: e[0]?._def._config.$types
  })(t);
}
class _c {
  context() {
    return new _c();
  }
  meta() {
    return new _c();
  }
  create(t) {
    return x9()(t);
  }
}
const v9 = new _c();
function x9() {
  return function(t) {
    const a = t?.errorFormatter ?? Ln, r = {
      transformer: o9(t?.transformer ?? Pn),
      isDev: t?.isDev ?? globalThis.process?.env?.NODE_ENV !== "production",
      allowOutsideOfServer: t?.allowOutsideOfServer ?? !1,
      errorFormatter: a,
      isServer: t?.isServer ?? qd,
      /**
      * @internal
      */
      $types: _o((c) => {
        throw new Error(`Tried to access "$types.${c}" which is not available at runtime`);
      })
    };
    if (!(t?.isServer ?? qd) && t?.allowOutsideOfServer !== !0)
      throw new Error("You're trying to use @trpc/server in a non-server environment. This is not supported by default.");
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: r,
      /**
      * Builder object for creating procedures
      */
      procedure: i0({
        meta: t?.defaultMeta
      }),
      /**
      * Create reusable middlewares
      */
      middleware: p9(),
      /**
      * Create a router
      */
      router: n0(r),
      /**
      * Merge Routers
      */
      mergeRouters: w9
    };
  };
}
var ls = {}, qc = {}, pn = {}, he = {};
const mn = /* @__PURE__ */ zf(M8);
var yo = {}, s0 = mn;
function o0(e) {
  return s0.observable((t) => {
    function a(r = 0, c = e.op) {
      const i = e.links[r];
      if (!i)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return i({
        op: c,
        next(o) {
          return a(r + 1, o);
        }
      });
    }
    return a().subscribe(t);
  });
}
function Gd(e) {
  return Array.isArray(e) ? e : [
    e
  ];
}
function E9(e) {
  return (t) => {
    const a = Gd(e.true).map((r) => r(t)), n = Gd(e.false).map((r) => r(t));
    return (r) => s0.observable((c) => {
      const i = e.condition(r.op) ? a : n;
      return o0({
        op: r.op,
        links: i
      }).subscribe(c);
    });
  };
}
yo.createChain = o0;
yo.splitLink = E9;
var gn = {};
class zt extends Error {
  static from(t, a = {}) {
    return t instanceof Error ? t.name === "TRPCClientError" ? t : new zt(t.message, {
      ...a,
      cause: t,
      result: null
    }) : new zt(t.error.message ?? "", {
      ...a,
      cause: void 0,
      result: t
    });
  }
  constructor(t, a) {
    const n = a?.cause;
    super(t, {
      cause: n
    }), this.meta = a?.meta, this.cause = n, this.shape = a?.result?.error, this.data = a?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, zt.prototype);
  }
}
function Yd(e) {
  return !!e && !Array.isArray(e) && typeof e == "object";
}
function k9(e, t) {
  if ("error" in e) {
    const n = t.transformer.deserialize(e.error);
    return {
      ok: !1,
      error: {
        ...e,
        error: n
      }
    };
  }
  return {
    ok: !0,
    result: {
      ...e.result,
      ...(!e.result.type || e.result.type === "data") && {
        type: "data",
        data: t.transformer.deserialize(e.result.data)
      }
    }
  };
}
function T9(e, t) {
  let a;
  try {
    a = k9(e, t);
  } catch {
    throw new zt("Unable to transform response from server");
  }
  if (!a.ok && (!Yd(a.error.error) || typeof a.error.error.code != "number"))
    throw new zt("Badly formatted response from server");
  if (a.ok && !Yd(a.result))
    throw new zt("Badly formatted response from server");
  return a;
}
gn.TRPCClientError = zt;
gn.transformResult = T9;
const S9 = /* @__PURE__ */ zf(K8);
var pt = {};
const us = (e) => typeof e == "function";
function Xd(e, t) {
  return us(e.bind) ? e.bind(t) : e;
}
function d0(e) {
  if (e)
    return e;
  if (typeof window < "u" && us(window.fetch))
    return Xd(window.fetch, window);
  if (typeof globalThis < "u" && us(globalThis.fetch))
    return Xd(globalThis.fetch, globalThis);
  throw new Error("No fetch implementation found");
}
function C9(e) {
  return e || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function A9(e) {
  return {
    url: e.url,
    fetch: d0(e.fetch),
    AbortController: C9(e.AbortController)
  };
}
function O9(e) {
  const t = {};
  for (let a = 0; a < e.length; a++) {
    const n = e[a];
    t[a] = n;
  }
  return t;
}
const I9 = {
  query: "GET",
  mutation: "POST"
};
function f0(e) {
  return "input" in e ? e.runtime.transformer.serialize(e.input) : O9(e.inputs.map((t) => e.runtime.transformer.serialize(t)));
}
const l0 = (e) => {
  let t = e.url + "/" + e.path;
  const a = [];
  if ("inputs" in e && a.push("batch=1"), e.type === "query") {
    const n = f0(e);
    n !== void 0 && a.push(`input=${encodeURIComponent(JSON.stringify(n))}`);
  }
  return a.length && (t += "?" + a.join("&")), t;
}, u0 = (e) => {
  if (e.type === "query")
    return;
  const t = f0(e);
  return t !== void 0 ? JSON.stringify(t) : void 0;
}, N9 = (e) => h0({
  ...e,
  contentTypeHeader: "application/json",
  getUrl: l0,
  getBody: u0
});
async function b0(e, t) {
  const a = e.getUrl(e), n = e.getBody(e), { type: r } = e, c = await e.headers();
  /* istanbul ignore if -- @preserve */
  if (r === "subscription")
    throw new Error("Subscriptions should use wsLink");
  return e.fetch(a, {
    method: I9[r],
    signal: t?.signal,
    body: n,
    headers: {
      ...e.contentTypeHeader ? {
        "content-type": e.contentTypeHeader
      } : {},
      ...e.batchModeHeader ? {
        "trpc-batch-mode": e.batchModeHeader
      } : {},
      ...c
    }
  });
}
function h0(e) {
  const t = e.AbortController ? new e.AbortController() : null, a = {};
  return {
    promise: new Promise((c, i) => {
      b0(e, t).then((s) => (a.response = s, s.json())).then((s) => {
        c({
          json: s,
          meta: a
        });
      }).catch(i);
    }),
    cancel: () => {
      t?.abort();
    }
  };
}
pt.fetchHTTPResponse = b0;
pt.getBody = u0;
pt.getFetch = d0;
pt.getUrl = l0;
pt.httpRequest = h0;
pt.jsonHttpRequester = N9;
pt.resolveHTTPLinkOptions = A9;
var wo = {}, R9 = mn, Oi = gn, bs = pt;
const Ii = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function Ni(e) {
  let t = null, a = null;
  const n = () => {
    clearTimeout(a), a = null, t = null;
  };
  function r(s) {
    const o = [
      []
    ];
    let d = 0;
    for (; ; ) {
      const f = s[d];
      if (!f)
        break;
      const l = o[o.length - 1];
      if (f.aborted) {
        f.reject?.(new Error("Aborted")), d++;
        continue;
      }
      if (e.validate(l.concat(f).map((u) => u.key))) {
        l.push(f), d++;
        continue;
      }
      if (l.length === 0) {
        f.reject?.(new Error("Input is too big for a single dispatch")), d++;
        continue;
      }
      o.push([]);
    }
    return o;
  }
  function c() {
    const s = r(t);
    n();
    for (const o of s) {
      if (!o.length)
        continue;
      const d = {
        items: o,
        cancel: Ii
      };
      for (const u of o)
        u.batch = d;
      const f = (u, h) => {
        const p = d.items[u];
        p.resolve?.(h), p.batch = null, p.reject = null, p.resolve = null;
      }, { promise: l, cancel: b } = e.fetch(d.items.map((u) => u.key), f);
      d.cancel = b, l.then((u) => {
        for (let h = 0; h < u.length; h++) {
          const p = u[h];
          f(h, p);
        }
        for (let h = 0; h < d.items.length; h++) {
          const p = d.items[h];
          p.reject?.(new Error("Missing result")), p.batch = null;
        }
      }).catch((u) => {
        for (const h of d.items)
          h.reject?.(u), h.batch = null;
      });
    }
  }
  function i(s) {
    const o = {
      aborted: !1,
      key: s,
      batch: null,
      resolve: Ii,
      reject: Ii
    }, d = new Promise((l, b) => {
      o.reject = b, o.resolve = l, t || (t = []), t.push(o);
    });
    return a || (a = setTimeout(c)), {
      promise: d,
      cancel: () => {
        o.aborted = !0, o.batch?.items.every((l) => l.aborted) && (o.batch.cancel(), o.batch = null);
      }
    };
  }
  return {
    load: i
  };
}
function p0(e) {
  return function(a) {
    const n = bs.resolveHTTPLinkOptions(a), r = a.maxURLLength || 1 / 0;
    return (c) => {
      const i = (l) => {
        const b = (h) => {
          if (r === 1 / 0)
            return !0;
          const p = h.map((v) => v.path).join(","), m = h.map((v) => v.input);
          return bs.getUrl({
            ...n,
            runtime: c,
            type: l,
            path: p,
            inputs: m
          }).length <= r;
        }, u = e({
          ...n,
          runtime: c,
          type: l,
          opts: a
        });
        return {
          validate: b,
          fetch: u
        };
      }, s = Ni(i("query")), o = Ni(i("mutation")), d = Ni(i("subscription")), f = {
        query: s,
        subscription: d,
        mutation: o
      };
      return ({ op: l }) => R9.observable((b) => {
        const u = f[l.type], { promise: h, cancel: p } = u.load(l);
        return h.then((m) => {
          const g = Oi.transformResult(m.json, c);
          if (!g.ok) {
            b.error(Oi.TRPCClientError.from(g.error, {
              meta: m.meta
            }));
            return;
          }
          b.next({
            context: m.meta,
            result: g.result
          }), b.complete();
        }).catch((m) => b.error(Oi.TRPCClientError.from(m))), () => p();
      });
    };
  };
}
const P9 = (e) => (t) => {
  const a = t.map((i) => i.path).join(","), n = t.map((i) => i.input), { promise: r, cancel: c } = bs.jsonHttpRequester({
    ...e,
    path: a,
    inputs: n,
    headers() {
      return e.opts.headers ? typeof e.opts.headers == "function" ? e.opts.headers({
        opList: t
      }) : e.opts.headers : {};
    }
  });
  return {
    promise: r.then((i) => (Array.isArray(i.json) ? i.json : t.map(() => i.json)).map((d) => ({
      meta: i.meta,
      json: d
    }))),
    cancel: c
  };
}, L9 = p0(P9);
wo.createHTTPBatchLink = p0;
wo.httpBatchLink = L9;
var Wc = {};
Object.defineProperty(Wc, "__esModule", { value: !0 });
var $9 = mn, Ri = gn, m0 = pt;
function g0(e) {
  return (t) => {
    const a = m0.resolveHTTPLinkOptions(t);
    return (n) => ({ op: r }) => $9.observable((c) => {
      const { path: i, input: s, type: o } = r, { promise: d, cancel: f } = e.requester({
        ...a,
        runtime: n,
        type: o,
        path: i,
        input: s,
        headers() {
          return t.headers ? typeof t.headers == "function" ? t.headers({
            op: r
          }) : t.headers : {};
        }
      });
      return d.then((l) => {
        const b = Ri.transformResult(l.json, n);
        if (!b.ok) {
          c.error(Ri.TRPCClientError.from(b.error, {
            meta: l.meta
          }));
          return;
        }
        c.next({
          context: l.meta,
          result: b.result
        }), c.complete();
      }).catch((l) => c.error(Ri.TRPCClientError.from(l))), () => {
        f();
      };
    });
  };
}
const D9 = g0({
  requester: m0.jsonHttpRequester
});
Wc.httpLink = D9;
Wc.httpLinkFactory = g0;
var vo = {};
Object.defineProperty(vo, "__esModule", { value: !0 });
var Jd = mn;
const B9 = {
  query: [
    "72e3ff",
    "3fb0d8"
  ],
  mutation: [
    "c5a3fc",
    "904dfc"
  ],
  subscription: [
    "ff49e1",
    "d83fbe"
  ]
};
function Z9(e) {
  return typeof FormData > "u" ? !1 : e instanceof FormData;
}
const j9 = (e = console) => (t) => {
  const { direction: a, type: n, path: r, context: c, id: i } = t, [s, o] = B9[n], d = t.input, f = Z9(d) ? Object.fromEntries(d) : d, l = `
    background-color: #${a === "up" ? s : o}; 
    color: ${a === "up" ? "black" : "white"};
    padding: 2px;
  `, b = [
    "%c",
    a === "up" ? ">>" : "<<",
    n,
    `#${i}`,
    `%c${r}%c`,
    "%O"
  ], u = [
    l,
    `${l}; font-weight: bold;`,
    `${l}; font-weight: normal;`
  ];
  t.direction === "up" ? u.push({
    input: f,
    context: c
  }) : u.push({
    input: f,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: c
  });
  const h = t.direction === "down" && t.result && (t.result instanceof Error || "error" in t.result.result) ? "error" : "log";
  e[h].apply(null, [
    b.join(" ")
  ].concat(u));
};
function U9(e = {}) {
  const { enabled: t = () => !0 } = e, { logger: a = j9(e.console) } = e;
  return () => ({ op: n, next: r }) => Jd.observable((c) => {
    t({
      ...n,
      direction: "up"
    }) && a({
      ...n,
      direction: "up"
    });
    const i = Date.now();
    function s(o) {
      const d = Date.now() - i;
      t({
        ...n,
        direction: "down",
        result: o
      }) && a({
        ...n,
        direction: "down",
        elapsedMs: d,
        result: o
      });
    }
    return r(n).pipe(Jd.tap({
      next(o) {
        s(o);
      },
      error(o) {
        s(o);
      }
    })).subscribe(c);
  });
}
vo.loggerLink = U9;
var Kc = {};
Object.defineProperty(Kc, "__esModule", { value: !0 });
var M9 = mn, hs = gn;
/* istanbul ignore next -- @preserve */
const H9 = (e) => e === 0 ? 0 : Math.min(1e3 * 2 ** e, 3e4);
function z9(e) {
  const { url: t, WebSocket: a = WebSocket, retryDelayMs: n = H9, onOpen: r, onClose: c } = e;
  /* istanbul ignore next -- @preserve */
  if (!a)
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  let i = [];
  const s = /* @__PURE__ */ Object.create(null);
  let o = 0, d = null, f = null, l = y(), b = "connecting";
  function u() {
    b !== "open" || d || (d = setTimeout(() => {
      d = null, i.length === 1 ? l.send(JSON.stringify(i.pop())) : l.send(JSON.stringify(i)), i = [];
    }));
  }
  function h() {
    if (f || b === "closed")
      return;
    const E = n(o++);
    m(E);
  }
  function p() {
    b = "connecting";
    const E = l;
    l = y(), g(E);
  }
  function m(E) {
    f || (b = "connecting", f = setTimeout(p, E));
  }
  function g(E) {
    Object.values(s).some((I) => I.ws === E) || E.close();
  }
  function v() {
    Object.values(s).forEach((E) => {
      E.type === "subscription" && E.callbacks.complete();
    });
  }
  function S(E) {
    i.some((_) => _.id === E.op.id) || O(E.op, E.callbacks);
  }
  function y() {
    const E = typeof t == "function" ? t() : t, _ = new a(E);
    clearTimeout(f), f = null, _.addEventListener("open", () => {
      /* istanbul ignore next -- @preserve */
      _ === l && (o = 0, b = "open", r?.(), u());
    }), _.addEventListener("error", () => {
      _ === l && h();
    });
    const I = (C) => {
      if (C.method === "reconnect" && _ === l) {
        b === "open" && c?.(), p();
        for (const x of Object.values(s))
          x.type === "subscription" && S(x);
      }
    }, j = (C) => {
      const x = C.id !== null && s[C.id];
      if (x) {
        if (x.callbacks.next?.(C), x.ws !== l && _ === l) {
          const J = x.ws;
          x.ws = l, g(J);
        }
        "result" in C && C.result.type === "stopped" && _ === l && x.callbacks.complete();
      }
    };
    return _.addEventListener("message", ({ data: C }) => {
      const x = JSON.parse(C);
      "method" in x ? I(x) : j(x), (_ !== l || b === "closed") && g(_);
    }), _.addEventListener("close", ({ code: C }) => {
      b === "open" && c?.({
        code: C
      }), l === _ && h();
      for (const [x, J] of Object.entries(s))
        if (J.ws === _) {
          if (b === "closed") {
            delete s[x], J.callbacks.complete?.();
            continue;
          }
          J.type === "subscription" ? S(J) : (delete s[x], J.callbacks.error?.(hs.TRPCClientError.from(new xo("WebSocket closed prematurely"))));
        }
    }), _;
  }
  function O(E, _) {
    const { type: I, input: j, path: C, id: x } = E, J = {
      id: x,
      method: I,
      params: {
        input: j,
        path: C
      }
    };
    return s[x] = {
      ws: l,
      type: I,
      callbacks: _,
      op: E
    }, i.push(J), u(), () => {
      const ce = s[x]?.callbacks;
      delete s[x], i = i.filter((B) => B.id !== x), ce?.complete?.(), l.readyState === a.OPEN && E.type === "subscription" && (i.push({
        id: x,
        method: "subscription.stop"
      }), u());
    };
  }
  return {
    close: () => {
      b = "closed", c?.(), v(), g(l), clearTimeout(f), f = null;
    },
    request: O,
    getConnection() {
      return l;
    }
  };
}
class xo extends Error {
  constructor(t) {
    super(t), this.name = "TRPCWebSocketClosedError", Object.setPrototypeOf(this, xo.prototype);
  }
}
function F9(e) {
  return (t) => {
    const { client: a } = e;
    return ({ op: n }) => M9.observable((r) => {
      const { type: c, path: i, id: s, context: o } = n, d = t.transformer.serialize(n.input), f = a.request({
        type: c,
        path: i,
        input: d,
        id: s,
        context: o
      }, {
        error(l) {
          r.error(l), f();
        },
        complete() {
          r.complete();
        },
        next(l) {
          const b = hs.transformResult(l, t);
          if (!b.ok) {
            r.error(hs.TRPCClientError.from(b.error));
            return;
          }
          r.next({
            result: b.result
          }), n.type !== "subscription" && (f(), r.complete());
        }
      });
      return () => {
        f();
      };
    });
  };
}
Kc.createWSClient = z9;
Kc.wsLink = F9;
Object.defineProperty(he, "__esModule", { value: !0 });
var Qd = mn, _0 = yo, y0 = gn, ef = S9, $n = pt, w0 = wo, Eo = Wc, V9 = vo, v0 = Kc;
class ko {
  $request({ type: t, input: a, path: n, context: r = {} }) {
    return _0.createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: t,
        path: n,
        input: a,
        context: r
      }
    }).pipe(Qd.share());
  }
  requestAsPromise(t) {
    const a = this.$request(t), { promise: n, abort: r } = Qd.observableToPromise(a);
    return new Promise((i, s) => {
      t.signal?.addEventListener("abort", r), n.then((o) => {
        i(o.result.data);
      }).catch((o) => {
        s(y0.TRPCClientError.from(o));
      });
    });
  }
  query(t, a, n) {
    return this.requestAsPromise({
      type: "query",
      path: t,
      input: a,
      context: n?.context,
      signal: n?.signal
    });
  }
  mutation(t, a, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: t,
      input: a,
      context: n?.context,
      signal: n?.signal
    });
  }
  subscription(t, a, n) {
    return this.$request({
      type: "subscription",
      path: t,
      input: a,
      context: n?.context
    }).subscribe({
      next(c) {
        c.result.type === "started" ? n.onStarted?.() : c.result.type === "stopped" ? n.onStopped?.() : n.onData?.(c.result.data);
      },
      error(c) {
        n.onError?.(c);
      },
      complete() {
        n.onComplete?.();
      }
    });
  }
  constructor(t) {
    this.requestId = 0;
    const a = (() => {
      const n = t.transformer;
      return n ? "input" in n ? t.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (r) => r,
          deserialize: (r) => r
        },
        output: {
          serialize: (r) => r,
          deserialize: (r) => r
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => a.input.serialize(n),
        deserialize: (n) => a.output.deserialize(n)
      },
      combinedTransformer: a
    }, this.links = t.links.map((n) => n(this.runtime));
  }
}
function q9(e) {
  return new ko(e);
}
function W9(e) {
  return new ko(e);
}
const K9 = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, x0 = (e) => K9[e];
function E0(e) {
  return ef.createFlatProxy((t) => e.hasOwnProperty(t) ? e[t] : ef.createRecursiveProxy(({ path: a, args: n }) => {
    const r = [
      t,
      ...a
    ], c = x0(r.pop()), i = r.join(".");
    return e[c](i, ...n);
  }));
}
function G9(e) {
  const t = new ko(e);
  return E0(t);
}
function Y9(e) {
  if (e)
    return e;
  if (typeof window < "u" && window.TextDecoder)
    return new window.TextDecoder();
  if (typeof globalThis < "u" && globalThis.TextDecoder)
    return new globalThis.TextDecoder();
  throw new Error("No TextDecoder implementation found");
}
async function X9(e) {
  const t = e.parse ?? JSON.parse, a = (n) => {
    if (e.signal?.aborted || !n || n === "}")
      return;
    const r = n.indexOf(":"), c = n.substring(2, r - 1), i = n.substring(r + 1);
    e.onSingle(Number(c), t(i));
  };
  await J9(e.readableStream, a, e.textDecoder);
}
async function J9(e, t, a) {
  let n = "";
  const r = (c) => {
    const s = a.decode(c).split(`
`);
    if (s.length === 1)
      n += s[0];
    else if (s.length > 1) {
      t(n + s[0]);
      for (let o = 1; o < s.length - 1; o++)
        t(s[o]);
      n = s[s.length - 1];
    }
  };
  "getReader" in e ? await e7(e, r) : await Q9(e, r), t(n);
}
function Q9(e, t) {
  return new Promise((a) => {
    e.on("data", t), e.on("end", a);
  });
}
async function e7(e, t) {
  const a = e.getReader();
  let n = await a.read();
  for (; !n.done; )
    t(n.value), n = await a.read();
}
const t7 = (e, t) => {
  const a = e.AbortController ? new e.AbortController() : null, n = $n.fetchHTTPResponse({
    ...e,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl: $n.getUrl,
    getBody: $n.getBody
  }, a), r = () => a?.abort(), c = n.then(async (i) => {
    if (!i.body)
      throw new Error("Received response without body");
    const s = {
      response: i
    };
    return X9({
      readableStream: i.body,
      onSingle: t,
      parse: (o) => ({
        json: JSON.parse(o),
        meta: s
      }),
      signal: a?.signal,
      textDecoder: e.textDecoder
    });
  });
  return {
    cancel: r,
    promise: c
  };
}, a7 = (e) => {
  const t = Y9(e.opts.textDecoder);
  return (a, n) => {
    const r = a.map((o) => o.path).join(","), c = a.map((o) => o.input), { cancel: i, promise: s } = t7({
      ...e,
      textDecoder: t,
      path: r,
      inputs: c,
      headers() {
        return e.opts.headers ? typeof e.opts.headers == "function" ? e.opts.headers({
          opList: a
        }) : e.opts.headers : {};
      }
    }, (o, d) => n(o, d));
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: s.then(() => []),
      cancel: i
    };
  };
}, n7 = w0.createHTTPBatchLink(a7), r7 = (e) => {
  if ("input" in e) {
    if (!(e.input instanceof FormData))
      throw new Error("Input is not FormData");
    return e.input;
  }
}, c7 = (e) => {
  if (e.type !== "mutation")
    throw new Error("We only handle mutations with formdata");
  return $n.httpRequest({
    ...e,
    getUrl() {
      return `${e.url}/${e.path}`;
    },
    getBody: r7
  });
}, i7 = Eo.httpLinkFactory({
  requester: c7
});
he.splitLink = _0.splitLink;
he.TRPCClientError = y0.TRPCClientError;
he.getFetch = $n.getFetch;
he.httpBatchLink = w0.httpBatchLink;
he.httpLink = Eo.httpLink;
he.httpLinkFactory = Eo.httpLinkFactory;
he.loggerLink = V9.loggerLink;
he.createWSClient = v0.createWSClient;
he.wsLink = v0.wsLink;
he.clientCallTypeToProcedureType = x0;
he.createTRPCClient = W9;
he.createTRPCClientProxy = E0;
he.createTRPCProxyClient = G9;
he.createTRPCUntypedClient = q9;
he.experimental_formDataLink = i7;
he.unstable_httpBatchStreamLink = n7;
var ta = {}, To = {};
function s7(e) {
  return e;
}
function o7(e) {
  return e.length === 0 ? s7 : e.length === 1 ? e[0] : function(a) {
    return e.reduce((n, r) => r(n), a);
  };
}
function d7(e) {
  return typeof e == "object" && e !== null && "subscribe" in e;
}
function f7(e) {
  const t = {
    subscribe(a) {
      let n = null, r = !1, c = !1, i = !1;
      function s() {
        if (n === null) {
          i = !0;
          return;
        }
        c || (c = !0, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = e({
        next(o) {
          r || a.next?.(o);
        },
        error(o) {
          r || (r = !0, a.error?.(o), s());
        },
        complete() {
          r || (r = !0, a.complete?.(), s());
        }
      }), i && s(), {
        unsubscribe: s
      };
    },
    pipe(...a) {
      return o7(a)(t);
    }
  };
  return t;
}
To.isObservable = d7;
To.observable = f7;
Object.defineProperty(ta, "__esModule", { value: !0 });
var k0 = To;
function l7(e) {
  return (t) => {
    let a = 0, n = null;
    const r = [];
    function c() {
      n || (n = t.subscribe({
        next(s) {
          for (const o of r)
            o.next?.(s);
        },
        error(s) {
          for (const o of r)
            o.error?.(s);
        },
        complete() {
          for (const s of r)
            s.complete?.();
        }
      }));
    }
    function i() {
      if (a === 0 && n) {
        const s = n;
        n = null, s.unsubscribe();
      }
    }
    return {
      subscribe(s) {
        return a++, r.push(s), c(), {
          unsubscribe() {
            a--, i();
            const o = r.findIndex((d) => d === s);
            o > -1 && r.splice(o, 1);
          }
        };
      }
    };
  };
}
function u7(e) {
  return (t) => ({
    subscribe(a) {
      let n = 0;
      return t.subscribe({
        next(c) {
          a.next?.(e(c, n++));
        },
        error(c) {
          a.error?.(c);
        },
        complete() {
          a.complete?.();
        }
      });
    }
  });
}
function b7(e) {
  return (t) => ({
    subscribe(a) {
      return t.subscribe({
        next(n) {
          e.next?.(n), a.next?.(n);
        },
        error(n) {
          e.error?.(n), a.error?.(n);
        },
        complete() {
          e.complete?.(), a.complete?.();
        }
      });
    }
  });
}
class So extends Error {
  constructor(t) {
    super(t), this.name = "ObservableAbortError", Object.setPrototypeOf(this, So.prototype);
  }
}
function h7(e) {
  let t;
  return {
    promise: new Promise((n, r) => {
      let c = !1;
      function i() {
        c || (c = !0, r(new So("This operation was aborted.")), s.unsubscribe());
      }
      const s = e.subscribe({
        next(o) {
          c = !0, n(o), i();
        },
        error(o) {
          c = !0, r(o), i();
        },
        complete() {
          c = !0, i();
        }
      });
      t = i;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: t
  };
}
ta.isObservable = k0.isObservable;
ta.observable = k0.observable;
ta.map = u7;
ta.observableToPromise = h7;
ta.share = l7;
ta.tap = b7;
var rt = {};
Object.defineProperty(rt, "__esModule", { value: !0 });
rt.isTRPCRequestWithId = rt.isTRPCRequest = rt.isTRPCResponse = rt.isTRPCMessage = void 0;
function tf(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
function p7(e) {
  return e == null;
}
function T0(e) {
  return !!(tf(e) && "trpc" in e && tf(e.trpc));
}
rt.isTRPCMessage = T0;
function Co(e) {
  return T0(e) && "id" in e.trpc && !p7(e.trpc.id);
}
function m7(e) {
  return Co(e) && ("error" in e.trpc || "result" in e.trpc);
}
rt.isTRPCResponse = m7;
function S0(e) {
  return Co(e) && "method" in e.trpc;
}
rt.isTRPCRequest = S0;
function g7(e) {
  return S0(e) && Co(e);
}
rt.isTRPCRequestWithId = g7;
Object.defineProperty(pn, "__esModule", { value: !0 });
pn.createBaseLink = void 0;
const Pi = he, _7 = ta, y7 = rt, w7 = (e) => (t) => ({ op: a }) => (0, _7.observable)((n) => {
  const r = [], { id: c, type: i, path: s } = a;
  try {
    const o = t.transformer.serialize(a.input), d = () => {
      n.error(new Pi.TRPCClientError("Port disconnected prematurely"));
    };
    e.addCloseListener(d), r.push(() => e.removeCloseListener(d));
    const f = (l) => {
      if (!(0, y7.isTRPCResponse)(l))
        return;
      const { trpc: b } = l;
      if (c === b.id) {
        if ("error" in b) {
          const u = t.transformer.deserialize(b.error);
          n.error(Pi.TRPCClientError.from(Object.assign(Object.assign({}, b), { error: u })));
          return;
        }
        n.next({
          result: Object.assign(Object.assign({}, b.result), (!b.result.type || b.result.type === "data") && {
            type: "data",
            data: t.transformer.deserialize(b.result.data)
          })
        }), (i !== "subscription" || b.result.type === "stopped") && n.complete();
      }
    };
    e.addMessageListener(f), r.push(() => e.removeMessageListener(f)), e.postMessage({
      trpc: {
        id: c,
        jsonrpc: void 0,
        method: i,
        params: { path: s, input: o }
      }
    });
  } catch (o) {
    n.error(new Pi.TRPCClientError(o instanceof Error ? o.message : "Unknown error"));
  }
  return () => {
    i === "subscription" && e.postMessage({
      trpc: {
        id: c,
        jsonrpc: void 0,
        method: "subscription.stop"
      }
    }), r.forEach((o) => o());
  };
});
pn.createBaseLink = w7;
Object.defineProperty(qc, "__esModule", { value: !0 });
qc.chromeLink = void 0;
const v7 = pn, x7 = (e) => (0, v7.createBaseLink)({
  postMessage(t) {
    e.port.postMessage(t);
  },
  addMessageListener(t) {
    e.port.onMessage.addListener(t);
  },
  removeMessageListener(t) {
    e.port.onMessage.removeListener(t);
  },
  addCloseListener(t) {
    e.port.onDisconnect.addListener(t);
  },
  removeCloseListener(t) {
    e.port.onDisconnect.removeListener(t);
  }
});
qc.chromeLink = x7;
var Gc = {};
Object.defineProperty(Gc, "__esModule", { value: !0 });
Gc.windowLink = void 0;
const E7 = pn, k7 = (e) => {
  var t;
  const a = /* @__PURE__ */ new Map(), n = e.window, r = (t = e.postWindow) !== null && t !== void 0 ? t : n;
  return (0, E7.createBaseLink)({
    postMessage(c) {
      r.postMessage(c, {
        targetOrigin: e.postOrigin
      });
    },
    addMessageListener(c) {
      const i = (s) => {
        c(s.data);
      };
      a.set(c, i), n.addEventListener("message", i);
    },
    removeMessageListener(c) {
      const i = a.get(c);
      i && n.removeEventListener("message", i);
    },
    addCloseListener(c) {
      n.addEventListener("beforeunload", c);
    },
    removeCloseListener(c) {
      n.removeEventListener("beforeunload", c);
    }
  });
};
Gc.windowLink = k7;
var Yc = {}, Xc = {};
Object.defineProperty(Xc, "__esModule", { value: !0 });
Xc.TRPC_BROWSER_LOADED_EVENT = void 0;
Xc.TRPC_BROWSER_LOADED_EVENT = "TRPC_BROWSER::POPUP_LOADED";
Object.defineProperty(Yc, "__esModule", { value: !0 });
Yc.popupLink = void 0;
const T7 = Xc, S7 = pn, C7 = (e) => {
  const t = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set();
  let n = null;
  async function r(c) {
    if (!n || n.closed) {
      n = e.createPopup(), await Promise.race([
        // wait til window is loaded (same origin)
        new Promise((i) => {
          var s;
          try {
            (s = n?.addEventListener) === null || s === void 0 || s.call(n, "load", i);
          } catch {
          }
        }),
        // this is needed for cross-origin popups as they don't have a load event
        new Promise((i) => {
          c.addEventListener("message", (s) => {
            s.data === T7.TRPC_BROWSER_LOADED_EVENT && i();
          });
        }),
        // expect the popup to load after 15s max, in case non of the above events fire
        new Promise((i) => {
          console.warn("Could not detect if popup loading succeeded after 15s timeout, continuing anyway"), setTimeout(i, 15e3);
        })
      ]);
      try {
        if (!n.addEventListener)
          throw new Error("popupWindow.addEventListener is not a function");
        n.addEventListener("beforeunload", () => {
          n = null;
        });
      } catch {
        const s = setInterval(() => {
          n && n.closed && (n = null, a.forEach((o) => {
            o();
          }), clearInterval(s));
        }, 1e3);
      }
    }
    return n;
  }
  return (0, S7.createBaseLink)({
    async postMessage(c) {
      return (await r(e.listenWindow)).postMessage(c, {
        targetOrigin: e.postOrigin
      });
    },
    addMessageListener(c) {
      const i = (s) => {
        c(s.data);
      };
      t.set(c, i), e.listenWindow.addEventListener("message", i);
    },
    removeMessageListener(c) {
      const i = t.get(c);
      i && e.listenWindow.removeEventListener("message", i);
    },
    addCloseListener(c) {
      e.listenWindow.addEventListener("beforeunload", c), a.add(c);
    },
    removeCloseListener(c) {
      e.listenWindow.removeEventListener("beforeunload", c), a.delete(c);
    }
  });
};
Yc.popupLink = C7;
(function(e) {
  var t = kn && kn.__createBinding || (Object.create ? function(n, r, c, i) {
    i === void 0 && (i = c);
    var s = Object.getOwnPropertyDescriptor(r, c);
    (!s || ("get" in s ? !r.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return r[c];
    } }), Object.defineProperty(n, i, s);
  } : function(n, r, c, i) {
    i === void 0 && (i = c), n[i] = r[c];
  }), a = kn && kn.__exportStar || function(n, r) {
    for (var c in n)
      c !== "default" && !Object.prototype.hasOwnProperty.call(r, c) && t(r, n, c);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), a(qc, e), a(Gc, e), a(Yc, e);
})(ls);
var te;
(function(e) {
  e.assertEqual = (r) => r;
  function t(r) {
  }
  e.assertIs = t;
  function a(r) {
    throw new Error();
  }
  e.assertNever = a, e.arrayToEnum = (r) => {
    const c = {};
    for (const i of r)
      c[i] = i;
    return c;
  }, e.getValidEnumValues = (r) => {
    const c = e.objectKeys(r).filter((s) => typeof r[r[s]] != "number"), i = {};
    for (const s of c)
      i[s] = r[s];
    return e.objectValues(i);
  }, e.objectValues = (r) => e.objectKeys(r).map(function(c) {
    return r[c];
  }), e.objectKeys = typeof Object.keys == "function" ? (r) => Object.keys(r) : (r) => {
    const c = [];
    for (const i in r)
      Object.prototype.hasOwnProperty.call(r, i) && c.push(i);
    return c;
  }, e.find = (r, c) => {
    for (const i of r)
      if (c(i))
        return i;
  }, e.isInteger = typeof Number.isInteger == "function" ? (r) => Number.isInteger(r) : (r) => typeof r == "number" && isFinite(r) && Math.floor(r) === r;
  function n(r, c = " | ") {
    return r.map((i) => typeof i == "string" ? `'${i}'` : i).join(c);
  }
  e.joinValues = n, e.jsonStringifyReplacer = (r, c) => typeof c == "bigint" ? c.toString() : c;
})(te || (te = {}));
var ps;
(function(e) {
  e.mergeShapes = (t, a) => ({
    ...t,
    ...a
    // second overwrites first
  });
})(ps || (ps = {}));
const R = te.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Dt = (e) => {
  switch (typeof e) {
    case "undefined":
      return R.undefined;
    case "string":
      return R.string;
    case "number":
      return isNaN(e) ? R.nan : R.number;
    case "boolean":
      return R.boolean;
    case "function":
      return R.function;
    case "bigint":
      return R.bigint;
    case "symbol":
      return R.symbol;
    case "object":
      return Array.isArray(e) ? R.array : e === null ? R.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? R.promise : typeof Map < "u" && e instanceof Map ? R.map : typeof Set < "u" && e instanceof Set ? R.set : typeof Date < "u" && e instanceof Date ? R.date : R.object;
    default:
      return R.unknown;
  }
}, T = te.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), A7 = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Ke extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const a = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, a) : this.__proto__ = a, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const a = t || function(c) {
      return c.message;
    }, n = { _errors: [] }, r = (c) => {
      for (const i of c.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(r);
        else if (i.code === "invalid_return_type")
          r(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          r(i.argumentsError);
        else if (i.path.length === 0)
          n._errors.push(a(i));
        else {
          let s = n, o = 0;
          for (; o < i.path.length; ) {
            const d = i.path[o];
            o === i.path.length - 1 ? (s[d] = s[d] || { _errors: [] }, s[d]._errors.push(a(i))) : s[d] = s[d] || { _errors: [] }, s = s[d], o++;
          }
        }
    };
    return r(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, te.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (a) => a.message) {
    const a = {}, n = [];
    for (const r of this.issues)
      r.path.length > 0 ? (a[r.path[0]] = a[r.path[0]] || [], a[r.path[0]].push(t(r))) : n.push(t(r));
    return { formErrors: n, fieldErrors: a };
  }
  get formErrors() {
    return this.flatten();
  }
}
Ke.create = (e) => new Ke(e);
const sr = (e, t) => {
  let a;
  switch (e.code) {
    case T.invalid_type:
      e.received === R.undefined ? a = "Required" : a = `Expected ${e.expected}, received ${e.received}`;
      break;
    case T.invalid_literal:
      a = `Invalid literal value, expected ${JSON.stringify(e.expected, te.jsonStringifyReplacer)}`;
      break;
    case T.unrecognized_keys:
      a = `Unrecognized key(s) in object: ${te.joinValues(e.keys, ", ")}`;
      break;
    case T.invalid_union:
      a = "Invalid input";
      break;
    case T.invalid_union_discriminator:
      a = `Invalid discriminator value. Expected ${te.joinValues(e.options)}`;
      break;
    case T.invalid_enum_value:
      a = `Invalid enum value. Expected ${te.joinValues(e.options)}, received '${e.received}'`;
      break;
    case T.invalid_arguments:
      a = "Invalid function arguments";
      break;
    case T.invalid_return_type:
      a = "Invalid function return type";
      break;
    case T.invalid_date:
      a = "Invalid date";
      break;
    case T.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (a = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (a = `${a} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? a = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? a = `Invalid input: must end with "${e.validation.endsWith}"` : te.assertNever(e.validation) : e.validation !== "regex" ? a = `Invalid ${e.validation}` : a = "Invalid";
      break;
    case T.too_small:
      e.type === "array" ? a = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? a = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? a = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? a = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : a = "Invalid input";
      break;
    case T.too_big:
      e.type === "array" ? a = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? a = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? a = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? a = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? a = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : a = "Invalid input";
      break;
    case T.custom:
      a = "Invalid input";
      break;
    case T.invalid_intersection_types:
      a = "Intersection results could not be merged";
      break;
    case T.not_multiple_of:
      a = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case T.not_finite:
      a = "Number must be finite";
      break;
    default:
      a = t.defaultError, te.assertNever(e);
  }
  return { message: a };
};
let C0 = sr;
function O7(e) {
  C0 = e;
}
function yc() {
  return C0;
}
const wc = (e) => {
  const { data: t, path: a, errorMaps: n, issueData: r } = e, c = [...a, ...r.path || []], i = {
    ...r,
    path: c
  };
  let s = "";
  const o = n.filter((d) => !!d).slice().reverse();
  for (const d of o)
    s = d(i, { data: t, defaultError: s }).message;
  return {
    ...r,
    path: c,
    message: r.message || s
  };
}, I7 = [];
function $(e, t) {
  const a = wc({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      yc(),
      sr
      // then global default map
    ].filter((n) => !!n)
  });
  e.common.issues.push(a);
}
class xe {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, a) {
    const n = [];
    for (const r of a) {
      if (r.status === "aborted")
        return V;
      r.status === "dirty" && t.dirty(), n.push(r.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, a) {
    const n = [];
    for (const r of a)
      n.push({
        key: await r.key,
        value: await r.value
      });
    return xe.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, a) {
    const n = {};
    for (const r of a) {
      const { key: c, value: i } = r;
      if (c.status === "aborted" || i.status === "aborted")
        return V;
      c.status === "dirty" && t.dirty(), i.status === "dirty" && t.dirty(), (typeof i.value < "u" || r.alwaysSet) && (n[c.value] = i.value);
    }
    return { status: t.value, value: n };
  }
}
const V = Object.freeze({
  status: "aborted"
}), A0 = (e) => ({ status: "dirty", value: e }), Ce = (e) => ({ status: "valid", value: e }), ms = (e) => e.status === "aborted", gs = (e) => e.status === "dirty", vc = (e) => e.status === "valid", xc = (e) => typeof Promise < "u" && e instanceof Promise;
var M;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
})(M || (M = {}));
class lt {
  constructor(t, a, n, r) {
    this._cachedPath = [], this.parent = t, this.data = a, this._path = n, this._key = r;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const af = (e, t) => {
  if (vc(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const a = new Ke(e.common.issues);
      return this._error = a, this._error;
    }
  };
};
function K(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: a, required_error: n, description: r } = e;
  if (t && (a || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: r } : { errorMap: (i, s) => i.code !== "invalid_type" ? { message: s.defaultError } : typeof s.data > "u" ? { message: n ?? s.defaultError } : { message: a ?? s.defaultError }, description: r };
}
class Y {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Dt(t.data);
  }
  _getOrReturnCtx(t, a) {
    return a || {
      common: t.parent.common,
      data: t.data,
      parsedType: Dt(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new xe(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Dt(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const a = this._parse(t);
    if (xc(a))
      throw new Error("Synchronous parse encountered promise.");
    return a;
  }
  _parseAsync(t) {
    const a = this._parse(t);
    return Promise.resolve(a);
  }
  parse(t, a) {
    const n = this.safeParse(t, a);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, a) {
    var n;
    const r = {
      common: {
        issues: [],
        async: (n = a?.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: a?.errorMap
      },
      path: a?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Dt(t)
    }, c = this._parseSync({ data: t, path: r.path, parent: r });
    return af(r, c);
  }
  async parseAsync(t, a) {
    const n = await this.safeParseAsync(t, a);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, a) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: a?.errorMap,
        async: !0
      },
      path: a?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Dt(t)
    }, r = this._parse({ data: t, path: n.path, parent: n }), c = await (xc(r) ? r : Promise.resolve(r));
    return af(n, c);
  }
  refine(t, a) {
    const n = (r) => typeof a == "string" || typeof a > "u" ? { message: a } : typeof a == "function" ? a(r) : a;
    return this._refinement((r, c) => {
      const i = t(r), s = () => c.addIssue({
        code: T.custom,
        ...n(r)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((o) => o ? !0 : (s(), !1)) : i ? !0 : (s(), !1);
    });
  }
  refinement(t, a) {
    return this._refinement((n, r) => t(n) ? !0 : (r.addIssue(typeof a == "function" ? a(n, r) : a), !1));
  }
  _refinement(t) {
    return new Xe({
      schema: this,
      typeName: z.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return kt.create(this, this._def);
  }
  nullable() {
    return Sa.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Ge.create(this, this._def);
  }
  promise() {
    return sn.create(this, this._def);
  }
  or(t) {
    return lr.create([this, t], this._def);
  }
  and(t) {
    return ur.create(this, t, this._def);
  }
  transform(t) {
    return new Xe({
      ...K(this._def),
      schema: this,
      typeName: z.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const a = typeof t == "function" ? t : () => t;
    return new gr({
      ...K(this._def),
      innerType: this,
      defaultValue: a,
      typeName: z.ZodDefault
    });
  }
  brand() {
    return new I0({
      typeName: z.ZodBranded,
      type: this,
      ...K(this._def)
    });
  }
  catch(t) {
    const a = typeof t == "function" ? t : () => t;
    return new Sc({
      ...K(this._def),
      innerType: this,
      catchValue: a,
      typeName: z.ZodCatch
    });
  }
  describe(t) {
    const a = this.constructor;
    return new a({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Pr.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const N7 = /^c[^\s-]{8,}$/i, R7 = /^[a-z][a-z0-9]*$/, P7 = /[0-9A-HJKMNP-TV-Z]{26}/, L7 = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, $7 = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, D7 = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, B7 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Z7 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, j7 = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function U7(e, t) {
  return !!((t === "v4" || !t) && B7.test(e) || (t === "v6" || !t) && Z7.test(e));
}
class Ve extends Y {
  constructor() {
    super(...arguments), this._regex = (t, a, n) => this.refinement((r) => t.test(r), {
      validation: a,
      code: T.invalid_string,
      ...M.errToObj(n)
    }), this.nonempty = (t) => this.min(1, M.errToObj(t)), this.trim = () => new Ve({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new Ve({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new Ve({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== R.string) {
      const c = this._getOrReturnCtx(t);
      return $(
        c,
        {
          code: T.invalid_type,
          expected: R.string,
          received: c.parsedType
        }
        //
      ), V;
    }
    const n = new xe();
    let r;
    for (const c of this._def.checks)
      if (c.kind === "min")
        t.data.length < c.value && (r = this._getOrReturnCtx(t, r), $(r, {
          code: T.too_small,
          minimum: c.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: c.message
        }), n.dirty());
      else if (c.kind === "max")
        t.data.length > c.value && (r = this._getOrReturnCtx(t, r), $(r, {
          code: T.too_big,
          maximum: c.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: c.message
        }), n.dirty());
      else if (c.kind === "length") {
        const i = t.data.length > c.value, s = t.data.length < c.value;
        (i || s) && (r = this._getOrReturnCtx(t, r), i ? $(r, {
          code: T.too_big,
          maximum: c.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: c.message
        }) : s && $(r, {
          code: T.too_small,
          minimum: c.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: c.message
        }), n.dirty());
      } else if (c.kind === "email")
        $7.test(t.data) || (r = this._getOrReturnCtx(t, r), $(r, {
          validation: "email",
          code: T.invalid_string,
          message: c.message
        }), n.dirty());
      else if (c.kind === "emoji")
        D7.test(t.data) || (r = this._getOrReturnCtx(t, r), $(r, {
          validation: "emoji",
          code: T.invalid_string,
          message: c.message
        }), n.dirty());
      else if (c.kind === "uuid")
        L7.test(t.data) || (r = this._getOrReturnCtx(t, r), $(r, {
          validation: "uuid",
          code: T.invalid_string,
          message: c.message
        }), n.dirty());
      else if (c.kind === "cuid")
        N7.test(t.data) || (r = this._getOrReturnCtx(t, r), $(r, {
          validation: "cuid",
          code: T.invalid_string,
          message: c.message
        }), n.dirty());
      else if (c.kind === "cuid2")
        R7.test(t.data) || (r = this._getOrReturnCtx(t, r), $(r, {
          validation: "cuid2",
          code: T.invalid_string,
          message: c.message
        }), n.dirty());
      else if (c.kind === "ulid")
        P7.test(t.data) || (r = this._getOrReturnCtx(t, r), $(r, {
          validation: "ulid",
          code: T.invalid_string,
          message: c.message
        }), n.dirty());
      else if (c.kind === "url")
        try {
          new URL(t.data);
        } catch {
          r = this._getOrReturnCtx(t, r), $(r, {
            validation: "url",
            code: T.invalid_string,
            message: c.message
          }), n.dirty();
        }
      else
        c.kind === "regex" ? (c.regex.lastIndex = 0, c.regex.test(t.data) || (r = this._getOrReturnCtx(t, r), $(r, {
          validation: "regex",
          code: T.invalid_string,
          message: c.message
        }), n.dirty())) : c.kind === "trim" ? t.data = t.data.trim() : c.kind === "includes" ? t.data.includes(c.value, c.position) || (r = this._getOrReturnCtx(t, r), $(r, {
          code: T.invalid_string,
          validation: { includes: c.value, position: c.position },
          message: c.message
        }), n.dirty()) : c.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : c.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : c.kind === "startsWith" ? t.data.startsWith(c.value) || (r = this._getOrReturnCtx(t, r), $(r, {
          code: T.invalid_string,
          validation: { startsWith: c.value },
          message: c.message
        }), n.dirty()) : c.kind === "endsWith" ? t.data.endsWith(c.value) || (r = this._getOrReturnCtx(t, r), $(r, {
          code: T.invalid_string,
          validation: { endsWith: c.value },
          message: c.message
        }), n.dirty()) : c.kind === "datetime" ? j7(c).test(t.data) || (r = this._getOrReturnCtx(t, r), $(r, {
          code: T.invalid_string,
          validation: "datetime",
          message: c.message
        }), n.dirty()) : c.kind === "ip" ? U7(t.data, c.version) || (r = this._getOrReturnCtx(t, r), $(r, {
          validation: "ip",
          code: T.invalid_string,
          message: c.message
        }), n.dirty()) : te.assertNever(c);
    return { status: n.value, value: t.data };
  }
  _addCheck(t) {
    return new Ve({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...M.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...M.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...M.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...M.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...M.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...M.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...M.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...M.errToObj(t) });
  }
  datetime(t) {
    var a;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof t?.precision > "u" ? null : t?.precision,
      offset: (a = t?.offset) !== null && a !== void 0 ? a : !1,
      ...M.errToObj(t?.message)
    });
  }
  regex(t, a) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...M.errToObj(a)
    });
  }
  includes(t, a) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: a?.position,
      ...M.errToObj(a?.message)
    });
  }
  startsWith(t, a) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...M.errToObj(a)
    });
  }
  endsWith(t, a) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...M.errToObj(a)
    });
  }
  min(t, a) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...M.errToObj(a)
    });
  }
  max(t, a) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...M.errToObj(a)
    });
  }
  length(t, a) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...M.errToObj(a)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
}
Ve.create = (e) => {
  var t;
  return new Ve({
    checks: [],
    typeName: z.ZodString,
    coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
    ...K(e)
  });
};
function M7(e, t) {
  const a = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, r = a > n ? a : n, c = parseInt(e.toFixed(r).replace(".", "")), i = parseInt(t.toFixed(r).replace(".", ""));
  return c % i / Math.pow(10, r);
}
class Yt extends Y {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== R.number) {
      const c = this._getOrReturnCtx(t);
      return $(c, {
        code: T.invalid_type,
        expected: R.number,
        received: c.parsedType
      }), V;
    }
    let n;
    const r = new xe();
    for (const c of this._def.checks)
      c.kind === "int" ? te.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), $(n, {
        code: T.invalid_type,
        expected: "integer",
        received: "float",
        message: c.message
      }), r.dirty()) : c.kind === "min" ? (c.inclusive ? t.data < c.value : t.data <= c.value) && (n = this._getOrReturnCtx(t, n), $(n, {
        code: T.too_small,
        minimum: c.value,
        type: "number",
        inclusive: c.inclusive,
        exact: !1,
        message: c.message
      }), r.dirty()) : c.kind === "max" ? (c.inclusive ? t.data > c.value : t.data >= c.value) && (n = this._getOrReturnCtx(t, n), $(n, {
        code: T.too_big,
        maximum: c.value,
        type: "number",
        inclusive: c.inclusive,
        exact: !1,
        message: c.message
      }), r.dirty()) : c.kind === "multipleOf" ? M7(t.data, c.value) !== 0 && (n = this._getOrReturnCtx(t, n), $(n, {
        code: T.not_multiple_of,
        multipleOf: c.value,
        message: c.message
      }), r.dirty()) : c.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), $(n, {
        code: T.not_finite,
        message: c.message
      }), r.dirty()) : te.assertNever(c);
    return { status: r.value, value: t.data };
  }
  gte(t, a) {
    return this.setLimit("min", t, !0, M.toString(a));
  }
  gt(t, a) {
    return this.setLimit("min", t, !1, M.toString(a));
  }
  lte(t, a) {
    return this.setLimit("max", t, !0, M.toString(a));
  }
  lt(t, a) {
    return this.setLimit("max", t, !1, M.toString(a));
  }
  setLimit(t, a, n, r) {
    return new Yt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: a,
          inclusive: n,
          message: M.toString(r)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Yt({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: M.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: M.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: M.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: M.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: M.toString(t)
    });
  }
  multipleOf(t, a) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: M.toString(a)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: M.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: M.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: M.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && te.isInteger(t.value));
  }
  get isFinite() {
    let t = null, a = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (a === null || n.value > a) && (a = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(a) && Number.isFinite(t);
  }
}
Yt.create = (e) => new Yt({
  checks: [],
  typeName: z.ZodNumber,
  coerce: e?.coerce || !1,
  ...K(e)
});
class Xt extends Y {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== R.bigint) {
      const c = this._getOrReturnCtx(t);
      return $(c, {
        code: T.invalid_type,
        expected: R.bigint,
        received: c.parsedType
      }), V;
    }
    let n;
    const r = new xe();
    for (const c of this._def.checks)
      c.kind === "min" ? (c.inclusive ? t.data < c.value : t.data <= c.value) && (n = this._getOrReturnCtx(t, n), $(n, {
        code: T.too_small,
        type: "bigint",
        minimum: c.value,
        inclusive: c.inclusive,
        message: c.message
      }), r.dirty()) : c.kind === "max" ? (c.inclusive ? t.data > c.value : t.data >= c.value) && (n = this._getOrReturnCtx(t, n), $(n, {
        code: T.too_big,
        type: "bigint",
        maximum: c.value,
        inclusive: c.inclusive,
        message: c.message
      }), r.dirty()) : c.kind === "multipleOf" ? t.data % c.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), $(n, {
        code: T.not_multiple_of,
        multipleOf: c.value,
        message: c.message
      }), r.dirty()) : te.assertNever(c);
    return { status: r.value, value: t.data };
  }
  gte(t, a) {
    return this.setLimit("min", t, !0, M.toString(a));
  }
  gt(t, a) {
    return this.setLimit("min", t, !1, M.toString(a));
  }
  lte(t, a) {
    return this.setLimit("max", t, !0, M.toString(a));
  }
  lt(t, a) {
    return this.setLimit("max", t, !1, M.toString(a));
  }
  setLimit(t, a, n, r) {
    return new Xt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: a,
          inclusive: n,
          message: M.toString(r)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Xt({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: M.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: M.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: M.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: M.toString(t)
    });
  }
  multipleOf(t, a) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: M.toString(a)
    });
  }
  get minValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t;
  }
}
Xt.create = (e) => {
  var t;
  return new Xt({
    checks: [],
    typeName: z.ZodBigInt,
    coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
    ...K(e)
  });
};
class or extends Y {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== R.boolean) {
      const n = this._getOrReturnCtx(t);
      return $(n, {
        code: T.invalid_type,
        expected: R.boolean,
        received: n.parsedType
      }), V;
    }
    return Ce(t.data);
  }
}
or.create = (e) => new or({
  typeName: z.ZodBoolean,
  coerce: e?.coerce || !1,
  ...K(e)
});
class ka extends Y {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== R.date) {
      const c = this._getOrReturnCtx(t);
      return $(c, {
        code: T.invalid_type,
        expected: R.date,
        received: c.parsedType
      }), V;
    }
    if (isNaN(t.data.getTime())) {
      const c = this._getOrReturnCtx(t);
      return $(c, {
        code: T.invalid_date
      }), V;
    }
    const n = new xe();
    let r;
    for (const c of this._def.checks)
      c.kind === "min" ? t.data.getTime() < c.value && (r = this._getOrReturnCtx(t, r), $(r, {
        code: T.too_small,
        message: c.message,
        inclusive: !0,
        exact: !1,
        minimum: c.value,
        type: "date"
      }), n.dirty()) : c.kind === "max" ? t.data.getTime() > c.value && (r = this._getOrReturnCtx(t, r), $(r, {
        code: T.too_big,
        message: c.message,
        inclusive: !0,
        exact: !1,
        maximum: c.value,
        type: "date"
      }), n.dirty()) : te.assertNever(c);
    return {
      status: n.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new ka({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, a) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: M.toString(a)
    });
  }
  max(t, a) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: M.toString(a)
    });
  }
  get minDate() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "min" && (t === null || a.value > t) && (t = a.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const a of this._def.checks)
      a.kind === "max" && (t === null || a.value < t) && (t = a.value);
    return t != null ? new Date(t) : null;
  }
}
ka.create = (e) => new ka({
  checks: [],
  coerce: e?.coerce || !1,
  typeName: z.ZodDate,
  ...K(e)
});
class Ec extends Y {
  _parse(t) {
    if (this._getType(t) !== R.symbol) {
      const n = this._getOrReturnCtx(t);
      return $(n, {
        code: T.invalid_type,
        expected: R.symbol,
        received: n.parsedType
      }), V;
    }
    return Ce(t.data);
  }
}
Ec.create = (e) => new Ec({
  typeName: z.ZodSymbol,
  ...K(e)
});
class dr extends Y {
  _parse(t) {
    if (this._getType(t) !== R.undefined) {
      const n = this._getOrReturnCtx(t);
      return $(n, {
        code: T.invalid_type,
        expected: R.undefined,
        received: n.parsedType
      }), V;
    }
    return Ce(t.data);
  }
}
dr.create = (e) => new dr({
  typeName: z.ZodUndefined,
  ...K(e)
});
class fr extends Y {
  _parse(t) {
    if (this._getType(t) !== R.null) {
      const n = this._getOrReturnCtx(t);
      return $(n, {
        code: T.invalid_type,
        expected: R.null,
        received: n.parsedType
      }), V;
    }
    return Ce(t.data);
  }
}
fr.create = (e) => new fr({
  typeName: z.ZodNull,
  ...K(e)
});
class cn extends Y {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Ce(t.data);
  }
}
cn.create = (e) => new cn({
  typeName: z.ZodAny,
  ...K(e)
});
class ba extends Y {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Ce(t.data);
  }
}
ba.create = (e) => new ba({
  typeName: z.ZodUnknown,
  ...K(e)
});
class Ct extends Y {
  _parse(t) {
    const a = this._getOrReturnCtx(t);
    return $(a, {
      code: T.invalid_type,
      expected: R.never,
      received: a.parsedType
    }), V;
  }
}
Ct.create = (e) => new Ct({
  typeName: z.ZodNever,
  ...K(e)
});
class kc extends Y {
  _parse(t) {
    if (this._getType(t) !== R.undefined) {
      const n = this._getOrReturnCtx(t);
      return $(n, {
        code: T.invalid_type,
        expected: R.void,
        received: n.parsedType
      }), V;
    }
    return Ce(t.data);
  }
}
kc.create = (e) => new kc({
  typeName: z.ZodVoid,
  ...K(e)
});
class Ge extends Y {
  _parse(t) {
    const { ctx: a, status: n } = this._processInputParams(t), r = this._def;
    if (a.parsedType !== R.array)
      return $(a, {
        code: T.invalid_type,
        expected: R.array,
        received: a.parsedType
      }), V;
    if (r.exactLength !== null) {
      const i = a.data.length > r.exactLength.value, s = a.data.length < r.exactLength.value;
      (i || s) && ($(a, {
        code: i ? T.too_big : T.too_small,
        minimum: s ? r.exactLength.value : void 0,
        maximum: i ? r.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: r.exactLength.message
      }), n.dirty());
    }
    if (r.minLength !== null && a.data.length < r.minLength.value && ($(a, {
      code: T.too_small,
      minimum: r.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: r.minLength.message
    }), n.dirty()), r.maxLength !== null && a.data.length > r.maxLength.value && ($(a, {
      code: T.too_big,
      maximum: r.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: r.maxLength.message
    }), n.dirty()), a.common.async)
      return Promise.all([...a.data].map((i, s) => r.type._parseAsync(new lt(a, i, a.path, s)))).then((i) => xe.mergeArray(n, i));
    const c = [...a.data].map((i, s) => r.type._parseSync(new lt(a, i, a.path, s)));
    return xe.mergeArray(n, c);
  }
  get element() {
    return this._def.type;
  }
  min(t, a) {
    return new Ge({
      ...this._def,
      minLength: { value: t, message: M.toString(a) }
    });
  }
  max(t, a) {
    return new Ge({
      ...this._def,
      maxLength: { value: t, message: M.toString(a) }
    });
  }
  length(t, a) {
    return new Ge({
      ...this._def,
      exactLength: { value: t, message: M.toString(a) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Ge.create = (e, t) => new Ge({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: z.ZodArray,
  ...K(t)
});
function ja(e) {
  if (e instanceof oe) {
    const t = {};
    for (const a in e.shape) {
      const n = e.shape[a];
      t[a] = kt.create(ja(n));
    }
    return new oe({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof Ge ? new Ge({
      ...e._def,
      type: ja(e.element)
    }) : e instanceof kt ? kt.create(ja(e.unwrap())) : e instanceof Sa ? Sa.create(ja(e.unwrap())) : e instanceof ut ? ut.create(e.items.map((t) => ja(t))) : e;
}
class oe extends Y {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), a = te.objectKeys(t);
    return this._cached = { shape: t, keys: a };
  }
  _parse(t) {
    if (this._getType(t) !== R.object) {
      const d = this._getOrReturnCtx(t);
      return $(d, {
        code: T.invalid_type,
        expected: R.object,
        received: d.parsedType
      }), V;
    }
    const { status: n, ctx: r } = this._processInputParams(t), { shape: c, keys: i } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof Ct && this._def.unknownKeys === "strip"))
      for (const d in r.data)
        i.includes(d) || s.push(d);
    const o = [];
    for (const d of i) {
      const f = c[d], l = r.data[d];
      o.push({
        key: { status: "valid", value: d },
        value: f._parse(new lt(r, l, r.path, d)),
        alwaysSet: d in r.data
      });
    }
    if (this._def.catchall instanceof Ct) {
      const d = this._def.unknownKeys;
      if (d === "passthrough")
        for (const f of s)
          o.push({
            key: { status: "valid", value: f },
            value: { status: "valid", value: r.data[f] }
          });
      else if (d === "strict")
        s.length > 0 && ($(r, {
          code: T.unrecognized_keys,
          keys: s
        }), n.dirty());
      else if (d !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const d = this._def.catchall;
      for (const f of s) {
        const l = r.data[f];
        o.push({
          key: { status: "valid", value: f },
          value: d._parse(
            new lt(r, l, r.path, f)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: f in r.data
        });
      }
    }
    return r.common.async ? Promise.resolve().then(async () => {
      const d = [];
      for (const f of o) {
        const l = await f.key;
        d.push({
          key: l,
          value: await f.value,
          alwaysSet: f.alwaysSet
        });
      }
      return d;
    }).then((d) => xe.mergeObjectSync(n, d)) : xe.mergeObjectSync(n, o);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return M.errToObj, new oe({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (a, n) => {
          var r, c, i, s;
          const o = (i = (c = (r = this._def).errorMap) === null || c === void 0 ? void 0 : c.call(r, a, n).message) !== null && i !== void 0 ? i : n.defaultError;
          return a.code === "unrecognized_keys" ? {
            message: (s = M.errToObj(t).message) !== null && s !== void 0 ? s : o
          } : {
            message: o
          };
        }
      } : {}
    });
  }
  strip() {
    return new oe({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new oe({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new oe({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new oe({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: z.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, a) {
    return this.augment({ [t]: a });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new oe({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const a = {};
    return te.objectKeys(t).forEach((n) => {
      t[n] && this.shape[n] && (a[n] = this.shape[n]);
    }), new oe({
      ...this._def,
      shape: () => a
    });
  }
  omit(t) {
    const a = {};
    return te.objectKeys(this.shape).forEach((n) => {
      t[n] || (a[n] = this.shape[n]);
    }), new oe({
      ...this._def,
      shape: () => a
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ja(this);
  }
  partial(t) {
    const a = {};
    return te.objectKeys(this.shape).forEach((n) => {
      const r = this.shape[n];
      t && !t[n] ? a[n] = r : a[n] = r.optional();
    }), new oe({
      ...this._def,
      shape: () => a
    });
  }
  required(t) {
    const a = {};
    return te.objectKeys(this.shape).forEach((n) => {
      if (t && !t[n])
        a[n] = this.shape[n];
      else {
        let c = this.shape[n];
        for (; c instanceof kt; )
          c = c._def.innerType;
        a[n] = c;
      }
    }), new oe({
      ...this._def,
      shape: () => a
    });
  }
  keyof() {
    return O0(te.objectKeys(this.shape));
  }
}
oe.create = (e, t) => new oe({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Ct.create(),
  typeName: z.ZodObject,
  ...K(t)
});
oe.strictCreate = (e, t) => new oe({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Ct.create(),
  typeName: z.ZodObject,
  ...K(t)
});
oe.lazycreate = (e, t) => new oe({
  shape: e,
  unknownKeys: "strip",
  catchall: Ct.create(),
  typeName: z.ZodObject,
  ...K(t)
});
class lr extends Y {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), n = this._def.options;
    function r(c) {
      for (const s of c)
        if (s.result.status === "valid")
          return s.result;
      for (const s of c)
        if (s.result.status === "dirty")
          return a.common.issues.push(...s.ctx.common.issues), s.result;
      const i = c.map((s) => new Ke(s.ctx.common.issues));
      return $(a, {
        code: T.invalid_union,
        unionErrors: i
      }), V;
    }
    if (a.common.async)
      return Promise.all(n.map(async (c) => {
        const i = {
          ...a,
          common: {
            ...a.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await c._parseAsync({
            data: a.data,
            path: a.path,
            parent: i
          }),
          ctx: i
        };
      })).then(r);
    {
      let c;
      const i = [];
      for (const o of n) {
        const d = {
          ...a,
          common: {
            ...a.common,
            issues: []
          },
          parent: null
        }, f = o._parseSync({
          data: a.data,
          path: a.path,
          parent: d
        });
        if (f.status === "valid")
          return f;
        f.status === "dirty" && !c && (c = { result: f, ctx: d }), d.common.issues.length && i.push(d.common.issues);
      }
      if (c)
        return a.common.issues.push(...c.ctx.common.issues), c.result;
      const s = i.map((o) => new Ke(o));
      return $(a, {
        code: T.invalid_union,
        unionErrors: s
      }), V;
    }
  }
  get options() {
    return this._def.options;
  }
}
lr.create = (e, t) => new lr({
  options: e,
  typeName: z.ZodUnion,
  ...K(t)
});
const Qr = (e) => e instanceof hr ? Qr(e.schema) : e instanceof Xe ? Qr(e.innerType()) : e instanceof pr ? [e.value] : e instanceof Jt ? e.options : e instanceof mr ? Object.keys(e.enum) : e instanceof gr ? Qr(e._def.innerType) : e instanceof dr ? [void 0] : e instanceof fr ? [null] : null;
class Jc extends Y {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== R.object)
      return $(a, {
        code: T.invalid_type,
        expected: R.object,
        received: a.parsedType
      }), V;
    const n = this.discriminator, r = a.data[n], c = this.optionsMap.get(r);
    return c ? a.common.async ? c._parseAsync({
      data: a.data,
      path: a.path,
      parent: a
    }) : c._parseSync({
      data: a.data,
      path: a.path,
      parent: a
    }) : ($(a, {
      code: T.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), V);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, a, n) {
    const r = /* @__PURE__ */ new Map();
    for (const c of a) {
      const i = Qr(c.shape[t]);
      if (!i)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of i) {
        if (r.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        r.set(s, c);
      }
    }
    return new Jc({
      typeName: z.ZodDiscriminatedUnion,
      discriminator: t,
      options: a,
      optionsMap: r,
      ...K(n)
    });
  }
}
function _s(e, t) {
  const a = Dt(e), n = Dt(t);
  if (e === t)
    return { valid: !0, data: e };
  if (a === R.object && n === R.object) {
    const r = te.objectKeys(t), c = te.objectKeys(e).filter((s) => r.indexOf(s) !== -1), i = { ...e, ...t };
    for (const s of c) {
      const o = _s(e[s], t[s]);
      if (!o.valid)
        return { valid: !1 };
      i[s] = o.data;
    }
    return { valid: !0, data: i };
  } else if (a === R.array && n === R.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const r = [];
    for (let c = 0; c < e.length; c++) {
      const i = e[c], s = t[c], o = _s(i, s);
      if (!o.valid)
        return { valid: !1 };
      r.push(o.data);
    }
    return { valid: !0, data: r };
  } else
    return a === R.date && n === R.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class ur extends Y {
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t), r = (c, i) => {
      if (ms(c) || ms(i))
        return V;
      const s = _s(c.value, i.value);
      return s.valid ? ((gs(c) || gs(i)) && a.dirty(), { status: a.value, value: s.data }) : ($(n, {
        code: T.invalid_intersection_types
      }), V);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([c, i]) => r(c, i)) : r(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
ur.create = (e, t, a) => new ur({
  left: e,
  right: t,
  typeName: z.ZodIntersection,
  ...K(a)
});
class ut extends Y {
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== R.array)
      return $(n, {
        code: T.invalid_type,
        expected: R.array,
        received: n.parsedType
      }), V;
    if (n.data.length < this._def.items.length)
      return $(n, {
        code: T.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), V;
    !this._def.rest && n.data.length > this._def.items.length && ($(n, {
      code: T.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), a.dirty());
    const c = [...n.data].map((i, s) => {
      const o = this._def.items[s] || this._def.rest;
      return o ? o._parse(new lt(n, i, n.path, s)) : null;
    }).filter((i) => !!i);
    return n.common.async ? Promise.all(c).then((i) => xe.mergeArray(a, i)) : xe.mergeArray(a, c);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new ut({
      ...this._def,
      rest: t
    });
  }
}
ut.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ut({
    items: e,
    typeName: z.ZodTuple,
    rest: null,
    ...K(t)
  });
};
class br extends Y {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== R.object)
      return $(n, {
        code: T.invalid_type,
        expected: R.object,
        received: n.parsedType
      }), V;
    const r = [], c = this._def.keyType, i = this._def.valueType;
    for (const s in n.data)
      r.push({
        key: c._parse(new lt(n, s, n.path, s)),
        value: i._parse(new lt(n, n.data[s], n.path, s))
      });
    return n.common.async ? xe.mergeObjectAsync(a, r) : xe.mergeObjectSync(a, r);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, a, n) {
    return a instanceof Y ? new br({
      keyType: t,
      valueType: a,
      typeName: z.ZodRecord,
      ...K(n)
    }) : new br({
      keyType: Ve.create(),
      valueType: t,
      typeName: z.ZodRecord,
      ...K(a)
    });
  }
}
class Tc extends Y {
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== R.map)
      return $(n, {
        code: T.invalid_type,
        expected: R.map,
        received: n.parsedType
      }), V;
    const r = this._def.keyType, c = this._def.valueType, i = [...n.data.entries()].map(([s, o], d) => ({
      key: r._parse(new lt(n, s, n.path, [d, "key"])),
      value: c._parse(new lt(n, o, n.path, [d, "value"]))
    }));
    if (n.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const o of i) {
          const d = await o.key, f = await o.value;
          if (d.status === "aborted" || f.status === "aborted")
            return V;
          (d.status === "dirty" || f.status === "dirty") && a.dirty(), s.set(d.value, f.value);
        }
        return { status: a.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const o of i) {
        const d = o.key, f = o.value;
        if (d.status === "aborted" || f.status === "aborted")
          return V;
        (d.status === "dirty" || f.status === "dirty") && a.dirty(), s.set(d.value, f.value);
      }
      return { status: a.value, value: s };
    }
  }
}
Tc.create = (e, t, a) => new Tc({
  valueType: t,
  keyType: e,
  typeName: z.ZodMap,
  ...K(a)
});
class Ta extends Y {
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== R.set)
      return $(n, {
        code: T.invalid_type,
        expected: R.set,
        received: n.parsedType
      }), V;
    const r = this._def;
    r.minSize !== null && n.data.size < r.minSize.value && ($(n, {
      code: T.too_small,
      minimum: r.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: r.minSize.message
    }), a.dirty()), r.maxSize !== null && n.data.size > r.maxSize.value && ($(n, {
      code: T.too_big,
      maximum: r.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: r.maxSize.message
    }), a.dirty());
    const c = this._def.valueType;
    function i(o) {
      const d = /* @__PURE__ */ new Set();
      for (const f of o) {
        if (f.status === "aborted")
          return V;
        f.status === "dirty" && a.dirty(), d.add(f.value);
      }
      return { status: a.value, value: d };
    }
    const s = [...n.data.values()].map((o, d) => c._parse(new lt(n, o, n.path, d)));
    return n.common.async ? Promise.all(s).then((o) => i(o)) : i(s);
  }
  min(t, a) {
    return new Ta({
      ...this._def,
      minSize: { value: t, message: M.toString(a) }
    });
  }
  max(t, a) {
    return new Ta({
      ...this._def,
      maxSize: { value: t, message: M.toString(a) }
    });
  }
  size(t, a) {
    return this.min(t, a).max(t, a);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Ta.create = (e, t) => new Ta({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: z.ZodSet,
  ...K(t)
});
class Ka extends Y {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== R.function)
      return $(a, {
        code: T.invalid_type,
        expected: R.function,
        received: a.parsedType
      }), V;
    function n(s, o) {
      return wc({
        data: s,
        path: a.path,
        errorMaps: [
          a.common.contextualErrorMap,
          a.schemaErrorMap,
          yc(),
          sr
        ].filter((d) => !!d),
        issueData: {
          code: T.invalid_arguments,
          argumentsError: o
        }
      });
    }
    function r(s, o) {
      return wc({
        data: s,
        path: a.path,
        errorMaps: [
          a.common.contextualErrorMap,
          a.schemaErrorMap,
          yc(),
          sr
        ].filter((d) => !!d),
        issueData: {
          code: T.invalid_return_type,
          returnTypeError: o
        }
      });
    }
    const c = { errorMap: a.common.contextualErrorMap }, i = a.data;
    return this._def.returns instanceof sn ? Ce(async (...s) => {
      const o = new Ke([]), d = await this._def.args.parseAsync(s, c).catch((b) => {
        throw o.addIssue(n(s, b)), o;
      }), f = await i(...d);
      return await this._def.returns._def.type.parseAsync(f, c).catch((b) => {
        throw o.addIssue(r(f, b)), o;
      });
    }) : Ce((...s) => {
      const o = this._def.args.safeParse(s, c);
      if (!o.success)
        throw new Ke([n(s, o.error)]);
      const d = i(...o.data), f = this._def.returns.safeParse(d, c);
      if (!f.success)
        throw new Ke([r(d, f.error)]);
      return f.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Ka({
      ...this._def,
      args: ut.create(t).rest(ba.create())
    });
  }
  returns(t) {
    return new Ka({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, a, n) {
    return new Ka({
      args: t || ut.create([]).rest(ba.create()),
      returns: a || ba.create(),
      typeName: z.ZodFunction,
      ...K(n)
    });
  }
}
class hr extends Y {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    return this._def.getter()._parse({ data: a.data, path: a.path, parent: a });
  }
}
hr.create = (e, t) => new hr({
  getter: e,
  typeName: z.ZodLazy,
  ...K(t)
});
class pr extends Y {
  _parse(t) {
    if (t.data !== this._def.value) {
      const a = this._getOrReturnCtx(t);
      return $(a, {
        received: a.data,
        code: T.invalid_literal,
        expected: this._def.value
      }), V;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
pr.create = (e, t) => new pr({
  value: e,
  typeName: z.ZodLiteral,
  ...K(t)
});
function O0(e, t) {
  return new Jt({
    values: e,
    typeName: z.ZodEnum,
    ...K(t)
  });
}
class Jt extends Y {
  _parse(t) {
    if (typeof t.data != "string") {
      const a = this._getOrReturnCtx(t), n = this._def.values;
      return $(a, {
        expected: te.joinValues(n),
        received: a.parsedType,
        code: T.invalid_type
      }), V;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const a = this._getOrReturnCtx(t), n = this._def.values;
      return $(a, {
        received: a.data,
        code: T.invalid_enum_value,
        options: n
      }), V;
    }
    return Ce(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  get Values() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  get Enum() {
    const t = {};
    for (const a of this._def.values)
      t[a] = a;
    return t;
  }
  extract(t) {
    return Jt.create(t);
  }
  exclude(t) {
    return Jt.create(this.options.filter((a) => !t.includes(a)));
  }
}
Jt.create = O0;
class mr extends Y {
  _parse(t) {
    const a = te.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== R.string && n.parsedType !== R.number) {
      const r = te.objectValues(a);
      return $(n, {
        expected: te.joinValues(r),
        received: n.parsedType,
        code: T.invalid_type
      }), V;
    }
    if (a.indexOf(t.data) === -1) {
      const r = te.objectValues(a);
      return $(n, {
        received: n.data,
        code: T.invalid_enum_value,
        options: r
      }), V;
    }
    return Ce(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
mr.create = (e, t) => new mr({
  values: e,
  typeName: z.ZodNativeEnum,
  ...K(t)
});
class sn extends Y {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    if (a.parsedType !== R.promise && a.common.async === !1)
      return $(a, {
        code: T.invalid_type,
        expected: R.promise,
        received: a.parsedType
      }), V;
    const n = a.parsedType === R.promise ? a.data : Promise.resolve(a.data);
    return Ce(n.then((r) => this._def.type.parseAsync(r, {
      path: a.path,
      errorMap: a.common.contextualErrorMap
    })));
  }
}
sn.create = (e, t) => new sn({
  type: e,
  typeName: z.ZodPromise,
  ...K(t)
});
class Xe extends Y {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === z.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t), r = this._def.effect || null;
    if (r.type === "preprocess") {
      const i = r.transform(n.data);
      return n.common.async ? Promise.resolve(i).then((s) => this._def.schema._parseAsync({
        data: s,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: i,
        path: n.path,
        parent: n
      });
    }
    const c = {
      addIssue: (i) => {
        $(n, i), i.fatal ? a.abort() : a.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (c.addIssue = c.addIssue.bind(c), r.type === "refinement") {
      const i = (s) => {
        const o = r.refinement(s, c);
        if (n.common.async)
          return Promise.resolve(o);
        if (o instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (n.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? V : (s.status === "dirty" && a.dirty(), i(s.value), { status: a.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((s) => s.status === "aborted" ? V : (s.status === "dirty" && a.dirty(), i(s.value).then(() => ({ status: a.value, value: s.value }))));
    }
    if (r.type === "transform")
      if (n.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!vc(i))
          return i;
        const s = r.transform(i.value, c);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: a.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((i) => vc(i) ? Promise.resolve(r.transform(i.value, c)).then((s) => ({ status: a.value, value: s })) : i);
    te.assertNever(r);
  }
}
Xe.create = (e, t, a) => new Xe({
  schema: e,
  typeName: z.ZodEffects,
  effect: t,
  ...K(a)
});
Xe.createWithPreprocess = (e, t, a) => new Xe({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: z.ZodEffects,
  ...K(a)
});
class kt extends Y {
  _parse(t) {
    return this._getType(t) === R.undefined ? Ce(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
kt.create = (e, t) => new kt({
  innerType: e,
  typeName: z.ZodOptional,
  ...K(t)
});
class Sa extends Y {
  _parse(t) {
    return this._getType(t) === R.null ? Ce(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Sa.create = (e, t) => new Sa({
  innerType: e,
  typeName: z.ZodNullable,
  ...K(t)
});
class gr extends Y {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t);
    let n = a.data;
    return a.parsedType === R.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: a.path,
      parent: a
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
gr.create = (e, t) => new gr({
  innerType: e,
  typeName: z.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...K(t)
});
class Sc extends Y {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), n = {
      ...a,
      common: {
        ...a.common,
        issues: []
      }
    }, r = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return xc(r) ? r.then((c) => ({
      status: "valid",
      value: c.status === "valid" ? c.value : this._def.catchValue({
        get error() {
          return new Ke(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: r.status === "valid" ? r.value : this._def.catchValue({
        get error() {
          return new Ke(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Sc.create = (e, t) => new Sc({
  innerType: e,
  typeName: z.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...K(t)
});
class Cc extends Y {
  _parse(t) {
    if (this._getType(t) !== R.nan) {
      const n = this._getOrReturnCtx(t);
      return $(n, {
        code: T.invalid_type,
        expected: R.nan,
        received: n.parsedType
      }), V;
    }
    return { status: "valid", value: t.data };
  }
}
Cc.create = (e) => new Cc({
  typeName: z.ZodNaN,
  ...K(e)
});
const H7 = Symbol("zod_brand");
class I0 extends Y {
  _parse(t) {
    const { ctx: a } = this._processInputParams(t), n = a.data;
    return this._def.type._parse({
      data: n,
      path: a.path,
      parent: a
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Pr extends Y {
  _parse(t) {
    const { status: a, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const c = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return c.status === "aborted" ? V : c.status === "dirty" ? (a.dirty(), A0(c.value)) : this._def.out._parseAsync({
          data: c.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const r = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return r.status === "aborted" ? V : r.status === "dirty" ? (a.dirty(), {
        status: "dirty",
        value: r.value
      }) : this._def.out._parseSync({
        data: r.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, a) {
    return new Pr({
      in: t,
      out: a,
      typeName: z.ZodPipeline
    });
  }
}
const N0 = (e, t = {}, a) => e ? cn.create().superRefine((n, r) => {
  var c, i;
  if (!e(n)) {
    const s = typeof t == "function" ? t(n) : typeof t == "string" ? { message: t } : t, o = (i = (c = s.fatal) !== null && c !== void 0 ? c : a) !== null && i !== void 0 ? i : !0, d = typeof s == "string" ? { message: s } : s;
    r.addIssue({ code: "custom", ...d, fatal: o });
  }
}) : cn.create(), z7 = {
  object: oe.lazycreate
};
var z;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(z || (z = {}));
const F7 = (e, t = {
  message: `Input not instance of ${e.name}`
}) => N0((a) => a instanceof e, t), R0 = Ve.create, P0 = Yt.create, V7 = Cc.create, q7 = Xt.create, L0 = or.create, W7 = ka.create, K7 = Ec.create, G7 = dr.create, Y7 = fr.create, X7 = cn.create, J7 = ba.create, Q7 = Ct.create, ep = kc.create, tp = Ge.create, ap = oe.create, np = oe.strictCreate, rp = lr.create, cp = Jc.create, ip = ur.create, sp = ut.create, op = br.create, dp = Tc.create, fp = Ta.create, lp = Ka.create, up = hr.create, bp = pr.create, hp = Jt.create, pp = mr.create, mp = sn.create, nf = Xe.create, gp = kt.create, _p = Sa.create, yp = Xe.createWithPreprocess, wp = Pr.create, vp = () => R0().optional(), xp = () => P0().optional(), Ep = () => L0().optional(), kp = {
  string: (e) => Ve.create({ ...e, coerce: !0 }),
  number: (e) => Yt.create({ ...e, coerce: !0 }),
  boolean: (e) => or.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Xt.create({ ...e, coerce: !0 }),
  date: (e) => ka.create({ ...e, coerce: !0 })
}, Tp = V;
var Pt = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: sr,
  setErrorMap: O7,
  getErrorMap: yc,
  makeIssue: wc,
  EMPTY_PATH: I7,
  addIssueToContext: $,
  ParseStatus: xe,
  INVALID: V,
  DIRTY: A0,
  OK: Ce,
  isAborted: ms,
  isDirty: gs,
  isValid: vc,
  isAsync: xc,
  get util() {
    return te;
  },
  get objectUtil() {
    return ps;
  },
  ZodParsedType: R,
  getParsedType: Dt,
  ZodType: Y,
  ZodString: Ve,
  ZodNumber: Yt,
  ZodBigInt: Xt,
  ZodBoolean: or,
  ZodDate: ka,
  ZodSymbol: Ec,
  ZodUndefined: dr,
  ZodNull: fr,
  ZodAny: cn,
  ZodUnknown: ba,
  ZodNever: Ct,
  ZodVoid: kc,
  ZodArray: Ge,
  ZodObject: oe,
  ZodUnion: lr,
  ZodDiscriminatedUnion: Jc,
  ZodIntersection: ur,
  ZodTuple: ut,
  ZodRecord: br,
  ZodMap: Tc,
  ZodSet: Ta,
  ZodFunction: Ka,
  ZodLazy: hr,
  ZodLiteral: pr,
  ZodEnum: Jt,
  ZodNativeEnum: mr,
  ZodPromise: sn,
  ZodEffects: Xe,
  ZodTransformer: Xe,
  ZodOptional: kt,
  ZodNullable: Sa,
  ZodDefault: gr,
  ZodCatch: Sc,
  ZodNaN: Cc,
  BRAND: H7,
  ZodBranded: I0,
  ZodPipeline: Pr,
  custom: N0,
  Schema: Y,
  ZodSchema: Y,
  late: z7,
  get ZodFirstPartyTypeKind() {
    return z;
  },
  coerce: kp,
  any: X7,
  array: tp,
  bigint: q7,
  boolean: L0,
  date: W7,
  discriminatedUnion: cp,
  effect: nf,
  enum: hp,
  function: lp,
  instanceof: F7,
  intersection: ip,
  lazy: up,
  literal: bp,
  map: dp,
  nan: V7,
  nativeEnum: pp,
  never: Q7,
  null: Y7,
  nullable: _p,
  number: P0,
  object: ap,
  oboolean: Ep,
  onumber: xp,
  optional: gp,
  ostring: vp,
  pipeline: wp,
  preprocess: yp,
  promise: mp,
  record: op,
  set: fp,
  strictObject: np,
  string: R0,
  symbol: K7,
  transformer: nf,
  tuple: sp,
  undefined: G7,
  union: rp,
  unknown: J7,
  void: ep,
  NEVER: Tp,
  ZodIssueCode: T,
  quotelessJson: A7,
  ZodError: Ke
});
const He = v9.create({
  isServer: !1,
  allowOutsideOfServer: !0
});
He.router({
  authorize: He.procedure.output(Pt.boolean()).mutation(async () => !0),
  connect: He.procedure.mutation(async () => ""),
  enable: He.procedure.output(Pt.string()).mutation(async () => ""),
  execute: He.procedure.input(zd.execute).output(Pt.string()).mutation(async () => ""),
  signMessage: He.procedure.input(zd.signMessage).output(Pt.string().array()).mutation(async () => []),
  getLoginStatus: He.procedure.output(
    Pt.object({
      isLoggedIn: Pt.boolean(),
      hasSession: Pt.boolean().optional(),
      isPreauthorized: Pt.boolean().optional()
    })
  ).mutation(async () => ({
    isLoggedIn: !0
  })),
  addStarknetChain: He.procedure.mutation((e) => {
    throw Error("not implemented");
  }),
  switchStarknetChain: He.procedure.mutation((e) => {
    throw Error("not implemented");
  }),
  watchAsset: He.procedure.mutation((e) => {
    throw Error("not implemented");
  }),
  updateModal: He.procedure.subscription(async () => {
  })
});
const Up = ({
  iframe: e,
  origin: t
}) => n9({
  links: [
    J8({
      enabled: (a) => process.env.NODE_ENV === "development" && typeof window < "u" || process.env.NODE_ENV === "development" && a.direction === "down" && a.result instanceof Error
    }),
    H8({
      condition(a) {
        if (!e && a.type === "subscription")
          throw new Error(
            "subscription is not supported without an iframe window"
          );
        return !!e;
      },
      true: ls.windowLink({
        window,
        postWindow: e,
        postOrigin: "*"
      }),
      false: ls.popupLink({
        listenWindow: window,
        createPopup: () => {
          const r = window?.outerWidth ?? window?.innerWidth ?? window?.screen.width ?? 0, c = window?.outerHeight ?? window?.innerHeight ?? window?.screen.height ?? 0, i = window?.screenLeft ?? window?.screenX ?? 0, o = (window?.screenTop ?? window?.screenY ?? 0) + c / 2 - 562 / 2, d = i + r / 2 - 886 / 2, f = window.open(
            `${t}/interstitialLogin`,
            "popup",
            `width=886,height=562,top=${o},left=${d},toolbar=no,menubar=no,scrollbars=no,location=no,status=no,popup=1`
          );
          if (!f)
            throw new Error("Could not open popup");
          return f;
        },
        postOrigin: "*"
      })
    })
  ]
}), Sp = (e) => {
  e.style.position = "fixed", e.style.top = "50%", e.style.left = "50%", e.style.transform = "translate(-50%, -50%)", e.style.width = "380px", e.style.height = "420px", e.style.border = "none", e.style.borderRadius = "40px", e.style.boxShadow = "0px 4px 20px rgba(0, 0, 0, 0.5)";
  const t = document.createElement("div");
  return t.style.display = "none", t.style.position = "fixed", t.style.top = "0", t.style.left = "0", t.style.right = "0", t.style.bottom = "0", t.style.backgroundColor = "rgba(0, 0, 0, 0.5)", t.style.zIndex = "99999", t.style.backdropFilter = "blur(4px)", t.appendChild(e), t;
}, Cp = (e) => {
  e.style.display = "block";
}, Ap = (e) => {
  e.style.display = "none";
}, Op = (e, t) => {
  e.style.height = `min(${t || 420}px, 100%)`;
}, Mp = async (e, t) => {
  const a = new URL(e);
  a.pathname = "/iframes/comms", e = a.toString();
  const n = document.createElement("iframe");
  n.src = e, n.loading = "eager", n.sandbox.add(
    "allow-scripts",
    "allow-same-origin",
    "allow-forms",
    "allow-top-navigation",
    "allow-popups"
  ), n.allow = "clipboard-write";
  const r = Sp(n);
  return r.style.display = t ? "block" : "none", window.document.body.appendChild(r), await new Promise((c, i) => {
    const s = setTimeout(
      () => i(new Error("Timeout while loading an iframe")),
      2e4
    );
    n.addEventListener("load", async () => {
      clearTimeout(s), c();
    });
  }), { iframe: n, modal: r };
}, { NetworkName: Ip } = Ll, Ua = Ip, Np = Ua.SN_GOERLI;
function Rp(e) {
  try {
    const { origin: t } = new URL(e);
    if (t.includes("localhost") || t.includes("127.0.0.1"))
      return Np;
    if (t.includes("hydrogen"))
      return Ua.SN_GOERLI;
    if (t.includes("staging"))
      return Ua.SN_MAIN;
    if (t.includes("dev"))
      return Ua.SN_GOERLI2;
    if (t.includes("argent.xyz"))
      return Ua.SN_MAIN;
  } catch {
    console.warn(
      "Could not determine network from target URL, defaulting to mainnet-alpha"
    );
  }
  return Ua.SN_MAIN;
}
const Hp = ws(
  async (e, t, a) => {
    const n = typeof window < "u" ? window : void 0;
    if (!n)
      throw new Error("window is not defined");
    const r = Rp(e), c = new Va({ network: r }), i = L5(
      {
        host: n.location.origin,
        id: "argentWebWallet",
        icon: "https://www.argent.xyz/favicon.ico",
        name: "Argent Web Wallet",
        version: "1.0.0"
      },
      c,
      t
    );
    if (a) {
      const { iframe: s, modal: o } = a;
      t.updateModal.subscribe(void 0, {
        onData(d) {
          switch (d.action) {
            case "show":
              setTimeout(() => Cp(o));
              break;
            case "hide":
              setTimeout(() => Ap(o));
              break;
            case "updateHeight":
              setTimeout(() => Op(s, d.height));
          }
        }
      });
    }
    return i;
  },
  (e) => `${e}`
);
export {
  Mp as createModal,
  Hp as getWebWalletStarknetObject,
  Up as trpcProxyClient
};
